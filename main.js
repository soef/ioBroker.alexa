/* eslint-disable no-unused-vars */
const Alexa = require('alexa-remote2');
const path = require('path');
const fs = require('fs');
const os = require('os');
const utils = require('@iobroker/adapter-core'); // Get common adapter utils
const shObjects = require('./lib/smarthomedevices.js');
const { rrulestr } = require('rrule');

let Sentry;
let SentryIntegrations;

let alexa;
let adapter;
let stopped = false;

const playerControls = {
    controlPlay: { command: 'play', val: false, common: { type: 'boolean', read: false, write: true, role: 'button.play'}},
    controlPause:{ command: 'pause', val: false, common: { type: 'boolean', read: false, write: true, role: 'button.pause'}}
};

const musicControls = {
    controlNext: { command: 'next', val: false, common: { type: 'boolean', read: false, write: true, role: 'button.next'}},
    controlPrevious: { command: 'previous', val: false, common: { type: 'boolean', read: false, write: true, role: 'button.prev'}},
    controlForward: { command: 'forward', val: false, common: { type: 'boolean', read: false, write: true, role: 'button.forward'}},
    controlRewind: { command: 'rewind', val: false, common: { type: 'boolean', read: false, write: true, role: 'button.reverse'}},
    controlShuffle: { command: 'shuffle', val: false, common: { type: 'boolean', read: false, write: true, role: 'media.mode.shuffle'}},
    controlRepeat: { command: 'repeat', val: false, common: { type: 'boolean', read: false, write: true, role: 'media.mode.repeat'}},
};

const listObjects = {
    'archived': { type: 'boolean', role: 'indicator' },
    'createdDate': { type: 'number', role: 'date' },
    'customerId': { type: 'string', role: 'text' },
    'defaultList': { type: 'boolean', role: 'indicator' },
    'itemId': { type: 'string', role: 'text' },
    'listReorderVersion': { type: 'number', role: 'value' },
    'name': { type: 'string', role: 'text' },
    'nbestItems': { type: 'string', role: 'text' },
    'originalAudioId': { type: 'string', role: 'text' },
    'type': { type: 'string', role: 'text' },
    'updatedDate': { type: 'number', role: 'date' },
    'version': { type: 'number', role: 'value' }
};

const listItemsObjects = {
    '#delete': { type: 'boolean', role: 'button' },
    'completed': { type: 'boolean', role: 'indicator', write: true },
    'createdDateTime': { type: 'number', role: 'date' },
    'customerId': { type: 'string', role: 'text' },
    'id': { type: 'string', role: 'text' },
    'listId': { type: 'string', role: 'text' },
    'shoppingListItem': { type: 'boolean', role: 'indicator' },
    'updatedDateTime': { type: 'number', role: 'date' },
    'value': { type: 'string', role: 'text', write: true },
    'version': { type: 'number', role: 'value' }
};

const commands = {
    'weather': { val: false, common: { type: 'boolean', read: false, write: true, role: 'button'}},
    'traffic': { val: false, common: { type: 'boolean', read: false, write: true, role: 'button'}},
    'flashbriefing': { val: false, common: { type: 'boolean', read: false, write: true, role: 'button'}},
    'goodmorning': { val: false, common: { type: 'boolean', read: false, write: true, role: 'button'}},
    'singasong': { val: false, common: { type: 'boolean', read: false, write: true, role: 'button'}},
    'tellstory': { val: false, common: { type: 'boolean', read: false, write: true, role: 'button'}},
    'deviceStop': { val: false, common: { type: 'boolean', read: false, write: true, role: 'button'}},
    'calendarToday': { val: false, common: { type: 'boolean', read: false, write: true, role: 'button'}},
    'calendarTomorrow': { val: false, common: { type: 'boolean', read: false, write: true, role: 'button'}},
    'calendarNext': { val: false, common: { type: 'boolean', read: false, write: true, role: 'button'}},
    'notification': { val: '', common: { type: 'string', read: false, write: true, role: 'text'}},
    'funfact': { val: false, common: { type: 'boolean', read: false, write: true, role: 'button'}},
    'joke': { val: false, common: { type: 'boolean', read: false, write: true, role: 'button'}},
    'cleanup': { val: false, common: { type: 'boolean', read: false, write: true, role: 'button'}},
    'curatedtts': { val: '', common: { type: 'string', read: false, write: true, role: 'text'}},
    'textCommand': { val: '', common: { type: 'string', read: false, write: true, role: 'text'}},
    'sound': { val: '', common: { type: 'string', read: false, write: true, role: 'text'}},
    'skill': { val: '', common: { type: 'string', read: false, write: true, role: 'text'}},
    'skillYours': { command: 'skill', val: '', common: { type: 'string', read: false, write: true, role: 'text'}}
};

const fireTVCommands = {
    'turnOn': { command: 'fireTVTurnOn', val: false, common: { type: 'boolean', read: false, write: true, role: 'button'}},
    'turnOff': { command: 'fireTVTurnOff', val: false, common: { type: 'boolean', read: false, write: true, role: 'button'}},
    'videoPause': { command: 'fireTVPauseVideo', val: false, common: { type: 'boolean', read: false, write: true, role: 'button'}},
    'videoResume': { command: 'fireTVResumeVideo', val: false, common: { type: 'boolean', read: false, write: true, role: 'button'}},
    'navigateHome': { command: 'fireTVNavigateHome', val: false, common: { type: 'boolean', read: false, write: true, role: 'button'}}
};

const allDevicesCommands = {
    'deviceStop': { command: 'deviceStopAll', val: false, common: { type: 'boolean', read: false, write: true, role: 'button'}},
    'deviceDoNotDisturb': { command: 'deviceDoNotDisturbAll', val: false, common: { type: 'mixed', read: false, write: true, role: 'state'}}
};

const knownDeviceType = {
    'A10A33FOX2NUBK':   {name: 'Echo Spot', commandSupport: true, icon: 'icons/spot.png'},
    'A10L5JEZTKKCZ8':   {name: 'Vobot-Clock', commandSupport: true}, // REMINDERS,VOLUME_SETTING,TUNE_IN,MUSIC_SKILL,TIMERS_AND_ALARMS,I_HEART_RADIO,PEONY,AUDIO_PLAYER,DEREGISTER_DEVICE,SLEEP,CHANGE_NAME,GOLDFISH,AUDIBLE,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,KINDLE_BOOKS,PERSISTENT_CONNECTION,MICROPHONE,DREAM_TRAINING,AMAZON_MUSIC
    'A11QM4H9HGV71H':   {name: 'Echo Show 5 3rd Gen', commandSupport: true, icon: 'icons/echo_show5.png'}, // SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,SUPPORTS_SOFTWARE_VERSION,DREAM_TRAINING,SIRIUSXM,TUNE_IN,CUSTOM_ALARM_TONE,TUPLE,ADAPTIVE_LISTENING,SUPPORTS_LOCALE_SWITCH,EQUALIZER_CONTROLLER_TREBLE,FLASH_BRIEFING,ALEXA_PRESENCE,PAIR_BT_SINK,AUDIO_PLAYER,LEMUR_ALPHA,TUPLE_CATEGORY_C,EQUALIZER_CONTROLLER_BASS,DISPLAY_BRIGHTNESS_ADJUST,MICROPHONE,LIVE_VIEW,AUDIO_CONTROLS,KINDLE_BOOKS,SALMON,EARCONS,CLOCK_FORMAT_24_HR,TAP_GESTURES_SINGLE_TAP,SHARKNADO,TIDAL,DISPLAY_ADAPTIVE_BRIGHTNESS,EQUALIZER_CONTROLLER_MIDRANGE,PANDORA,DIALOG_INTERFACE_VERSION,EFDCARDS,REMINDERS,SOUND_SETTINGS,SUPPORT_CALENDAR_ALERT,TIMERS_AND_ALARMS,CHANGE_NAME,DEEZER,AUDIBLE,ASCENDING_ALARM_VOLUME,VOLUME_SETTING,ALEXA_VOICE,DS_VOLUME_SETTING,DISPLAY_POWER_TOGGLE,APPLE_MUSIC,SET_LOCALE,VOICE_TRAINING,BT_PAIRING_FLOW_V2,AMAZON_MUSIC,I_HEART_RADIO,GUARD_EARCON,TAP_GESTURES,MUSIC_SKILL,GOLDFISH,FAR_FIELD_WAKE_WORD,DEREGISTER_DEVICE,SLEEP,SET_TIME_ZONE,SUPPORTS_LOCALE,SPEECH_RECOGNIZER_USS,MULTI_WAKEWORDS_SUPPORTED,ALEXA_GESTURES,PERSISTENT_CONNECTION,TIMERS_ALARMS_NOTIFICATIONS_VOLUME
    'A12GXV8XMS007S':   {name: 'FireTV', commandSupport: true, icon: 'icons/firetv.png'}, // ARTHUR_TARGET,BT_PAIRING_FLOW_V2,REMINDERS,CHANGE_NAME,ACTIVE_AFTER_FRO,SUPPORTS_LOCALE,FLASH_BRIEFING,ASCENDING_ALARM_VOLUME,TIMERS_AND_ALARMS,PAIR_BT_SINK,PERSISTENT_CONNECTION,SOUND_SETTINGS,SUPPORTS_SOFTWARE_VERSION,MULTI_WAKEWORDS_SUPPORTED,SHARKNADO,SPEECH_RECOGNIZER_USS,CUSTOM_ALARM_TONE,EARCONS,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,SUPPORTS_LOCALE_SWITCH,VOLUME_SETTING,MICROPHONE,DIALOG_INTERFACE_VERSION
    'A15996VY63BQ2D':   {name: 'Echo Show 8 2nd Gen', commandSupport: true, icon: 'icons/echo_show.png'}, // TIMERS_ALARMS_NOTIFICATIONS_VOLUME,SOUND_SETTINGS,DEREGISTER_DEVICE,DS_VOLUME_SETTING,BT_PAIRING_FLOW_V2,ADAPTIVE_LISTENING,SET_LOCALE,GUARD_EARCON,PERSISTENT_CONNECTION,LOCALIZATION,VOICE_TRAINING,ALEXA_VOICE,SUPPORT_CALENDAR_ALERT,DEEZER,MUSIC_SKILL,AUDIO_CONTROLS,TUNE_IN,EFDCARDS,SPEECH_RECOGNIZER_USS,EQUALIZER_CONTROLLER_TREBLE,DIALOG_INTERFACE_VERSION,TUPLE_CATEGORY_B,APPLE_MUSIC,SLEEP,PAIR_BT_SINK,SIRIUSXM,VISUAL_GESTURE,SUPPORTS_SOFTWARE_VERSION,TIMERS_AND_ALARMS,FAR_FIELD_WAKE_WORD,FLASH_BRIEFING,AUDIBLE,EQUALIZER_CONTROLLER_BASS,SUPPORTS_LOCALE,I_HEART_RADIO,SUPPORTS_LOCALE_SWITCH,KINDLE_BOOKS,CUSTOM_ALARM_TONE,SALMON,ALEXA_PRESENCE,MULTI_WAKEWORDS_SUPPORTED,CHANGE_NAME,TUPLE,MICROPHONE,EARCONS,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,AMAZON_MUSIC,VOLUME_SETTING,LEMUR_ALPHA,PANDORA,GOLDFISH,SHARKNADO,CLOCK_FORMAT_24_HR,LIVE_VIEW,POPTART,FACE_TO_TALK,TIDAL,REMINDERS,DREAM_TRAINING,AUDIO_PLAYER,ASCENDING_ALARM_VOLUME,EQUALIZER_CONTROLLER_MIDRANGE
    'A15ERDAKK5HQQG':   {name: 'Sonos', commandSupport: false, icon: 'icons/sonos.png'}, //? AUDIO_PLAYER,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,AMAZON_MUSIC,TUNE_IN,PANDORA,REMINDERS,I_HEART_RADIO,CHANGE_NAME,VOLUME_SETTING,PEONY
    'A17LGWINFBUTZZ':   {name: 'Anker Roav Viva Alexa', commandSupport: false}, // PERSISTENT_CONNECTION,PEONY,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,VOLUME_SETTING,MICROPHONE,AUDIO_PLAYER,AMAZON_MUSIC,TUNE_IN,I_HEART_RADIO,KINDLE_BOOKS,GOLDFISH,TIMERS_AND_ALARMS,DREAM_TRAINING,DEREGISTER_DEVICE,REMINDERS,SLEEP,AUDIBLE,CHANGE_NAME
    'A18O6U1UQFJ0XK':   {name: 'Echo Plus 2.Gen', commandSupport: true, icon: 'icons/echo_plus2.png'}, // PERSISTENT_CONNECTION,ACTIVE_AFTER_FRO,PAIR_BT_SINK,GADGETS,ASCENDING_ALARM_VOLUME,SET_LOCALE,MICROPHONE,VOLUME_SETTING,AUDIBLE,PAIR_BT_SOURCE,AUDIO_PLAYER,DREAM_TRAINING,FAR_FIELD_WAKE_WORD,UPDATE_WIFI,TUPLE,CUSTOM_ALARM_TONE,REQUIRES_OOBE_FOR_SETUP,EARCONS,KINDLE_BOOKS,SUPPORTS_SOFTWARE_VERSION,ALLOW_LOG_UPLOAD,POPTART,GOLDFISH,DEREGISTER_DEVICE,SLEEP,TAHOE_BYOD,VOICE_TRAINING,SOUND_SETTINGS,CHANGE_NAME,FLASH_BRIEFING,AUX_SETTINGS,REMINDERS,LEMUR_ALPHA,PAIR_REMOTE,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,TUPLE_CATEGORY_A,TIMERS_AND_ALARMS
    'A1C66CX2XD756O':   {name: 'Fire HD 8', commandSupport: true, icon: 'icons/firetab.png'}, // MICROPHONE,ASX_TIME_ZONE,VOLUME_SETTING,SUPPORTS_SOFTWARE_VERSION,REMINDERS,PEONY,TIMERS_AND_ALARMS,PERSISTENT_CONNECTION
    'A1DL2DVDQVK3Q':    {name: 'Apps', commandSupport: true, icon: 'icons/apps.png'}, // (PEONY,VOLUME_SETTING)
    'A1EIANJ7PNB0Q7':   {name: 'Echo Show 15', commandSupport: true, icon: 'icons/echo_show.png'}, // KINDLE_BOOKS,ASCENDING_ALARM_VOLUME,FLASH_BRIEFING,SUPPORTS_SOFTWARE_VERSION,ALEXA_PRESENCE,EFDCARDS,POPTART,PANDORA,DIALOG_INTERFACE_VERSION,SPEECH_RECOGNIZER_USS,VOICE_TRAINING,ADAPTIVE_LISTENING,VOLUME_SETTING,FAR_FIELD_WAKE_WORD,CUSTOM_ALARM_TONE,BT_PAIRING_FLOW_V2,MULTI_WAKEWORDS_SUPPORTED,ALEXA_VOICE,GOLDFISH,SOUND_SETTINGS,SIRIUSXM,EARCONS,EQUALIZER_CONTROLLER_TREBLE,AUDIBLE,EQUALIZER_CONTROLLER_BASS,LEMUR_ALPHA,TIMERS_AND_ALARMS,SUPPORTS_LOCALE,PERSISTENT_CONNECTION,SET_LOCALE,EQUALIZER_CONTROLLER_MIDRANGE,TUNE_IN,APPLE_MUSIC,DREAM_TRAINING,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,SLEEP,AUDIO_PLAYER,SALMON,TUPLE,CHANGE_NAME,GUARD_EARCON,DEEZER,TUPLE_CATEGORY_B,SUPPORTS_LOCALE_SWITCH,MUSIC_SKILL,AUDIO_CONTROLS,FACTORY_RESET_DEVICE,I_HEART_RADIO,REMINDERS,MICROPHONE,SHARKNADO,PAIR_BT_SINK,TIDAL,SUPPORT_CALENDAR_ALERT,DS_VOLUME_SETTING,TIMERS_ALARMS_NOTIFICATIONS_VOLUME,LIVE_VIEW,AMAZON_MUSIC
    'A1ETW4IXK2PYBP':   {name: 'Echo Auto', commandSupport: false}, // CHANGE_NAME,AUDIBLE,TIMERS_AND_ALARMS,REMINDERS,AUDIO_PLAYER,SUPPORTS_LOCALE,DEREGISTER_DEVICE,AMAZON_MUSIC,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,MUSIC_SKILL,I_HEART_RADIO,SET_LOCALE,CUSTOM_ALARM_TONE,SET_TIME_ZONE,TUNE_IN,MICROPHONE,PERSISTENT_CONNECTION,KINDLE_BOOKS,DREAM_TRAINING,SOUND_SETTINGS,GOLDFISH,VOLUME_SETTING,SUPPORTS_LOCALE_SWITCH,SLEEP
    'A1GIZO9LR81BL5':   {name: 'Yamaha ATS-1090', commandSupport: true}, // DREAM_TRAINING,SIRIUSXM,I_HEART_RADIO,KINDLE_BOOKS,AMAZON_MUSIC,VOLUME_SETTING,SOUND_SETTINGS,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,MUSIC_SKILL,DEEZER,AUDIBLE,DIALOG_INTERFACE_VERSION,APPLE_MUSIC,SLEEP,PERSISTENT_CONNECTION,CUSTOM_ALARM_TONE,TIMERS_AND_ALARMS,CHANGE_NAME,MICROPHONE,ADAPTIVE_LISTENING,FAR_FIELD,AUDIO_PLAYER,TIDAL,REMINDERS,GOLDFISH,TOUCH_INITIATED,TUNE_IN,DEREGISTER_DEVICE
    'A1H0CMF1XM0ZP4':   {name: 'Echo Dot/Bose', commandSupport: false}, // ??? // CHANGE_NAME,AUDIO_PLAYER,AMAZON_MUSIC,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,VOLUME_SETTING,LAMBDA // Bose: LAMBDA_DOWNCHANNEL,AUDIO_PLAYER,CHANGE_NAME,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,AMAZON_MUSIC,PANDORA,PEONY,I_HEART_RADIO,TUNE_IN,REMINDERS,VOLUME_SETTING
    'A1J16TEDOYCZTN':   {name: 'Fire tab', commandSupport: true, icon: 'icons/firetab.png'}, // (PEONY,MICROPHONE,SUPPORTS_SOFTWARE_VERSION,VOLUME_SETTING,ASX_TIME_ZONE,REMINDERS)
    'A1JJ0KFC4ZPNJ3':   {name: 'Echo Input', commandSupport: true, icon: 'icons/echo-input.png'}, // (ACTIVE_AFTER_FRO,TIMERS_AND_ALARMS,SET_LOCALE,TAHOE_BYOD,AUDIBLE,FLASH_BRIEFING,I_HEART_RADIO,GOLDFISH,DREAM_TRAINING,KINDLE_BOOKS,REMINDERS,GADGETS,ALLOW_LOG_UPLOAD,SOUND_SETTINGS,FAR_FIELD_WAKE_WORD,PAIR_BT_SINK,DEREGISTER_DEVICE,AMAZON_MUSIC,LEMUR_ALPHA,VOICE_TRAINING,MICROPHONE,CHANGE_NAME,SUPPORTS_SOFTWARE_VERSION,SALMON,PAIR_BT_SOURCE,CUSTOM_ALARM_TONE,SLEEP,PANDORA,AUDIO_PLAYER,ASCENDING_ALARM_VOLUME,DS_VOLUME_SETTING,POPTART,PERSISTENT_CONNECTION,REQUIRES_OOBE_FOR_SETUP,VOLUME_SETTING,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,MUSIC_SKILL,UPDATE_WIFI,EARCONS,TUNE_IN,SUPPORT_CALENDAR_ALERT)
    'A1JJTI4FXQ7JCR':   {name: 'Amazfit GTS 4 mini', commandSupport: true}, // SET_LOCALE,SPEECH_RECOGNIZER_USS,MULTI_WAKEWORDS_SUPPORTED,KINDLE_BOOKS,MUSIC_SKILL,CUSTOM_ALARM_TONE,SET_TIME_ZONE,EARCONS,APPLE_MUSIC,DEREGISTER_DEVICE,PERSISTENT_CONNECTION,DEEZER,MICROPHONE,SIRIUSXM,AMAZON_MUSIC,REMINDERS,ADAPTIVE_LISTENING,SUPPORTS_LOCALE,SOUND_SETTINGS,SLEEP,AUDIBLE,DREAM_TRAINING,I_HEART_RADIO,CHANGE_NAME,TOUCH_INITIATED,GOLDFISH,TIDAL,AUDIO_PLAYER,VOLUME_SETTING,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,TUNE_IN,TIMERS_AND_ALARMS,TIMERS_ALARMS_NOTIFICATIONS_VOLUME
    'A1LOQ8ZHF4G510':   {name: 'Samsung Soundbar Q990B', commandSupport: true}, // KINDLE_BOOKS,CHANGE_NAME,AUDIO_CONTROLS,I_HEART_RADIO,SUPPORTS_LOCALE,SLEEP,TUNE_IN,TOUCH_INITIATED,AUDIBLE,EARCONS,SET_LOCALE,APPLE_MUSIC,TIDAL,CUSTOM_ALARM_TONE,REMINDERS,DIALOG_INTERFACE_VERSION,ADAPTIVE_LISTENING,DEREGISTER_DEVICE,EQUALIZER_CONTROLLER_MIDRANGE,AUDIO_PLAYER,FAR_FIELD,SOUND_SETTINGS,DREAM_TRAINING,SET_TIME_ZONE,AMAZON_MUSIC,TIMERS_AND_ALARMS,ASCENDING_ALARM_VOLUME,EQUALIZER_CONTROLLER_BASS,DEEZER,VOLUME_SETTING,BT_PAIRING_FLOW_V2,EQUALIZER_CONTROLLER_TREBLE,SIRIUSXM,PERSISTENT_CONNECTION,MICROPHONE,GOLDFISH,SUPPORTS_LOCALE_SWITCH,MUSIC_SKILL,PAIR_BT_SINK,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,MULTI_WAKEWORDS_SUPPORTED,SPEECH_RECOGNIZER_USS
    'A1NL4BVLQ4L3N3':   {name: 'Echo Show', commandSupport: true, icon: 'icons/echo_show.png'}, // PAIR_BT_SINK,CUSTOM_ALARM_TONE,TIMERS_AND_ALARMS,TUNE_IN,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,SOUND_SETTINGS,SET_LOCALE,SLEEP,EARCONS,SHARKNADO,SUPPORTS_SOFTWARE_VERSION,TUPLE_CATEGORY_B,MICROPHONE,SALMON,ALLOW_LOG_UPLOAD,CHANGE_NAME,FAR_FIELD_WAKE_WORD,VOLUME_SETTING,AUDIO_PLAYER,I_HEART_RADIO,REMINDERS,ASCENDING_ALARM_VOLUME,PERSISTENT_CONNECTION,AUDIBLE,GADGETS,AMAZON_MUSIC,VOICE_TRAINING,FLASH_BRIEFING,GOLDFISH,FACTORY_RESET_DEVICE,TUPLE,PANDORA,DREAM_TRAINING,LEMUR_ALPHA,POPTART,KINDLE_BOOKS
    'A1NQ0LXWBGVQS9':   {name: 'Samsung The Frame ', commandSupport: true}, // DEREGISTER_DEVICE,AUDIO_PLAYER,SLEEP,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,GOLDFISH,MUSIC_SKILL,AUDIBLE,SPEECH_RECOGNIZER_USS,SOUND_SETTINGS,ASCENDING_ALARM_VOLUME,TIMERS_AND_ALARMS,SUPPORTS_LOCALE,CHANGE_NAME,DEEZER,CUSTOM_ALARM_TONE,SET_TIME_ZONE,TUNE_IN,AMAZON_MUSIC,SIRIUSXM,EARCONS,PERSISTENT_CONNECTION,TIDAL,APPLE_MUSIC,SET_LOCALE,DIALOG_INTERFACE_VERSION,REMINDERS,MICROPHONE,TOUCH_INITIATED,MULTI_WAKEWORDS_SUPPORTED,I_HEART_RADIO,VOLUME_SETTING,DREAM_TRAINING,HANDS_FREE,ADAPTIVE_LISTENING,SUPPORTS_LOCALE_SWITCH,KINDLE_BOOKS
    'A1P31Q3MOWSHOD':   {name: 'Anker Zalo Halo Speaker', commandSupport: false}, // (PEONY,PERSISTENT_CONNECTION,AMAZON_MUSIC,TUNE_IN,MICROPHONE,DREAM_TRAINING,DEREGISTER_DEVICE,KINDLE_BOOKS,MUSIC_SKILL,REMINDERS,AUDIO_PLAYER,GOLDFISH,TIMERS_AND_ALARMS,...
    'A1Q7QCGNMXAKYW':   {name: 'Fire tab 7 (Partial command support)', commandSupport: true, icon: 'icons/firetab.png'}, // (MICROPHONE,CUSTOM_ALARM_TONE,REMINDERS,SOUND_SETTINGS,DIALOG_INTERFACE_VERSION,ASX_TIME_ZONE,SUPPORTS_LOCALE,PERSISTENT_CONNECTION,VOLUME_SETTING,SUPPORTS_SOFTWARE_VERSION,TIMERS_AND_ALARMS,ASCENDING_ALARM_VOLUME,SUPPORTS_LOCALE_SWITCH,NO_TIME_ZONE_SETTING)
    'A1QKZ9D0IJY332':   {name: 'Samsung QLED (Partial command support)', commandSupport: true}, // (AUDIO_PLAYER,GOLDFISH,AMAZON_MUSIC,APPLE_MUSIC,SIRIUSXM,MICROPHONE,SPEECH_RECOGNIZER_USS,AUDIBLE,SET_TIME_ZONE,ASCENDING_ALARM_VOLUME,PERSISTENT_CONNECTION,VOLUME_SETTING,DEEZER,EARCONS,TUNE_IN,CUSTOM_ALARM_TONE,SUPPORTS_LOCALE,TIMERS_AND_ALARMS,MUSIC_SKILL,MULTI_WAKEWORDS_SUPPORTED,SUPPORTS_LOCALE_SWITCH,KINDLE_BOOKS,DEREGISTER_DEVICE,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,SOUND_SETTINGS,CHANGE_NAME,DREAM_TRAINING,SLEEP,REMINDERS,I_HEART_RADIO,SET_LOCALE,TIDAL)
    'A1RABVCI4QCIKC':   {name: 'Echo Dot 3.Gen', commandSupport: true, icon: 'icons/echo_dot3.png'}, // (SUPPORT_CALENDAR_ALERT,DEREGISTER_DEVICE,CUSTOM_ALARM_TONE,TUPLE_CATEGORY_A,AUDIBLE,ASCENDING_ALARM_VOLUME,EARCONS,SALMON,ACTIVE_AFTER_FRO,SLEEP,REQUIRES_OOBE_FOR_SETUP,FAR_FIELD_WAKE_WORD,FLASH_BRIEFING,PERSISTENT_CONNECTION,PANDORA,SUPPORTS_SOFTWARE_VERSION,I_HEART_RADIO,BT_PAIRING_FLOW_V2,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,AMAZON_MUSIC,PAIR_BT_SINK,ALEXA_PRESENCE,ALLOW_LOG_UPLOAD,SET_LOCALE,PAIR_REMOTE,UPDATE_WIFI,KINDLE_BOOKS,DREAM_TRAINING,MUSIC_SKILL,TIMERS_ALARMS_NOTIFICATIONS_VOLUME,DS_VOLUME_SETTING,TUNE_IN,REMINDERS,AUDIO_PLAYER,VOLUME_SETTING,PAIR_BT_SOURCE,GADGETS,GOLDFISH,CHANGE_NAME,VOICE_TRAINING,TUPLE,POPTART,TAHOE_BYOD,MICROPHONE,DIALOG_INTERFACE_VERSION,TIMERS_AND_ALARMS,SOUND_SETTINGS,LEMUR_ALPHA)
    'A1RTAM01W29CUP':   {name: 'Windows App', commandSupport: false, icon: 'icons/apps.png'}, // FLASH_BRIEFING,AUDIO_PLAYER,VOLUME_SETTING,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,SET_LOCALE,SOUND_SETTINGS,PERSISTENT_CONNECTION,KINDLE_BOOKS,CHANGE_NAME,TUNE_IN,TIMERS_AND_ALARMS,AUDIBLE,AMAZON_MUSIC,MICROPHONE,I_HEART_RADIO,EARCONS,REMINDERS,SLEEP,DREAM_TRAINING,DEREGISTER_DEVICE
    'A1X7HJX9QL16M5':   {name: 'Bespoken.io', commandSupport: false},
    'A1XWJRHALS1REP':   {name: 'Echo Show 5 2.Gen', commandSupport: true, icon: 'icons/echo_show5.png'}, // SUPPORTS_LOCALE_SWITCH,SOUND_SETTINGS,SPEECH_RECOGNIZER_USS,DREAM_TRAINING,VOLUME_SETTING,TIMERS_AND_ALARMS,SLEEP,ASCENDING_ALARM_VOLUME,GOLDFISH,AUDIO_CONTROLS,LEMUR_ALPHA,MUSIC_SKILL,CHANGE_NAME,SIRIUSXM,DIALOG_INTERFACE_VERSION,REMINDERS,APPLE_MUSIC,ADAPTIVE_LISTENING,TIMERS_ALARMS_NOTIFICATIONS_VOLUME,EQUALIZER_CONTROLLER_TREBLE,SUPPORTS_SOFTWARE_VERSION,ALEXA_PRESENCE,EFDCARDS,KINDLE_BOOKS,DEEZER,MICROPHONE,EQUALIZER_CONTROLLER_MIDRANGE,SUPPORTS_LOCALE,CUSTOM_ALARM_TONE,SALMON,VOICE_TRAINING,TIDAL,AMAZON_MUSIC,AUDIBLE,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,PAIR_BT_SINK,AUDIO_PLAYER,EARCONS,PERSISTENT_CONNECTION,SUPPORT_CALENDAR_ALERT,GUARD_EARCON,PANDORA,EQUALIZER_CONTROLLER_BASS,LIVE_VIEW,TUNE_IN,I_HEART_RADIO,SHARKNADO,SET_LOCALE,BT_PAIRING_FLOW_V2,DS_VOLUME_SETTING,FLASH_BRIEFING,MULTI_WAKEWORDS_SUPPORTED,DEREGISTER_DEVICE,FAR_FIELD_WAKE_WORD,ALEXA_VOICE
    'A1Z88NGR2BK6A2':   {name: 'Echo Show 8', commandSupport: true, icon: 'icons/echo_show.png'},
    'A1ZB65LA390I4K':   {name: 'Fire HD 10', commandSupport: true, icon: 'icons/firetab.png'}, // VOLUME_SETTING,CUSTOM_ALARM_TONE,REMINDERS,SOUND_SETTINGS,SUPPORTS_LOCALE,ASX_TIME_ZONE,MICROPHONE,PERSISTENT_CONNECTION,SUPPORTS_SOFTWARE_VERSION,DIALOG_INTERFACE_VERSION,TIMERS_AND_ALARMS,ASCENDING_ALARM_VOLUME,SUPPORTS_LOCALE_SWITCH,NO_TIME_ZONE_SETTING
    'A21Z3CGI8UIP0F':   {name: 'Apps', commandSupport: false, icon: 'icons/apps.png'}, // AUDIO_PLAYER,AMAZON_MUSIC,PANDORA,CHANGE_NAME,REMINDERS,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,I_HEART_RADIO,VOLUME_SETTING,TUNE_IN,LAMBDA_DOWNCHANNEL,PEONY
    'A222D4HGE48EOR':   {name: 'Alexa App Apple Watch', commandSupport: false}, // ASCENDING_ALARM_VOLUME,AUDIBLE,SET_LOCALE,TOUCH_INITIATED,REMINDERS,MUSIC_SKILL,VOLUME_SETTING,DEREGISTER_DEVICE,SPEECH_RECOGNIZER_USS,APPLE_MUSIC,SET_TIME_ZONE,EARCONS,DEEZER,I_HEART_RADIO,MICROPHONE,SLEEP,TIDAL,AMAZON_MUSIC,SUPPORTS_LOCALE_SWITCH,PEONY,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,CHANGE_NAME,TIMERS_AND_ALARMS,DIALOG_INTERFACE_VERSION,GOLDFISH,SIRIUSXM,AUDIO_PLAYER,SOUND_SETTINGS,ADAPTIVE_LISTENING,CUSTOM_ALARM_TONE,MULTI_WAKEWORDS_SUPPORTED,PERSISTENT_CONNECTION,SUPPORTS_LOCALE,DREAM_TRAINING,TUNE_IN,KINDLE_BOOKS
    'A25OJWHZA1MWNB':   {name: 'Samsung TV Neo', commandSupport: true}, // AMAZON_MUSIC,ASCENDING_ALARM_VOLUME,TIMERS_AND_ALARMS,HANDS_FREE,TUNE_IN,MULTI_WAKEWORDS_SUPPORTED,I_HEART_RADIO,DEEZER,PERSISTENT_CONNECTION,KINDLE_BOOKS,DREAM_TRAINING,SUPPORTS_LOCALE_SWITCH,DIALOG_INTERFACE_VERSION,VOLUME_SETTING,ADAPTIVE_LISTENING,GOLDFISH,SOUND_SETTINGS,SLEEP,CHANGE_NAME,MUSIC_SKILL,DEREGISTER_DEVICE,SPEECH_RECOGNIZER_USS,TIDAL,REMINDERS,SUPPORTS_LOCALE,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,AUDIBLE,FAR_FIELD,SET_LOCALE,EARCONS,SET_TIME_ZONE,CUSTOM_ALARM_TONE,APPLE_MUSIC,AUDIO_PLAYER,TOUCH_INITIATED,MICROPHONE,SIRIUSXM
    'A265XOI9586NML':   {name: 'FireTV Strick v3', commandSupport: true, icon: 'icons/firetv.png'}, // VOLUME_SETTING,CHANGE_NAME,ARTHUR_TARGET,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,REMINDERS,SPEECH_RECOGNIZER_USS,TIMERS_AND_ALARMS,CUSTOM_ALARM_TONE,SUPPORTS_LOCALE_SWITCH,EARCONS,PAIR_BT_SINK,ASCENDING_ALARM_VOLUME,ACTIVE_AFTER_FRO,SUPPORTS_SOFTWARE_VERSION,FLASH_BRIEFING,PERSISTENT_CONNECTION,DIALOG_INTERFACE_VERSION,MULTI_WAKEWORDS_SUPPORTED,SOUND_SETTINGS,SUPPORTS_LOCALE,MICROPHONE
    'A2825NDLA7WDZV':   {name: 'Apps', commandSupport: false, icon: 'icons/apps.png'}, // PEONY,VOLUME_SETTING
    'A2DS1Q2TPDJ48U':   {name: 'Echo Dot 5.Gen Clock', commandSupport: true, icon: 'icons/echo_dot4.png'}, // EQUALIZER_CONTROLLER_BASS,ALEXA_VOICE,SUPPORTS_LOCALE,DEREGISTER_DEVICE,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,ASCENDING_ALARM_VOLUME,EFDCARDS,ALEXA_GESTURES,DIALOG_INTERFACE_VERSION,SUPPORTS_SOFTWARE_VERSION,REQUIRES_OOBE_FOR_SETUP,PAIR_BT_SOURCE,PERSISTENT_CONNECTION,TUPLE_CATEGORY_A,TUPLE,SALMON,PANDORA,DISPLAY_BRIGHTNESS_ADJUST,SET_TIME_ZONE,ACTIVE_AFTER_FRO,DREAM_TRAINING,TEMPERATURE_SENSOR,ADAPTIVE_LISTENING,TAP_GESTURES,GOLDFISH,FAR_FIELD_WAKE_WORD,MOTION_SENSOR_RANGE_STRING,TIMERS_ALARMS_NOTIFICATIONS_VOLUME,SUPPORT_CALENDAR_ALERT,SUPPORTS_LOCALE_SWITCH,CUSTOM_ALARM_TONE,VOLUME_SETTING,BT_PAIRING_FLOW_V2,TUNE_IN,AMAZON_MUSIC,EQUALIZER_CONTROLLER_MIDRANGE,KINDLE_BOOKS,CLOCK_FORMAT_24_HR,PAIR_BT_SINK,MICROPHONE,GUARD_EARCON,ALEXA_PRESENCE,AUDIO_CONTROLS,SPEECH_RECOGNIZER_USS,LEMUR_ALPHA,I_HEART_RADIO,UPDATE_WIFI,LOCALIZATION,DEEZER,WAKE_WORD_SENSITIVITY,EQUALIZER_CONTROLLER_TREBLE,SET_LOCALE,AUDIO_PLAYER,TAHOE_BYOD,SLEEP,TIDAL,DISPLAY_POWER_TOGGLE,EARCONS,FLASH_BRIEFING,SOUND_SETTINGS,TAP_GESTURES_SINGLE_TAP,TIMERS_AND_ALARMS,DS_VOLUME_SETTING,MUSIC_SKILL,POPTART,DISPLAY_ADAPTIVE_BRIGHTNESS,REMINDERS,GADGETS,SIRIUSXM,AUDIBLE,CHANGE_NAME,MOTION_DETECTION,VOICE_TRAINING,APPLE_MUSIC,TAP_GESTURES_RESUME_MEDIA,MULTI_WAKEWORDS_SUPPORTED
    'A2E0SNTXJVT7WK':   {name: 'Fire TV V1', commandSupport: false, icon: 'icons/firetv.png'},
    'A2EZ3TS0L1S2KV':   {name: 'Sonos Beam Gen 2', commandSupport: true, icon: 'icons/sonos.png'}, // AUDIO_PLAYER,DEREGISTER_DEVICE,APPLE_MUSIC,SUPPORTS_LOCALE,DIALOG_INTERFACE_VERSION,TIDAL,SIRIUSXM,DREAM_TRAINING,ADAPTIVE_LISTENING,DEEZER,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,AUDIO_CONTROLS,TIMERS_AND_ALARMS,AMAZON_MUSIC,EQUALIZER_CONTROLLER_TREBLE,SET_LOCALE,VOLUME_SETTING,KINDLE_BOOKS,TUNE_IN,SET_TIME_ZONE,AUDIBLE,EQUALIZER_CONTROLLER_BASS,MULTI_WAKEWORDS_SUPPORTED,REMINDERS,CUSTOM_ALARM_TONE,SUPPORTS_LOCALE_SWITCH,I_HEART_RADIO,EARCONS,MUSIC_SKILL,CHANGE_NAME,GOLDFISH,PERSISTENT_CONNECTION,EQUALIZER_CONTROLLER_MIDRANGE,MICROPHONE,ASCENDING_ALARM_VOLUME,SOUND_SETTINGS,SLEEP,SPEECH_RECOGNIZER_USS
    'A2GFL5ZMWNE0PX':   {name: 'Fire TV', commandSupport: true, icon: 'icons/firetv.png'}, // SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,VOLUME_SETTING,SUPPORTS_SOFTWARE_VERSION,CHANGE_NAME,ACTIVE_AFTER_FRO,ARTHUR_TARGET,FLASH_BRIEFING
    'A2H4LV5GIZ1JFT':   {name: 'Echo 4 Clock', commandSupport: true, icon: 'icons/echo4.png'}, // ACTIVE_AFTER_FRO,SLEEP,TAHOE_BYOD,DISPLAY_ADAPTIVE_BRIGHTNESS,EQUALIZER_CONTROLLER_MIDRANGE,SALMON,VOLUME_SETTING,GOLDFISH,MULTI_WAKEWORDS_SUPPORTED,ALEXA_PRESENCE,PERSISTENT_CONNECTION,KINDLE_BOOKS,SET_LOCALE,APPLE_MUSIC,AUDIO_PLAYER,AMAZON_MUSIC,DS_VOLUME_SETTING,SUPPORTS_LOCALE,MOTION_DETECTION,EQUALIZER_CONTROLLER_BASS,SIRIUSXM,MICROPHONE,MUSIC_SKILL,DEEZER,AUDIO_CONTROLS,POPTART,CUSTOM_ALARM_TONE,SUPPORTS_LOCALE_SWITCH,PAIR_BT_SINK,DREAM_TRAINING,EARCONS,DIALOG_INTERFACE_VERSION,BT_PAIRING_FLOW_V2,DEREGISTER_DEVICE,EFDCARDS,TIMERS_AND_ALARMS,REQUIRES_OOBE_FOR_SETUP,EQUALIZER_CONTROLLER_TREBLE,TIMERS_ALARMS_NOTIFICATIONS_VOLUME,SUPPORT_CALENDAR_ALERT,CLOCK_FORMAT_24_HR,TUNE_IN,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,TUPLE,ALEXA_GESTURES,DISPLAY_BRIGHTNESS_ADJUST,UPDATE_WIFI,TUPLE_CATEGORY_A,SET_TIME_ZONE,ASCENDING_ALARM_VOLUME,PAIR_BT_SOURCE,GADGETS,CHANGE_NAME,VOICE_TRAINING,REMINDERS,SOUND_SETTINGS,I_HEART_RADIO,DISPLAY_POWER_TOGGLE,AUDIBLE,FLASH_BRIEFING,GUARD_EARCON,SUPPORTS_SOFTWARE_VERSION,FAR_FIELD_WAKE_WORD,PANDORA,TIDAL,LEMUR_ALPHA
    'A2IS7199CJBT71':    {name: 'LG TV', commandSupport: true}, // ASCENDING_ALARM_VOLUME,AUDIBLE,SET_LOCALE,TOUCH_INITIATED,REMINDERS,MUSIC_SKILL,VOLUME_SETTING,DEREGISTER_DEVICE,SPEECH_RECOGNIZER_USS,APPLE_MUSIC,SET_TIME_ZONE,EARCONS,DEEZER,I_HEART_RADIO,MICROPHONE,SLEEP,TIDAL,AMAZON_MUSIC,SUPPORTS_LOCALE_SWITCH,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,CHANGE_NAME,TIMERS_AND_ALARMS,DIALOG_INTERFACE_VERSION,GOLDFISH,SIRIUSXM,AUDIO_PLAYER,SOUND_SETTINGS,ADAPTIVE_LISTENING,CUSTOM_ALARM_TONE,MULTI_WAKEWORDS_SUPPORTED,PERSISTENT_CONNECTION,SUPPORTS_LOCALE,DREAM_TRAINING,TUNE_IN,KINDLE_BOOKS
    'A2IVLV5VM2W81':    {name: 'Apps', commandSupport: true, icon: 'icons/apps.png'}, // VOLUME_SETTING,MICROPHONE
    'A2J0R2SD7G9LPA':   {name: 'Tablet', commandSupport: false}, // SHARKNADO,FAR_FIELD_WAKE_WORD,SUPPORTS_LOCALE,TIMERS_ALARMS_NOTIFICATIONS_VOLUME,MUSIC_SKILL,I_HEART_RADIO,SALMON,EARCONS,TIMERS_AND_ALARMS,TUNE_IN,REMINDERS,SUPPORTS_LOCALE_SWITCH,DREAM_TRAINING,GADGETS,PERSISTENT_CONNECTION,SOUND_SETTINGS,VOICE_TRAINING,PANDORA,AUDIO_PLAYER,AUDIBLE,ASCENDING_ALARM_VOLUME,VOLUME_SETTING,CUSTOM_ALARM_TONE,GOLDFISH,AMAZON_MUSIC,FLASH_BRIEFING,SET_LOCALE,SLEEP,KINDLE_BOOKS,CHANGE_NAME,POPTART,MICROPHONE
    'A2JKHJ0PX4J3L3':   {name: 'FireTV Cube', commandSupport: true, icon: 'icons/echo_cube.png'}, // SUPPORTS_SOFTWARE_VERSION,SIRIUSXM,ACTIVE_AFTER_FRO,AMAZON_MUSIC,CUSTOM_ALARM_TONE,AUDIBLE,FAR_FIELD_WAKE_WORD,DREAM_TRAINING,EARCONS,I_HEART_RADIO,TIDAL,MULTI_WAKEWORDS_SUPPORTED,TUNE_IN,APPLE_MUSIC,KINDLE_BOOKS,DIALOG_INTERFACE_VERSION,REMINDERS,AUDIO_PLAYER,TIMERS_ALARMS_NOTIFICATIONS_VOLUME,FLASH_BRIEFING,SALMON,SUPPORT_CALENDAR_ALERT,SUPPORTS_LOCALE_SWITCH,VOICE_TRAINING,GOLDFISH,SOUND_SETTINGS,ARTHUR_TARGET,PERSISTENT_CONNECTION,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,PAIR_BT_SINK,SPEECH_RECOGNIZER_USS,MICROPHONE,DEEZER,TIMERS_AND_ALARMS,SET_LOCALE,ASCENDING_ALARM_VOLUME,PANDORA,MUSIC_SKILL,CHANGE_NAME,SLEEP,SUPPORTS_LOCALE
    'A2JMVL7QPIXTN5':   {name: 'Amazfit GTR 3 Pro', commandSupport: true}, // SET_LOCALE,SPEECH_RECOGNIZER_USS,MULTI_WAKEWORDS_SUPPORTED,KINDLE_BOOKS,MUSIC_SKILL,CUSTOM_ALARM_TONE,SET_TIME_ZONE,EARCONS,APPLE_MUSIC,DEREGISTER_DEVICE,PERSISTENT_CONNECTION,DEEZER,MICROPHONE,SIRIUSXM,AMAZON_MUSIC,REMINDERS,ADAPTIVE_LISTENING,SUPPORTS_LOCALE,SOUND_SETTINGS,SLEEP,AUDIBLE,DREAM_TRAINING,I_HEART_RADIO,CHANGE_NAME,TOUCH_INITIATED,GOLDFISH,TIDAL,AUDIO_PLAYER,VOLUME_SETTING,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,TUNE_IN,TIMERS_AND_ALARMS
    'A2L8KG0CT86ADW':   {name: 'RaspPi', commandSupport: false}, // KINDLE_BOOKS,DREAM_TRAINING,PEONY,VOLUME_SETTING,CHANGE_NAME,PAIR_BT_SINK,SLEEP,I_HEART_RADIO,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,PERSISTENT_CONNECTION,TUNE_IN,TIMERS_AND_ALARMS,MICROPHONE,AUDIBLE,DEREGISTER_DEVICE,GOLDFISH,AUDIO_PLAYER,REMINDERS,AMAZON_MUSIC
    'A2LWARUGJLBYEW':   {name: 'Fire TV Stick V2', commandSupport: true, icon: 'icons/firetv.png'}, // SOUND_SETTINGS,CHANGE_NAME,ARTHUR_TARGET,PERSISTENT_CONNECTION,DIALOG_INTERFACE_VERSION,ASCENDING_ALARM_VOLUME,VOLUME_SETTING,MICROPHONE,TIMERS_AND_ALARMS,SUPPORTS_LOCALE,CUSTOM_ALARM_TONE,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,ACTIVE_AFTER_FRO,FLASH_BRIEFING,REMINDERS,SUPPORTS_LOCALE_SWITCH,SUPPORTS_SOFTWARE_VERSION
    'A2M35JJZWCQOMZ':   {name: 'Echo Plus', commandSupport: true, icon: 'icons/echo.png'}, // PAIR_BT_SINK,SOUND_SETTINGS,FAR_FIELD_WAKE_WORD,CUSTOM_ALARM_TONE,MICROPHONE,VOLUME_SETTING,ACTIVE_AFTER_FRO,POPTART,REMINDERS,AMAZON_MUSIC,TUNE_IN,CHANGE_NAME,I_HEART_RADIO,DEREGISTER_FACTORY_RESET,SUPPORTS_SOFTWARE_VERSION,EARCONS,PAIR_REMOTE,PERSISTENT_CONNECTION,LEMUR_ALPHA,SALMON,DREAM_TRAINING,UPDATE_WIFI,VOICE_TRAINING,TIMERS_AND_ALARMS,ASCENDING_ALARM_VOLUME,AUDIBLE,SLEEP,AUDIO_PLAYER,PAIR_BT_SOURCE,FLASH_BRIEFING,SET_LOCALE,REQUIRES_OOBE_FOR_SETUP,DEREGISTER_DEVICE,PANDORA,GOLDFISH,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,KINDLE_BOOKS
    'A2M4YX06LWP8WI':   {name: 'Fire Tab', commandSupport: false, icon: 'icons/firetab.png'}, // SUPPORTS_SOFTWARE_VERSION,VOLUME_SETTING,ASX_TIME_ZONE,MICROPHONE,PEONY
    'A2OSP3UA4VC85F':   {name: 'Sonos', commandSupport: true, icon: 'icons/sonos.png'}, // DEREGISTER_DEVICE,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,CHANGE_NAME,KINDLE_BOOKS,AUDIO_PLAYER,TIMERS_AND_ALARMS,VOLUME_SETTING,PEONY,AMAZON_MUSIC,REMINDERS,SLEEP,I_HEART_RADIO,AUDIBLE,GOLDFISH,TUNE_IN,DREAM_TRAINING,PERSISTENT_CONNECTION
    'A2T0P32DY3F7VB':   {name: 'echosim.io', commandSupport: false},
    'A2TF17PFR55MTB':   {name: 'Apps', commandSupport: true, icon: 'icons/apps.png'}, // VOLUME_SETTING,MICROPHONE
    'A2U21SRK4QGSE1':   {name: 'Echo Dot 4.Gen', commandSupport: true, icon: 'icons/echo_dot4.png'}, // SPEECH_RECOGNIZER_USS,MUSIC_SKILL,AMAZON_MUSIC,BT_PAIRING_FLOW_V2,SET_LOCALE,SLEEP,TIDAL,REQUIRES_OOBE_FOR_SETUP,EQUALIZER_CONTROLLER_TREBLE,TUNE_IN,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,KINDLE_BOOKS,SUPPORTS_SOFTWARE_VERSION,MICROPHONE,PERSISTENT_CONNECTION,SUPPORTS_LOCALE,FAR_FIELD_WAKE_WORD,UPDATE_WIFI,SALMON,TIMERS_AND_ALARMS,PAIR_BT_SINK,VOICE_TRAINING,EFDCARDS,TUPLE,GADGETS,ACTIVE_AFTER_FRO,TIMERS_ALARMS_NOTIFICATIONS_VOLUME,POPTART,GOLDFISH,SUPPORTS_LOCALE_SWITCH,LEMUR_ALPHA,TUPLE_CATEGORY_A,DS_VOLUME_SETTING,APPLE_MUSIC,GUARD_EARCON,EQUALIZER_CONTROLLER_BASS,AUDIBLE,TAHOE_BYOD,FLASH_BRIEFING,SOUND_SETTINGS,I_HEART_RADIO,ASCENDING_ALARM_VOLUME,DREAM_TRAINING,ALEXA_GESTURES,CUSTOM_ALARM_TONE,ALEXA_PRESENCE,EARCONS,CHANGE_NAME,VOLUME_SETTING,DIALOG_INTERFACE_VERSION,SIRIUSXM,AUDIO_PLAYER,MOTION_DETECTION,MULTI_WAKEWORDS_SUPPORTED,SUPPORT_CALENDAR_ALERT,DEREGISTER_DEVICE,AUDIO_CONTROLS,DEEZER,PAIR_BT_SOURCE,PANDORA,EQUALIZER_CONTROLLER_MIDRANGE,REMINDERS,SET_TIME_ZONE
    'A2XPGY5LRKB9BE':   {name: 'Fitbit Versa 2', commandSupport: false}, // ARCONS,KINDLE_BOOKS,REMINDERS,AMAZON_MUSIC,DEREGISTER_DEVICE,TIDAL,SLEEP,CHANGE_NAME,MULTI_WAKEWORDS_SUPPORTED,PEONY,SUPPORTS_LOCALE,APPLE_MUSIC,PERSISTENT_CONNECTION,I_HEART_RADIO,SOUND_SETTINGS,SET_TIME_ZONE,DIALOG_INTERFACE_VERSION,AUDIBLE,DEEZER,TUNE_IN,AUDIO_PLAYER,MICROPHONE,MUSIC_SKILL,SIRIUSXM,SUPPORTS_LOCALE_SWITCH,DREAM_TRAINING,TOUCH_INITIATED,SET_LOCALE,GOLDFISH,SPEECH_RECOGNIZER_USS,VOLUME_SETTING,ADAPTIVE_LISTENING,TIMERS_AND_ALARMS,CUSTOM_ALARM_TONE,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY
    'A2Y04QPFCANLPQ':   {name: 'Bose QC35-II', commandSupport: false}, // KINDLE_BOOKS,SLEEP,VOLUME_SETTING,SIRIUSXM,I_HEART_RADIO,TUNE_IN,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,CHANGE_NAME,APPLE_MUSIC,PERSISTENT_CONNECTION,AUDIBLE,MUSIC_SKILL,TOUCH_INITIATED,ADAPTIVE_LISTENING,DEREGISTER_DEVICE,DREAM_TRAINING,TIDAL,AUDIO_PLAYER,MICROPHONE,TIMERS_AND_ALARMS,GOLDFISH,DEEZER,AMAZON_MUSIC
    'A2Z8O30CD35N8F':   {name: 'Sonos Arc', commandSupport: true}, // SET_TIME_ZONE,APPLE_MUSIC,DEEZER,SUPPORTS_LOCALE,SOUND_SETTINGS,CHANGE_NAME,SET_LOCALE,EQUALIZER_CONTROLLER_BASS,SUPPORTS_LOCALE_SWITCH,DIALOG_INTERFACE_VERSION,PERSISTENT_CONNECTION,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,MUSIC_SKILL,DREAM_TRAINING,AMAZON_MUSIC,MULTI_WAKEWORDS_SUPPORTED,VOLUME_SETTING,REMINDERS,TIMERS_AND_ALARMS,AUDIBLE,KINDLE_BOOKS,CUSTOM_ALARM_TONE,AUDIO_PLAYER,AUDIO_CONTROLS,I_HEART_RADIO,EQUALIZER_CONTROLLER_TREBLE,DEREGISTER_DEVICE,ASCENDING_ALARM_VOLUME,GOLDFISH,SPEECH_RECOGNIZER_USS,TUNE_IN,MICROPHONE,TIDAL,SLEEP,SIRIUSXM,EARCONS,EQUALIZER_CONTROLLER_MIDRANGE
    'A303PJF6ISQ7IC':   {name: 'Echo Auto', commandSupport: false}, // ACTIVE_AFTER_FRO,TUNE_IN,LAMBDA_DOWNCHANNEL,MICROPHONE,SUPPORTS_LOCALE,CHANGE_NAME,EARCONS,FAR_FIELD_WAKE_WORD,AUDIBLE,REQUIRES_OOBE_FOR_SETUP,SUPPORTS_LOCALE_SWITCH,PANDORA,SUPPORTS_CONNECTED_HOME,FLASH_BRIEFING,KINDLE_BOOKS,SUPPORTS_SOFTWARE_VERSION,PAIR_BT_SINK,REMINDERS,I_HEART_RADIO,AUDIO_PLAYER,VOLUME_SETTING,AMAZON_MUSIC,AUDIO_CONTROLS,FACTORY_RESET_DEVICE,DEREGISTER_DEVICE
    'A30YDR2MK8HMRV':   {name: 'Echo Dot 3.Gen Clock', commandSupport: true, icon: 'icons/echo_dot3.png'}, // DREAM_TRAINING,DISPLAY_BRIGHTNESS_ADJUST,SUPPORTS_LOCALE,TUNE_IN,TUPLE_CATEGORY_A,KINDLE_BOOKS,ALEXA_PRESENCE,GOLDFISH,I_HEART_RADIO,DEREGISTER_DEVICE,DIALOG_INTERFACE_VERSION,CHANGE_NAME,UPDATE_WIFI,AUDIO_CONTROLS,TUPLE,REMINDERS,EQUALIZER_CONTROLLER_TREBLE,GADGETS,SUPPORTS_LOCALE_SWITCH,TIMERS_AND_ALARMS,ALEXA_GESTURES,EQUALIZER_CONTROLLER_MIDRANGE,AUDIO_PLAYER,TIMERS_ALARMS_NOTIFICATIONS_VOLUME,SUPPORTS_SOFTWARE_VERSION,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,POPTART,SOUND_SETTINGS,ACTIVE_AFTER_FRO,PANDORA,DS_VOLUME_SETTING,PERSISTENT_CONNECTION,SLEEP,GUARD_EARCON,SUPPORT_CALENDAR_ALERT,EQUALIZER_CONTROLLER_BASS,AUDIBLE,EARCONS,FLASH_BRIEFING,PAIR_REMOTE,CUSTOM_ALARM_TONE,CLOCK_FORMAT_24_HR,DISPLAY_POWER_TOGGLE,REQUIRES_OOBE_FOR_SETUP,MICROPHONE,MUSIC_SKILL,FAR_FIELD_WAKE_WORD,VOICE_TRAINING,TAHOE_BYOD,PAIR_BT_SOURCE,PAIR_BT_SINK,AMAZON_MUSIC,SALMON,ASCENDING_ALARM_VOLUME,BT_PAIRING_FLOW_V2,LEMUR_ALPHA,SET_LOCALE,DISPLAY_ADAPTIVE_BRIGHTNESS,VOLUME_SETTING
    'A31DTMEEVDDOIV':   {name: 'Fire TV Stick Lite 2020', commandSupport: true, icon: 'icons/firetv.png'}, // SUPPORTS_LOCALE,MICROPHONE,SUPPORTS_LOCALE_SWITCH,FLASH_BRIEFING,SUPPORTS_SOFTWARE_VERSION,PAIR_BT_SINK,REMINDERS,PERSISTENT_CONNECTION,TIMERS_AND_ALARMS,VOLUME_SETTING,ASCENDING_ALARM_VOLUME,CHANGE_NAME,SOUND_SETTINGS,DIALOG_INTERFACE_VERSION,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,ARTHUR_TARGET,ACTIVE_AFTER_FRO,CUSTOM_ALARM_TONE,MULTI_WAKEWORDS_SUPPORTED,EARCONS,SPEECH_RECOGNIZER_USS
    'A32DOYMUN6DTXA':   {name: 'Echo Dot 3.Gen', commandSupport: true, icon: 'icons/echo_dot3.png'}, // PAIR_BT_SINK,CUSTOM_ALARM_TONE,PAIR_REMOTE,TIMERS_AND_ALARMS,SUPPORTS_CONNECTED_HOME,TUNE_IN,SOUND_SETTINGS,DEREGISTER_DEVICE,SET_LOCALE,SLEEP,EARCONS,UPDATE_WIFI,PAIR_BT_SOURCE,SUPPORTS_SOFTWARE_VERSION,REQUIRES_OOBE_FOR_SETUP,MICROPHONE,SALMON,TAHOE_BYOD,CHANGE_NAME,FAR_FIELD_WAKE_WORD,VOLUME_SETTING,AUDIO_PLAYER,I_HEART_RADIO,REMINDERS,PERSISTENT_CONNECTION,AUDIBLE,GADGETS,SUPPORTS_CONNECTED_HOME_ALL,AMAZON_MUSIC,VOICE_TRAINING,FLASH_BRIEFING,DEREGISTER_FACTORY_RESET,GOLDFISH,PANDORA,ACTIVE_AFTER_FRO,DREAM_TRAINING,LEMUR_ALPHA,POPTART,KINDLE_BOOKS
    'A378ND93PD0NC4':   {name: 'VR Radio', commandSupport: true}, // SLEEP,CHANGE_NAME,TUNE_IN,MICROPHONE,VOLUME_SETTING,DEREGISTER_DEVICE,GOLDFISH,AMAZON_MUSIC,KINDLE_BOOKS,REMINDERS,AUDIBLE,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,TIMERS_AND_ALARMS,PAIR_BT_SINK,PEONY,PERSISTENT_CONNECTION,AUDIO_PLAYER,I_HEART_RADIO,DREAM_TRAINING,MUSIC_SKILL
    'A37SHHQ3NUL7B5':   {name: 'Bose Homespeaker', commandSupport: false}, // MICROPHONE,AMAZON_MUSIC,AUDIO_PLAYER,SLEEP,PERSISTENT_CONNECTION,I_HEART_RADIO,AUDIBLE,TIMERS_AND_ALARMS,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,DREAM_TRAINING,TUNE_IN,VOLUME_SETTING,GOLDFISH,KINDLE_BOOKS,DEREGISTER_DEVICE,CHANGE_NAME
    'A38BPK7OW001EX':   {name: 'Raspberry Alexa', commandSupport: false, icon: 'icons/raspi.png'}, // TIMERS_AND_ALARMS,AMAZON_MUSIC,VOLUME_SETTING,AUDIBLE,I_HEART_RADIO,TUNE_IN,KINDLE_BOOKS,DEREGISTER_DEVICE,AUDIO_PLAYER,SLEEP,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,PERSISTENT_CONNECTION,DREAM_TRAINING,MICROPHONE,GOLDFISH,CHANGE_NAME,PEONY
    'A38EHHIB10L47V':   {name: 'Echo Dot', commandSupport: true, icon: 'icons/echo_dot.png'}, // ASCENDING_ALARM_VOLUME,MICROPHONE,REMINDERS,ASX_TIME_ZONE,VOLUME_SETTING,PEONY,SUPPORTS_SOFTWARE_VERSION)
    'A39Y3UG1XLEJLZ':   {name: 'Fitbit Sense', commandSupport: false}, // DIALOG_INTERFACE_VERSION,SLEEP,DREAM_TRAINING,APPLE_MUSIC,AUDIBLE,SUPPORTS_LOCALE,AMAZON_MUSIC,GOLDFISH,SET_TIME_ZONE,SUPPORTS_LOCALE_SWITCH,TUNE_IN,SPEECH_RECOGNIZER_USS,REMINDERS,TIDAL,KINDLE_BOOKS,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,I_HEART_RADIO,MUSIC_SKILL,SET_LOCALE,CHANGE_NAME,VOLUME_SETTING,DEREGISTER_DEVICE,PERSISTENT_CONNECTION,EARCONS,DEEZER,TIMERS_AND_ALARMS,PEONY,CUSTOM_ALARM_TONE,SIRIUSXM,MULTI_WAKEWORDS_SUPPORTED,AUDIO_PLAYER,MICROPHONE,SOUND_SETTING
    'A3C9PE6TNYLTCH':   {name: 'Multiroom', commandSupport: true, icon: 'icons/multiroom.png'}, // AUDIO_PLAYER,AMAZON_MUSIC,KINDLE_BOOKS,TUNE_IN,AUDIBLE,PANDORA,I_HEART_RADIO,SALMON,VOLUME_SETTING
    'A3EVMLQTU6WL1W':   {name: 'Echo Show 8 2.Gen', commandSupport: true, icon: 'icons/echo_show.png'}, //ACTIVE_AFTER_FRO,PERSISTENT_CONNECTION,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,VOLUME_SETTING,SUPPORTS_SOFTWARE_VERSION,CHANGE_NAME,SHARKNADO,ARTHUR_TARGET,FLASH_BRIEFING,MICROPHONE,ADAPTIVE_LISTENING
    'A3FX4UWTP28V1P':   {name: 'Echo 3', commandSupport: true, icon: 'icons/echo_plus2.png'}, // SET_LOCALE,TIMERS_AND_ALARMS,EARCONS,VOLUME_SETTING,AUX_SETTINGS,GOLDFISH,CHANGE_NAME,TUNE_IN,UPDATE_WIFI,KINDLE_BOOKS,DEREGISTER_DEVICE,PAIR_BT_SINK,PANDORA,SLEEP,AUDIO_CONTROLS,EQUALIZER_CONTROLLER_MIDRANGE,MUSIC_SKILL,TIMERS_ALARMS_NOTIFICATIONS_VOLUME,TUPLE,SOUND_SETTINGS,PAIR_BT_SOURCE,AMAZON_MUSIC,EQUALIZER_CONTROLLER_TREBLE,MICROPHONE,FAR_FIELD_WAKE_WORD,BT_PAIRING_FLOW_V2,REQUIRES_OOBE_FOR_SETUP,ASCENDING_ALARM_VOLUME,PAIR_REMOTE,SUPPORT_CALENDAR_ALERT,REMINDERS,GADGETS,DREAM_TRAINING,GUARD_EARCON,ACTIVE_AFTER_FRO,SALMON,SUPPORTS_LOCALE_SWITCH,DS_VOLUME_SETTING,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,CUSTOM_ALARM_TONE,TUPLE_CATEGORY_A,POPTART,SUPPORTS_LOCALE,AUDIO_PLAYER,VOICE_TRAINING,ALEXA_PRESENCE,AUDIBLE,TAHOE_BYOD,EQUALIZER_CONTROLLER_BASS,DIALOG_INTERFACE_VERSION,SUPPORTS_SOFTWARE_VERSION,FLASH_BRIEFING,I_HEART_RADIO,LEMUR_ALPHA,PERSISTENT_CONNECTION
    'A3GZUE7F9MEB4U':   {name: 'Fire TV Cube', commandSupport: true, icon: 'icons/firetv.png'}, // (AMAZON_MUSIC,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,CHANGE_NAME,VOLUME_SETTING,I_HEART_RADIO,AUDIBLE,SLEEP,DREAM_TRAINING,KINDLE_BOOKS,TIMERS_AND_ALARMS,MUSIC_SKILL,MICROPHONE,DEREGISTER_DEVICE,TUNE_IN,GOLDFISH,PERSISTENT_CONNECTION,AUDIO_PLAYER)
    'A3H674413M2EKB':   {name: 'echosim.io', commandSupport: false},
    'A3HF4YRA2L7XGC':   {name: 'Fire TV Cube', commandSupport: true}, // FLASH_BRIEFING,TUNE_IN,PANDORA,FAR_FIELD_WAKE_WORD,DREAM_TRAINING,AMAZON_MUSIC,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,AUDIBLE,SUPPORTS_SOFTWARE_VERSION,PAIR_BT_SINK,CHANGE_NAME,AUDIO_PLAYER,VOICE_TRAINING,SET_LOCALE,EARCONS,SOUND_SETTINGS,SALMON,ACTIVE_AFTER_FRO,SLEEP,I_HEART_RADIO,TIMERS_AND_ALARMS,CUSTOM_ALARM_TONE,PERSISTENT_CONNECTION,ARTHUR_TARGET,KINDLE_BOOKS,REMINDERS
    'A3L2K717GERE73':   {name: 'Alexa App Apple Watch', commandSupport: false}, // ASCENDING_ALARM_VOLUME,AUDIBLE,SET_LOCALE,TOUCH_INITIATED,REMINDERS,MUSIC_SKILL,VOLUME_SETTING,DEREGISTER_DEVICE,SPEECH_RECOGNIZER_USS,APPLE_MUSIC,SET_TIME_ZONE,EARCONS,DEEZER,I_HEART_RADIO,MICROPHONE,SLEEP,TIDAL,AMAZON_MUSIC,SUPPORTS_LOCALE_SWITCH,PEONY,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,CHANGE_NAME,TIMERS_AND_ALARMS,DIALOG_INTERFACE_VERSION,GOLDFISH,SIRIUSXM,AUDIO_PLAYER,SOUND_SETTINGS,ADAPTIVE_LISTENING,CUSTOM_ALARM_TONE,MULTI_WAKEWORDS_SUPPORTED,PERSISTENT_CONNECTION,SUPPORTS_LOCALE,DREAM_TRAINING,TUNE_IN,KINDLE_BOOKS
    'A3NPD82ABCPIDP':   {name: 'Sonos Beam', commandSupport: true, icon: 'icons/sonos.png'}, // AMAZON_MUSIC,CHANGE_NAME,AUDIO_PLAYER,KINDLE_BOOKS,SLEEP,DREAM_TRAINING,AUDIBLE,DEREGISTER_DEVICE,I_HEART_RADIO,GOLDFISH,PERSISTENT_CONNECTION,MICROPHONE,TIMERS_AND_ALARMS,PEONY,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,REMINDERS,VOLUME_SETTING,TUNE_IN
    'A3OCOCNTAPDC9O':   {name: 'Mi Smart Band 6 NFC', commandSupport: false}, // DREAM_TRAINING,SIRIUSXM,MULTI_WAKEWORDS_SUPPORTED,I_HEART_RADIO,KINDLE_BOOKS,SET_TIME_ZONE,AMAZON_MUSIC,SPEECH_RECOGNIZER_USS,HANDS_FREE,VOLUME_SETTING,SOUND_SETTINGS,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,MUSIC_SKILL,DEEZER,AUDIBLE,DIALOG_INTERFACE_VERSION,APPLE_MUSIC,ASCENDING_ALARM_VOLUME,SLEEP,SET_LOCALE,SUPPORTS_LOCALE_SWITCH,PERSISTENT_CONNECTION,CUSTOM_ALARM_TONE,TIMERS_AND_ALARMS,CHANGE_NAME,MICROPHONE,ADAPTIVE_LISTENING,EARCONS,AUDIO_PLAYER,TIDAL,REMINDERS,GOLDFISH,TUNE_IN,DEREGISTER_DEVICE,SUPPORTS_LOCALE
    'A3R8XIAIU4HJAX':   {name: 'Echo Show', commandSupport: true, icon: 'icons/echo_show.png'}, // AMAZON_MUSIC,MUSIC_SKILL,CHANGE_NAME,I_HEART_RADIO,TUNE_IN,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,PEONY,REMINDERS,AUDIO_PLAYER,PANDORA,VOLUME_SETTING,LAMBDA_DOWNCHANNEL
    'A3R9S4ZZECZ6YL':   {name: 'Fire Tab HD 10', commandSupport: true, icon: 'icons/firetab.png'}, // ASX_TIME_ZONE,PEONY,VOLUME_SETTING,SUPPORTS_SOFTWARE_VERSION
    'A3RBAYBE7VM004':   {name: 'Echo Studio', commandSupport: true, icon: 'icons/echo_studio.png'}, // TUNE_IN,AUDIBLE,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,LEMUR_ALPHA,GADGETS,FLASH_BRIEFING,SHARKNADO,PAIR_BT_SINK,PERSISTENT_CONNECTION,CHANGE_NAME,CUSTOM_ALARM_TONE,TUPLE_CATEGORY_B,EARCONS,I_HEART_RADIO,REMINDERS,SET_LOCALE,DREAM_TRAINING,POPTART,AMAZON_MUSIC,KINDLE_BOOKS,SALMON,FACTORY_RESET_DEVICE,SLEEP,GOLDFISH,ASCENDING_ALARM_VOLUME,SOUND_SETTINGS,ALLOW_LOG_UPLOAD,FAR_FIELD_WAKE_WORD,AUDIO_PLAYER,VOLUME_SETTING,VOICE_TRAINING,TUPLE,TIMERS_AND_ALARMS,SUPPORTS_SOFTWARE_VERSION,PANDORA,MICROPHONE
    'A3RMGO6LYLH7YN':   {name: 'Echo Plus 4.Gen', commandSupport: true, icon: 'icons/echo4.png'}, // PANDORA,PAIR_BT_SINK,FAR_FIELD_WAKE_WORD,GADGETS,DS_VOLUME_SETTING,TUNE_IN,EQUALIZER_CONTROLLER_BASS,DIALOG_INTERFACE_VERSION,MOTION_DETECTION,SALMON,TIMERS_AND_ALARMS,TIDAL,AUDIO_PROCESSING,TUPLE,EARCONS,POPTART,EQUALIZER_CONTROLLER_MIDRANGE,ALEXA_GESTURES,SUPPORTS_LOCALE,UPDATE_WIFI,TAHOE_BYOD,MUSIC_SKILL,ASCENDING_ALARM_VOLUME,ALEXA_PRESENCE,BT_PAIRING_FLOW_V2,EQUALIZER_CONTROLLER_TREBLE,ACTIVE_AFTER_FRO,DREAM_TRAINING,DEEZER,DEREGISTER_DEVICE,AUDIBLE,REQUIRES_OOBE_FOR_SETUP,VOICE_TRAINING,AUDIO_CONTROLS,SUPPORTS_SOFTWARE_VERSION,SOUND_SETTINGS,CUSTOM_ALARM_TONE,FLASH_BRIEFING,I_HEART_RADIO,SUPPORT_CALENDAR_ALERT,SET_LOCALE,LEMUR_ALPHA,APPLE_MUSIC,MICROPHONE,REMINDERS,GOLDFISH,SUPPORTS_LOCALE_SWITCH,MULTI_WAKEWORDS_SUPPORTED,SLEEP,KINDLE_BOOKS,TEMPERATURE_SENSOR,SIRIUSXM,GUARD_EARCON,AUDIO_PLAYER,PERSISTENT_CONNECTION,TIMERS_ALARMS_NOTIFICATIONS_VOLUME,EFDCARDS,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,TUPLE_CATEGORY_A,CHANGE_NAME,VOLUME_SETTING,PAIR_BT_SOURCE,AUX_SETTINGS,SET_TIME_ZONE,AMAZON_MUSIC
    'A3S5BH2HU6VAYF':   {name: 'Echo Dot 2.Gen', commandSupport: true, icon: 'icons/echo_dot.png'}, // PAIR_BT_SINK,CUSTOM_ALARM_TONE,PAIR_REMOTE,TIMERS_AND_ALARMS,SUPPORTS_CONNECTED_HOME,TUNE_IN,SOUND_SETTINGS,DEREGISTER_DEVICE,SET_LOCALE,SLEEP,EARCONS,UPDATE_WIFI,PAIR_BT_SOURCE,SUPPORTS_SOFTWARE_VERSION,REQUIRES_OOBE_FOR_SETUP,MICROPHONE,SALMON,TAHOE_BYOD,CHANGE_NAME,FAR_FIELD_WAKE_WORD,VOLUME_SETTING,AUDIO_PLAYER,I_HEART_RADIO,REMINDERS,PERSISTENT_CONNECTION,AUDIBLE,GADGETS,SUPPORTS_CONNECTED_HOME_ALL,AMAZON_MUSIC,VOICE_TRAINING,FLASH_BRIEFING,DEREGISTER_FACTORY_RESET,GOLDFISH,PANDORA,ACTIVE_AFTER_FRO,DREAM_TRAINING,LEMUR_ALPHA,POPTART,KINDLE_BOOKS
    'A3SSG6GR8UU7SN':   {name: 'Echo Sub', commandSupport: true, icon: 'icons/echo_sub.png'}, // PERSISTENT_CONNECTION,ACTIVE_AFTER_FRO,SET_LOCALE,MICROPHONE,VOLUME_SETTING,AUDIBLE,AUDIO_PLAYER,UPDATE_WIFI,TUPLE,CUSTOM_ALARM_TONE,REQUIRES_OOBE_FOR_SETUP,EARCONS,KINDLE_BOOKS,TUPLE_CATEGORY_C,SUPPORTS_SOFTWARE_VERSION,ALLOW_LOG_UPLOAD,DEREGISTER_DEVICE,SLEEP,SOUND_SETTINGS,CHANGE_NAME,FLASH_BRIEFING,REMINDERS,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,TIMERS_AND_ALARMS
    'A3TCJ8RTT3NVI7':   {name: 'Listens for Alexa', commandSupport: false, icon: 'icons/microphone.png'}, // (AUDIBLE,DEREGISTER_DEVICE,MICROPHONE,GOLDFISH,CHANGE_NAME,PERSISTENT_CONNECTION,TUNE_IN,SLEEP,AUDIO_PLAYER,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,KINDLE_BOOKS,VOLUME_SETTING,I_HEART_RADIO,DREAM_TRAINING,MUSIC_SKILL,PEONY,AMAZON_MUSIC,TIMERS_AND_ALARMS)
    'A3V3VA38K169FO':   {name: 'Fire Tab', commandSupport: true, icon: 'icons/firetab.png'}, // (VOLUME_SETTING,MUSIC_SKILL,AUDIO_PLAYER,AUDIBLE,KINDLE_BOOKS,SLEEP,I_HEART_RADIO,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,PERSISTENT_CONNECTION,CHANGE_NAME,TIMERS_AND_ALARMS,PEONY,DREAM_TRAINING,MICROPHONE,TUNE_IN,AMAZON_MUSIC,GOLDFISH,DEREGISTER_DEVICE)
    'A3VRME03NAXFUB':   {name: 'Echo Flex', commandSupport: true, icon: 'icons/echo_flex.png'}, // (LEMUR_ALPHA,TUNE_IN,EARCONS,ALEXA_PRESENCE,AMAZON_MUSIC,TUPLE,DREAM_TRAINING,TIMERS_ALARMS_NOTIFICATIONS_VOLUME,FLASH_BRIEFING,DIALOG_INTERFACE_VERSION,PAIR_REMOTE,SOUND_SETTINGS,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,UPDATE_WIFI,AUDIBLE,SLEEP,VOLUME_SETTING,GOLDFISH,CHANGE_NAME,SALMON,GADGETS,ACTIVE_AFTER_FRO,PANDORA,ASCENDING_ALARM_VOLUME,PAIR_BT_SINK,KINDLE_BOOKS,VOICE_TRAINING,DS_VOLUME_SETTING,SUPPORT_CALENDAR_ALERT,TAHOE_BYOD,FAR_FIELD_WAKE_WORD,I_HEART_RADIO,SUPPORTS_SOFTWARE_VERSION,PAIR_BT_SOURCE,TUPLE_CATEGORY_A,ALLOW_LOG_UPLOAD,POPTART,SET_LOCALE,TIMERS_AND_ALARMS,BT_PAIRING_FLOW_V2,REQUIRES_OOBE_FOR_SETUP,CUSTOM_ALARM_TONE,REMINDERS,MUSIC_SKILL,DEREGISTER_DEVICE,PERSISTENT_CONNECTION,MICROPHONE,DISPLAY_BRIGHTNESS_ADJUST,AUDIO_PLAYER)
    'A4ZP7ZC4PI6TO':    {name: 'Echo Show 5', commandSupport: true, icon: 'icons/echo_show5.png'}, // FAR_FIELD_WAKE_WORD,AMAZON_MUSIC,LEMUR_ALPHA,MICROPHONE,PANDORA,I_HEART_RADIO,VOLUME_SETTING,EARCONS,PAIR_BT_SINK,DS_VOLUME_SETTING,SOUND_SETTINGS,TIMERS_AND_ALARMS,LOCAL_VOICE,DIALOG_INTERFACE_VERSION,GOLDFISH,SHARKNADO,TIMERS_ALARMS_NOTIFICATIONS_VOLUME,CHANGE_NAME,SUPPORTS_SOFTWARE_VERSION,REMINDERS,AUDIO_PLAYER,SALMON,MUSIC_SKILL,ALLOW_LOG_UPLOAD,TUNE_IN,DREAM_TRAINING,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,ASCENDING_ALARM_VOLUME,AUDIBLE,FACTORY_RESET_DEVICE,FLASH_BRIEFING,SLEEP,SET_LOCALE,PERSISTENT_CONNECTION,VOICE_TRAINING,CUSTOM_ALARM_TONE,KINDLE_BOOKS,SUPPORT_CALENDAR_ALERT
    'A4ZXE0RM7LQ7A':   {name: 'Echo Dot 5.Gen', commandSupport: true, icon: 'icons/echo_dot4.png'}, // SET_LOCALE,GUARD_EARCON,DEREGISTER_DEVICE,REQUIRES_OOBE_FOR_SETUP,SUPPORTS_SOFTWARE_VERSION,VOLUME_SETTING,BT_PAIRING_FLOW_V2,REMINDERS,TAHOE_BYOD,SLEEP,ACTIVE_AFTER_FRO,PAIR_BT_SINK,ALEXA_PRESENCE,MUSIC_SKILL,CHANGE_NAME,SPEECH_RECOGNIZER_USS,LOCALIZATION,SET_TIME_ZONE,PAIR_BT_SOURCE,TAP_GESTURES_RESUME_MEDIA,TEMPERATURE_SENSOR,TIMERS_AND_ALARMS,SUPPORTS_LOCALE_SWITCH,MOTION_DETECTION,SUPPORT_CALENDAR_ALERT,CUSTOM_ALARM_TONE,EQUALIZER_CONTROLLER_BASS,PERSISTENT_CONNECTION,KINDLE_BOOKS,LEMUR_ALPHA,SUPPORTS_LOCALE,GADGETS,I_HEART_RADIO,DIALOG_INTERFACE_VERSION,TIDAL,EFDCARDS,WAKE_WORD_SENSITIVITY,EQUALIZER_CONTROLLER_TREBLE,SALMON,PANDORA,TAP_GESTURES_SINGLE_TAP,TIMERS_ALARMS_NOTIFICATIONS_VOLUME,VOICE_TRAINING,EQUALIZER_CONTROLLER_MIDRANGE,AUDIO_PLAYER,TUPLE,SIRIUSXM,TUPLE_CATEGORY_A,TUNE_IN,AUDIBLE,DS_VOLUME_SETTING,ASCENDING_ALARM_VOLUME,FLASH_BRIEFING,DEEZER,POPTART,TAP_GESTURES,UPDATE_WIFI,MOTION_SENSOR_RANGE_STRING,ALEXA_VOICE,SOUND_SETTINGS,GOLDFISH,ADAPTIVE_LISTENING,DREAM_TRAINING,APPLE_MUSIC,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,MULTI_WAKEWORDS_SUPPORTED,EARCONS,FAR_FIELD_WAKE_WORD,AMAZON_MUSIC,MICROPHONE,AUDIO_CONTROLS
    'A7WXQPH584YP':     {name: 'Echo 2.Gen', commandSupport: true, icon: 'icons/echo2.png'}, // PAIR_BT_SINK,CUSTOM_ALARM_TONE,PAIR_REMOTE,TIMERS_AND_ALARMS,TUNE_IN,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,SOUND_SETTINGS,DEREGISTER_DEVICE,SET_LOCALE,SLEEP,EARCONS,UPDATE_WIFI,PAIR_BT_SOURCE,SUPPORTS_SOFTWARE_VERSION,REQUIRES_OOBE_FOR_SETUP,MICROPHONE,SALMON,TAHOE_BYOD,CHANGE_NAME,FAR_FIELD_WAKE_WORD,VOLUME_SETTING,AUDIO_PLAYER,I_HEART_RADIO,REMINDERS,ASCENDING_ALARM_VOLUME,PERSISTENT_CONNECTION,AUDIBLE,GADGETS,TUPLE_CATEGORY_A,AMAZON_MUSIC,VOICE_TRAINING,FLASH_BRIEFING,DEREGISTER_FACTORY_RESET,GOLDFISH,TUPLE,PANDORA,ACTIVE_AFTER_FRO,DREAM_TRAINING,LEMUR_ALPHA,POPTART,KINDLE_BOOKS
    'A8D2OKFFQKQ56':    {name: 'Bose Smart Soundbar 900', commandSupport: true}, // ADAPTIVE_LISTENING,TIMERS_AND_ALARMS,DEREGISTER_DEVICE,DEEZER,GOLDFISH,TIDAL,SPEECH_RECOGNIZER_USS,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,APPLE_MUSIC,FAR_FIELD,PERSISTENT_CONNECTION,SLEEP,SUPPORTS_LOCALE,MICROPHONE,VOLUME_SETTING,DIALOG_INTERFACE_VERSION,SIRIUSXM,SOUND_SETTINGS,I_HEART_RADIO,CHANGE_NAME,AUDIBLE,DREAM_TRAINING,SET_TIME_ZONE,EARCONS,AUDIO_PLAYER,TUNE_IN,MUSIC_SKILL,AMAZON_MUSIC,KINDLE_BOOKS,REMINDERS,MULTI_WAKEWORDS_SUPPORTED,CUSTOM_ALARM_TONE
    'A8DM4FYR6D3HT':    {name: 'LG WebOS TV', commandSupport: true}, // CHANGE_NAME,AUDIBLE,ASCENDING_ALARM_VOLUME,REMINDERS,DIALOG_INTERFACE_VERSION,DEREGISTER_DEVICE,MUSIC_SKILL,I_HEART_RADIO,SET_LOCALE,CUSTOM_ALARM_TONE,SET_TIME_ZONE,MULTI_WAKEWORDS_SUPPORTED,TUNE_IN,MICROPHONE,KINDLE_BOOKS,DREAM_TRAINING,SOUND_SETTINGS,GOLDFISH,VOLUME_SETTING,SUPPORTS_LOCALE_SWITCH,SLEEP,TIMERS_AND_ALARMS,AUDIO_PLAYER,SUPPORTS_LOCALE,AMAZON_MUSIC,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,PERSISTENT_CONNECTION
    'AB72C64C86AW2':    {name: 'Echo', commandSupport: true, icon: 'icons/echo.png'}, // PAIR_BT_SINK,CUSTOM_ALARM_TONE,PAIR_REMOTE,TIMERS_AND_ALARMS,SUPPORTS_CONNECTED_HOME,TUNE_IN,SOUND_SETTINGS,DEREGISTER_DEVICE,SET_LOCALE,SLEEP,EARCONS,UPDATE_WIFI,PAIR_BT_SOURCE,SUPPORTS_SOFTWARE_VERSION,REQUIRES_OOBE_FOR_SETUP,TUPLE_CATEGORY_B,MICROPHONE,SALMON,TAHOE_BYOD,CHANGE_NAME,FAR_FIELD_WAKE_WORD,VOLUME_SETTING,AUDIO_PLAYER,I_HEART_RADIO,REMINDERS,ASCENDING_ALARM_VOLUME,PERSISTENT_CONNECTION,AUDIBLE,GADGETS,SUPPORTS_CONNECTED_HOME_ALL,AMAZON_MUSIC,VOICE_TRAINING,FLASH_BRIEFING,DEREGISTER_FACTORY_RESET,GOLDFISH,TUPLE,PANDORA,ACTIVE_AFTER_FRO,DREAM_TRAINING,LEMUR_ALPHA,POPTART,KINDLE_BOOKS
    'ADVBD696BHNV5':    {name: 'Fire TV Stick V1', commandSupport: true, icon: 'icons/firetv.png'}, // REMINDERS,CUSTOM_ALARM_TONE,VOLUME_SETTING,SUPPORTS_LOCALE_SWITCH,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,DIALOG_INTERFACE_VERSION,SUPPORTS_SOFTWARE_VERSION,SOUND_SETTINGS,PERSISTENT_CONNECTION,MICROPHONE,SUPPORTS_LOCALE,FLASH_BRIEFING,ACTIVE_AFTER_FRO,ARTHUR_TARGET,ASCENDING_ALARM_VOLUME,CHANGE_NAME,TIMERS_AND_ALARMS
    'AHCEDGRIFN5RP':    {name: 'Xiaomi Smart Fire TV', commandSupport: true}, // DREAM_TRAINING,AMAZON_MUSIC,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,CUSTOM_ALARM_TONE,SUPPORTS_CONNECTED_HOME_ALL,ARTHUR_TARGET,SALMON,VOLUME_SETTING,I_HEART_RADIO,TIMERS_ALARMS_NOTIFICATIONS_VOLUME,SUPPORTS_LOCALE,REMINDERS,AUDIO_PLAYER,ADAPTIVE_LISTENING,KINDLE_BOOKS,TAHOE_BYOD,EARCONS,FLASH_BRIEFING,AUDIO_CONTROLS,PANDORA,SET_LOCALE,TIMERS_AND_ALARMS,SPEECH_RECOGNIZER_USS,PERSISTENT_CONNECTION,AUDIBLE,MICROPHONE,REQUIRES_OOBE_FOR_SETUP,TIDAL,SIRIUSXM,SHARKNADO,CHANGE_NAME,EQUALIZER_CONTROLLER_MIDRANGE,SUPPORTS_LOCALE_SWITCH,DEEZER,MUSIC_SKILL,SLEEP,SUPPORTS_SOFTWARE_VERSION,APPLE_MUSIC,MULTI_WAKEWORDS_SUPPORTED,DIALOG_INTERFACE_VERSION,VOICE_TRAINING,ACTIVE_AFTER_FRO,TUNE_IN,ASCENDING_ALARM_VOLUME,SOUND_SETTINGS,TIMEZONE
    'AHJYKVA63YCAQ':    {name: 'Sonos Roam', commandSupport: true, icon: 'icons/sonos.png'}, // SIRIUSXM,PERSISTENT_CONNECTION,TIDAL,SUPPORTS_LOCALE_SWITCH,DIALOG_INTERFACE_VERSION,DREAM_TRAINING,CUSTOM_ALARM_TONE,APPLE_MUSIC,GOLDFISH,KINDLE_BOOKS,CHANGE_NAME,SET_LOCALE,AUDIO_PLAYER,AUDIBLE,TUNE_IN,DEREGISTER_DEVICE,SPEECH_RECOGNIZER_USS,TIMERS_AND_ALARMS,MULTI_WAKEWORDS_SUPPORTED,EARCONS,MICROPHONE,DEEZER,ASCENDING_ALARM_VOLUME,MUSIC_SKILL,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,SLEEP,SOUND_SETTINGS,SUPPORTS_LOCALE,I_HEART_RADIO,REMINDERS,AMAZON_MUSIC,SET_TIME_ZONE,VOLUME_SETTING
    'AILBSA2LNTOYL':    {name: 'reverb App', commandSupport: false, icon: 'icons/reverb.png'},
    'AINRG27IL8AS0':    {name: 'Megablast Speaker', commandSupport: false}, // (TUNE_IN,KINDLE_BOOKS,PAIR_BT_SINK,TIMERS_AND_ALARMS,MICROPHONE,AUDIBLE,CHANGE_NAME,GOLDFISH,REMINDERS,VOLUME_SETTING,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,DREAM_TRAINING,SLEEP,PERSISTENT_CONNECTION,AMAZON_MUSIC,I_HEART_RADIO,MUSIC_SKILL,PEONY,AUDIO_PLAYER,DEREGISTER_DEVICE)
    'AIPK7MM90V7TB':    {name: 'Echo Show 10', commandSupport: true, icon: 'icons/echo_show5.png'}, // TIDAL,ALEXA_VOICE,FAR_FIELD_WAKE_WORD,POPTART,PANDORA,TUNE_IN,DEREGISTER_DEVICE,EQUALIZER_CONTROLLER_MIDRANGE,CUSTOM_ALARM_TONE,AUDIO_PROCESSING,TIMERS_AND_ALARMS,PAIR_BT_SINK,AUDIO_PLAYER,SALMON,SHARKNADO,APPLE_MUSIC,SLEEP,KINDLE_BOOKS,EARCONS,DREAM_TRAINING,EFDCARDS,CHANGE_NAME,AUDIBLE,SUPPORTS_LOCALE_SWITCH,VOLUME_SETTING,DIALOG_INTERFACE_VERSION,SUPPORT_CALENDAR_ALERT,FLASH_BRIEFING,MUSIC_SKILL,GOLDFISH,MULTI_WAKEWORDS_SUPPORTED,SMART_MOTION,SPEECH_RECOGNIZER_USS,EQUALIZER_CONTROLLER_BASS,LEMUR_ALPHA,VOICE_TRAINING,ASCENDING_ALARM_VOLUME,LIVE_VIEW,GUARD_EARCON,ALEXA_PRESENCE,SUPPORTS_SOFTWARE_VERSION,SIRIUSXM,EQUALIZER_CONTROLLER_TREBLE,AUDIO_CONTROLS,NEED_WARMUP_FOR_LIVE_VIEW,MICROPHONE,SUPPORTS_LOCALE,TUPLE_CATEGORY_B,BT_PAIRING_FLOW_V2,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,REMINDERS,TUPLE,AMAZON_MUSIC,CLOCK_FORMAT_24_HR,I_HEART_RADIO,SOUND_SETTINGS,SET_LOCALE,DS_VOLUME_SETTING,DEEZER,TIMERS_ALARMS_NOTIFICATIONS_VOLUME,ADAPTIVE_LISTENING,PERSISTENT_CONNECTION
    'AKOAGQTKAS9YB':    {name: 'Echo Connect', commandSupport: false}, // VOLUME_SETTING,PEONY,BLOWER,DEREGISTER_DEVICE,PERSISTENT_CONNECTION,NO_UNITS_AND_TIMEZONES,SUPPORTS_SOFTWARE_VERSION,UPDATE_WIFI,CHANGE_NAME,MICROPHONE
    'AKPGW064GI9HE':    {name: 'Fire Stick 4K', commandSupport: true, icon: 'icons/firetv.png'}, // SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,SUPPORTS_SOFTWARE_VERSION,CHANGE_NAME,PERSISTENT_CONNECTION,ARTHUR_TARGET,ACTIVE_AFTER_FRO,FLASH_BRIEFING,MICROPHONE,VOLUME_SETTING
    'AO50AHDYKXRFG':   {name: 'Bose Headphones', commandSupport: false}, // KINDLE_BOOKS,AUDIBLE,DEEZER,AMAZON_MUSIC,TUNE_IN,AUDIO_PLAYER,MICROPHONE,DEREGISTER_DEVICE,MUSIC_SKILL,TIDAL,SLEEP,SIRIUSXM,DREAM_TRAINING,TOUCH_INITIATED,CHANGE_NAME,HANDS_FREE,GOLDFISH,VOLUME_SETTING,ADAPTIVE_LISTENING,TIMERS_AND_ALARMS,APPLE_MUSIC,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,PERSISTENT_CONNECTION,I_HEART_RADIO
    'AP1F6KUH00XPV':    {name: 'Stereo/Subwoofer Pair', commandSupport: true}, // AUDIO_PLAYER,TUNE_IN,SALMON,I_HEART_RADIO,PANDORA,AMAZON_MUSIC,VOLUME_SETTING,MUSIC_SKILL,MICROPHONE
    'ASO109Y6XSVHD':    {name: 'Amazfit GTR 4 LE', commandSupport: true}, // SET_LOCALE,DEEZER,ADAPTIVE_LISTENING,SLEEP,MUSIC_SKILL,REMINDERS,MULTI_WAKEWORDS_SUPPORTED,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,TIDAL,TOUCH_INITIATED,SIRIUSXM,PERSISTENT_CONNECTION,CHANGE_NAME,VOLUME_SETTING,TIMERS_ALARMS_NOTIFICATIONS_VOLUME,TIMERS_AND_ALARMS,MICROPHONE,SOUND_SETTINGS,SUPPORTS_LOCALE_SWITCH,SET_TIME_ZONE,AUDIO_PLAYER,AUDIBLE,TUNE_IN,AMAZON_MUSIC,APPLE_MUSIC,SUPPORTS_LOCALE,DREAM_TRAINING,KINDLE_BOOKS,GOLDFISH,DEREGISTER_DEVICE,CUSTOM_ALARM_TONE,I_HEART_RADIO,EARCONS,SPEECH_RECOGNIZER_USS
    'ASQZWP4GPYUT7': {name: 'Echo Pop', commandSupport: true}, // SET_LOCALE,BT_PAIRING_FLOW_V2,TIMERS_AND_ALARMS,PERSISTENT_CONNECTION,VOICE_TRAINING,TAHOE_BYOD,EFDCARDS,ACTIVE_AFTER_FRO,ALEXA_PRESENCE,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,AMAZON_MUSIC,AUDIBLE,TUPLE_CATEGORY_A,PANDORA,GOLDFISH,REQUIRES_OOBE_FOR_SETUP,REMINDERS,LEMUR_ALPHA,EQUALIZER_CONTROLLER_MIDRANGE,DEREGISTER_DEVICE,SUPPORT_CALENDAR_ALERT,ASCENDING_ALARM_VOLUME,SET_TIME_ZONE,MUSIC_SKILL,LOCALIZATION,SLEEP,EQUALIZER_CONTROLLER_BASS,TAP_GESTURES,SUPPORTS_LOCALE,DIALOG_INTERFACE_VERSION,ALEXA_VOICE,DREAM_TRAINING,DS_VOLUME_SETTING,TIDAL,EARCONS,SUPPORTS_SOFTWARE_VERSION,SIRIUSXM,SUPPORTS_LOCALE_SWITCH,SOUND_SETTINGS,APPLE_MUSIC,MULTI_WAKEWORDS_SUPPORTED,AUDIO_CONTROLS,POPTART,AUDIO_PLAYER,DEEZER,GUARD_EARCON,CHANGE_NAME,TIMERS_ALARMS_NOTIFICATIONS_VOLUME,PAIR_BT_SINK,DISPLAY_BRIGHTNESS_ADJUST,SALMON,ADAPTIVE_LISTENING,SPEECH_RECOGNIZER_USS,KINDLE_BOOKS,FLASH_BRIEFING,FAR_FIELD_WAKE_WORD,TAP_GESTURES_SINGLE_TAP,I_HEART_RADIO,VOLUME_SETTING,TUNE_IN,TUPLE,CUSTOM_ALARM_TONE,MICROPHONE,GADGETS,PAIR_BT_SOURCE,UPDATE_WIFI,EQUALIZER_CONTROLLER_TREBLE
    'ATNLRCEBX3W4P':    {name: 'Fire HD 10', commandSupport: true}, // SOUND_SETTINGS,ASCENDING_ALARM_VOLUME,MICROPHONE,EARCONS,SUPPORTS_SOFTWARE_VERSION,REMINDERS,ADAPTIVE_LISTENING,SPEECH_RECOGNIZER_USS,NO_TIME_ZONE_SETTING,MULTI_WAKEWORDS_SUPPORTED,SUPPORTS_LOCALE,ASX_TIME_ZONE,VOLUME_SETTING,CUSTOM_ALARM_TONE,SUPPORTS_LOCALE_SWITCH,DIALOG_INTERFACE_VERSION,PERSISTENT_CONNECTION,TIMERS_AND_ALARMS
    'AVD3HM0HOJAAL':    {name: 'Sonos One 2.Gen', commandSupport: true, icon: 'icons/sonos.png'}, // CHANGE_NAME,DEREGISTER_DEVICE,DREAM_TRAINING,PEONY,AMAZON_MUSIC,MICROPHONE,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,TIMERS_AND_ALARMS,VOLUME_SETTING,AUDIBLE,KINDLE_BOOKS,SLEEP,AUDIO_PLAYER,GOLDFISH,I_HEART_RADIO,TUNE_IN,MUSIC_SKILL,PERSISTENT_CONNECTION,REMINDERS
    'AVE5HX13UR5NO':    {name: 'Logitech Zero Touch', commandSupport: false}, // SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,TUNE_IN,MICROPHONE,AUDIO_PLAYER,TIMERS_AND_ALARMS,PEONY,GOLDFISH,DEREGISTER_DEVICE,AUDIBLE,AMAZON_MUSIC,PERSISTENT_CONNECTION,KINDLE_BOOKS,CHANGE_NAME,I_HEART_RADIO,SLEEP,DREAM_TRAINING,VOLUME_SETTING
    'AVU7CPPF2ZRAS':    {name: 'Fire HD 8', commandSupport: true}, // VOLUME_SETTING,SUPPORTS_SOFTWARE_VERSION,REMINDERS,PERSISTENT_CONNECTION,NO_TIME_ZONE_SETTING,DIALOG_INTERFACE_VERSION,TIMERS_AND_ALARMS,SOUND_SETTINGS,CUSTOM_ALARM_TONE,ASX_TIME_ZONE,ASCENDING_ALARM_VOLUME,MICROPHONE
    'AWZZ5CVHX2CD':     {name: 'Echo Show 2.Gen', commandSupport: true, icon: 'icons/echo_show2.png'}, // TUNE_IN,AUDIBLE,SUPPORTS_CONNECTED_HOME_CLOUD_ONLY,LEMUR_ALPHA,GADGETS,FLASH_BRIEFING,SHARKNADO,PAIR_BT_SINK,PERSISTENT_CONNECTION,CHANGE_NAME,CUSTOM_ALARM_TONE,TUPLE_CATEGORY_B,EARCONS,I_HEART_RADIO,REMINDERS,SET_LOCALE,DREAM_TRAINING,POPTART,AMAZON_MUSIC,KINDLE_BOOKS,SALMON,FACTORY_RESET_DEVICE,SLEEP,GOLDFISH,ASCENDING_ALARM_VOLUME,SOUND_SETTINGS,ALLOW_LOG_UPLOAD,FAR_FIELD_WAKE_WORD,AUDIO_PLAYER,VOLUME_SETTING,VOICE_TRAINING,TUPLE,TIMERS_AND_ALARMS,SUPPORTS_SOFTWARE_VERSION,PANDORA,MICROPHONE
};

const unknownDeviceWarnings = {};

let proxyUrl = null;

let resetCrashCheckerTimeout = null;
let updateStateTimer;
let updateHistoryTimer;
let updateConfigurationTimer;
let updateSmartHomeDevicesTimer;
const updatePlayerTimer = {};
const updateNotificationTimer = {};

let musicProviders;
let routineSounds;
let routineSkills;
const rememberedNotificationVolumeRestoreCallbacks = {};
const initialDeviceVolumes = {};
let automationRoutines;
let routineTriggerUtterances;
const playerDevices = {};
const playingDevices = {};
const appDevices = {};
const listMap =  {};
const equalizerUpdateTimeouts = {};

const lastPlayerState = {};
const notificationTimer = {};
let pushConnected = false;
const shApplianceEntityMap = {};
const shEntityApplianceMap = {};
const shMergedApplianceIdMap = {};
const shGroupDetails = {};
const shDeviceParamValues = {};
const shQueryBlocker = {};
const shQueryEnabled = {};
const shDeviceParamControlValues = {};
const shDeviceRefreshTimeoutAfterControl = {};
let shDeviceDiscoveryTimeout = null;

const stateChangeTrigger = {};
const objectQueue = [];

const existingStates = {};
const adapterObjects = {};

let crashCheckFileName;
let isCrashStop = false;
const useCrashCheck = true; // Only disable for development!
let initDone = false;
let installationUuid;

const shdCounters = {
    getSkill: 0,
    get: 0,
    setSkill: 0,
    set: 0
};
let checkerInterval = null;

process.on('uncaughtException', () => {
    isCrashStop = true;
});
process.on('unhandledRejection', () => {
    isCrashStop = true;
});

function setOrUpdateObject(id, obj, value, stateChangeCallback, createNow) {
    let callback = null;
    if (typeof value === 'function') {
        createNow = stateChangeCallback;
        stateChangeCallback = value;
        value = undefined;
    }
    if (typeof createNow === 'function') {
        callback = createNow;
        createNow = true;
    }

    if (! obj.type) {
        obj.type = 'state';
    }
    if (! obj.common) {
        obj.common = {};
    }
    if (! obj.native) {
        obj.native = {};
    }
    if (obj.common && obj.common.type === undefined && obj.type === 'state') {
        if (value !== null && value !== undefined) {
            obj.common.type = typeof value;
        }
        else if (obj.common.def !== undefined) {
            obj.common.type = typeof obj.common.def;
        }
        else if (obj.common.min !== undefined || obj.common.max !== undefined) {
            obj.common.type = 'number';
        }
        else {
            obj.common.type = 'mixed';
        }
    }
    if (obj.common && obj.common.read === undefined) {
        obj.common.read = true; //!(obj.common.type === 'boolean' && !!stateChangeCallback);
    }
    if (obj.common && obj.common.write === undefined) {
        obj.common.write = !!stateChangeCallback;
    }
    /*
    if (obj.common && obj.common.def === undefined && value !== null && value !== undefined) {
        obj.common.def = value;
    }*/
    if (obj.common && obj.common.name === undefined) {
        obj.common.name = id.split('.').pop();
    }

    let preserveSettings;
    if (obj.preserveSettings) {
        preserveSettings = obj.preserveSettings;
        delete obj.preserveSettings;
    }

    if (!adapterObjects[id] && existingStates[id]) {
        adapterObjects[id] = existingStates[id];
        if (adapterObjects[id].from) delete adapterObjects[id].from;
        if (adapterObjects[id].ts) delete adapterObjects[id].ts;
        if (adapterObjects[id].acl) delete adapterObjects[id].acl;
        if (adapterObjects[id]._id) delete adapterObjects[id]._id;
        if (obj.common && adapterObjects[id].common) {
            if (obj.common.def === undefined && adapterObjects[id].common.def !== undefined) delete adapterObjects[id].common.def;
            if (obj.common.unit === undefined && adapterObjects[id].common.unit !== undefined) delete adapterObjects[id].common.unit;
            if (obj.common.min === undefined && adapterObjects[id].common.min !== undefined) delete adapterObjects[id].common.min;
            if (obj.common.max === undefined && adapterObjects[id].common.max !== undefined) delete adapterObjects[id].common.max;
        }
        //value = undefined; // when exists and it is first time do not overwrite value!
    }
    if (existingStates[id]) delete(existingStates[id]);
    if (adapterObjects[id] && isEquivalent(obj, adapterObjects[id])) {
        //adapter.log.debug('Object unchanged for ' + id + ': ' + JSON.stringify(adapterObjects[id]) + ' - update only: ' + JSON.stringify(value));
        //if (value !== undefined) adapter.setState(id, value, true);
        //if (stateChangeCallback) stateChangeTrigger[id] = stateChangeCallback;
        adapterObjects[id] = JSON.parse(JSON.stringify(obj));
        obj = null;
    } else {
        adapterObjects[id] = JSON.parse(JSON.stringify(obj));
    }
    //adapter.log.debug('Add Object for ' + id + ': ' + JSON.stringify(adapterObjects[id]) + '/' + JSON.stringify(obj));

    objectQueue.push({
        id: id,
        value: value,
        obj: obj,
        stateChangeCallback: stateChangeCallback,
        preserveSettings
    });
    //adapter.log.debug('Create object for ' + id + ': ' + JSON.stringify(obj) + ' with value: ' + JSON.stringify(value));

    if (createNow) {
        processObjectQueue(callback);
    }
}

function deleteObject(id) {
    if (id.startsWith(adapter.namespace)) {
        id = id.substr(adapter.namespace.length + 1);
    }
    const obj = adapterObjects[id];
    if (obj && obj.type) {
        if (obj.type !== 'state') {
            adapter.log.debug(`Delete objects for ${id}`);
            Object.keys(adapterObjects).forEach((objId) => {
                if (objId.startsWith(`${id}.`)) {
                    try {
                        adapter.delObject(objId, (err) => {
                            err = err ? ` (${err})` : '';
                            adapter.log.info(`${adapterObjects[objId] ? adapterObjects[objId].type : '?'} ${objId} deleted${err}`);
                            if (!err) {
                                delete adapterObjects[objId];
                                delete stateChangeTrigger[objId];
                            }
                        });
                    } catch (err) {
                        adapter.log.info(`Cannot delete ${objId}: ${err}`);
                    }
                }
            });
        }
        try {
            adapter.delObject(id, (err) => {
                adapter.log.info(`${obj.type} ${id} deleted (${err})`);
                if (!err) {
                    delete adapterObjects[id];
                    delete stateChangeTrigger[id];
                }
            });
        } catch (err) {
            adapter.log.info(`Cannot delete ${id}: ${err}`);
        }
    }
    else {
        adapter.log.info(`Try to delete unknown object ${id}`);
    }
}

function ucFirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

function isEquivalent(a, b) {
    //adapter.log.debug('Compare ' + JSON.stringify(a) + ' with ' +  JSON.stringify(b));
    // Create arrays of property names
    if (a === null || a === undefined || b === null || b === undefined) {
        return (a === b);
    }
    const aProps = Object.getOwnPropertyNames(a);
    const bProps = Object.getOwnPropertyNames(b);

    // If number of properties is different,
    // objects are not equivalent
    if (aProps.length !== bProps.length) {
        //console.log('num props different: ' + JSON.stringify(aProps) + ' / ' + JSON.stringify(bProps));
        return false;
    }

    for (let i = 0; i < aProps.length; i++) {
        const propName = aProps[i];

        if (typeof a[propName] !== typeof b[propName]) {
            //console.log('type props ' + propName + ' different');
            return false;
        }
        if (typeof a[propName] === 'object') {
            if (!isEquivalent(a[propName], b[propName])) {
                return false;
            }
        }
        else {
            // If values of same property are not equal,
            // objects are not equivalent
            if (a[propName] !== b[propName]) {
                //console.log('props ' + propName + ' different');
                return false;
            }
        }
    }

    // If we made it this far, objects
    // are considered equivalent
    return true;
}

function processObjectQueue(callback) {
    if (!objectQueue.length) {
        callback && callback();
        return;
    }

    function handleObject(queueEntry, callback) {
        if (!queueEntry.obj) {
            handleValue(queueEntry, () => {
                return callback && callback();
            });
            return;
        }
        const options = {};
        if (queueEntry.preserveSettings) {
            options.preserve = queueEntry.preserveSettings; //{ common: ['name'], native: true } };
        }
        adapter.getObject(queueEntry.id, (err, obj) => {
            if (!err && obj) {
                adapter.extendObject(queueEntry.id, queueEntry.obj, options, () => {
                    handleValue(queueEntry, () => {
                        return callback && callback();
                    });
                });
            }
            else {
                adapter.setObject(queueEntry.id, queueEntry.obj, () => {
                    handleValue(queueEntry, () => {
                        return callback && callback();
                    });
                });
            }
        });
    }

    function handleValue(queueEntry, callback) {
        if (queueEntry.value === undefined) {
            stateChangeTrigger[queueEntry.id] = queueEntry.stateChangeCallback;
            return callback && callback();
        }
        adapter.setState(queueEntry.id, queueEntry.value, true, () => {
            stateChangeTrigger[queueEntry.id] = queueEntry.stateChangeCallback;
            return callback && callback();
        });
    }

    const queueEntry = objectQueue.shift();
    handleObject(queueEntry, () => {
        return processObjectQueue(callback);
    });
}

function initSentry(callback) {
    if (!adapter.ioPack.common || !adapter.ioPack.common.plugins || !adapter.ioPack.common.plugins.sentry) {
        return callback && callback();
    }
    const sentryConfig = adapter.ioPack.common.plugins.sentry;
    if (!sentryConfig.dsn) {
        adapter.log.warn('Invalid Sentry definition, no dsn provided. Disable error reporting');
        return callback && callback();
    }
    adapter.getForeignObject('system.meta.uuid', (err, obj) => {
        // create uuid
        if (!err  && obj) {
            installationUuid = obj.native.uuid;
        }

        if (adapter.supportsFeature && adapter.supportsFeature('PLUGINS')) {
            const sentryInstance = adapter.getPluginInstance('sentry');
            if (sentryInstance) {
                Sentry = sentryInstance.getSentryObject();
            }
        }
        if (Sentry) {
            return callback && callback();
        }
        // Require needed tooling
        Sentry = require('@sentry/node');
        SentryIntegrations = require('@sentry/integrations');
        // By installing source map support, we get the original source
        // locations in error messages
        require('source-map-support').install();

        let sentryPathWhitelist = [];
        if (sentryConfig.pathWhitelist && Array.isArray(sentryConfig.pathWhitelist)) {
            sentryPathWhitelist = sentryConfig.pathWhitelist;
        }
        if (adapter.pack.name && !sentryPathWhitelist.includes(adapter.pack.name)) {
            sentryPathWhitelist.push(adapter.pack.name);
        }
        let sentryErrorBlacklist = [];
        if (sentryConfig.errorBlacklist && Array.isArray(sentryConfig.errorBlacklist)) {
            sentryErrorBlacklist = sentryConfig.errorBlacklist;
        }
        if (!sentryErrorBlacklist.includes('SyntaxError')) {
            sentryErrorBlacklist.push('SyntaxError');
        }

        Sentry.init({
            release: `${adapter.pack.name}@${adapter.pack.version}`,
            dsn: sentryConfig.dsn,
            integrations: [
                new SentryIntegrations.Dedupe()
            ]
        });
        Sentry.configureScope(scope => {
            if (adapter.supportsFeature && adapter.supportsFeature('PLUGINS')) {
                scope.setTag('activationOverwrite', true);
            }
            scope.setTag('version', adapter.common.installedVersion || adapter.common.version);
            if (adapter.common.installedFrom) {
                scope.setTag('installedFrom', adapter.common.installedFrom);
            }
            else {
                scope.setTag('installedFrom', adapter.common.installedVersion || adapter.common.version);
            }
            scope.addEventProcessor(function(event, hint) {
                // Try to filter out some events
                if (event.exception && event.exception.values && event.exception.values[0]) {
                    const eventData = event.exception.values[0];
                    // if error type is one from blacklist we ignore this error
                    if (eventData.type && sentryErrorBlacklist.includes(eventData.type)) {
                        return null;
                    }
                    if (eventData.stacktrace && eventData.stacktrace.frames && Array.isArray(eventData.stacktrace.frames) && eventData.stacktrace.frames.length) {
                        // if last exception frame is from an nodejs internal method we ignore this error
                        if (eventData.stacktrace.frames[eventData.stacktrace.frames.length - 1].filename && (eventData.stacktrace.frames[eventData.stacktrace.frames.length - 1].filename.startsWith('internal/') || eventData.stacktrace.frames[eventData.stacktrace.frames.length - 1].filename.startsWith('Module.'))) {
                            return null;
                        }
                        // Check if any entry is whitelisted from pathWhitelist
                        const whitelisted = eventData.stacktrace.frames.find(frame => {
                            if (frame.function && frame.function.startsWith('Module.')) {
                                return false;
                            }
                            if (frame.filename && frame.filename.startsWith('internal/')) {
                                return false;
                            }
                            if (frame.filename && !sentryPathWhitelist.find(path => path && path.length && frame.filename.includes(path))) {
                                return false;
                            }
                            return true;
                        });
                        if (!whitelisted) {
                            return null;
                        }
                    }
                }

                return event;
            });

            adapter.getForeignObject('system.config', (err, obj) => {
                if (obj && obj.common && obj.common.diag !== 'none') {
                    if (installationUuid) {
                        Sentry.configureScope(scope => {
                            scope.setUser({
                                id: obj.native.uuid
                            });
                        });
                    }
                }
                callback && callback();
            });
        });
    });
}

function startAdapter(options) {
    options = options || {};
    Object.assign(options, {
        name: 'alexa2'
    });

    adapter = new utils.Adapter(options);

    adapter.on('unload', (callback) => {
        stopped = true;
        if (resetCrashCheckerTimeout) {
            clearTimeout(resetCrashCheckerTimeout);
            if (!isCrashStop) {
                try {
                    if (fs.existsSync(crashCheckFileName)) {
                        fs.unlinkSync(crashCheckFileName);
                    }
                } catch (err) {
                    adapter.log.error(`Error deleting crashCheck file: ${err.message}`);
                }
            }
        }
        checkerInterval && clearInterval(checkerInterval);
        updateSmartHomeDevicesTimer && clearTimeout(updateSmartHomeDevicesTimer);
        updateStateTimer && clearTimeout(updateStateTimer);
        updateConfigurationTimer && clearTimeout(updateConfigurationTimer);
        updateHistoryTimer && clearTimeout(updateHistoryTimer);
        Object.keys(notificationTimer).forEach(timer => notificationTimer[timer] && clearTimeout(notificationTimer[timer]));
        Object.keys(updateNotificationTimer).forEach(timer => updateNotificationTimer[timer] && clearTimeout(updateNotificationTimer[timer]));
        Object.keys(updatePlayerTimer).forEach(timer => updatePlayerTimer[timer] && clearTimeout(updatePlayerTimer[timer]));
        Object.keys(lastPlayerState).forEach(timer => lastPlayerState[timer] && lastPlayerState[timer].timeout && clearTimeout(lastPlayerState[timer].timeout));
        Object.keys(shDeviceRefreshTimeoutAfterControl).forEach(timer => shDeviceRefreshTimeoutAfterControl[timer] && clearTimeout(shDeviceRefreshTimeoutAfterControl[timer]));

        if (alexa) {
            alexa.stop();
        }
        callback && callback();
    });

    adapter.on('stateChange', (id, state) => {
        adapter.log.debug(`State changed ${id}: ${JSON.stringify(state)}`);
        if (!state || state.ack) return;
        id = id.substr(adapter.namespace.length + 1);

        if (state && state.val && state.from && state.from.startsWith('system.adapter.cloud') && id.endsWith('.Commands.speak')) {
            state.val = state.val.replace(/<[^>]+>/g, '').replace('/  /g', ' ');
        }

        if (typeof stateChangeTrigger[id] === 'function') {
            if (adapterObjects[id] && adapterObjects[id].common && adapterObjects[id].common.type && adapterObjects[id].common.type !== 'mixed') {
                if (adapterObjects[id].common.type === 'boolean' && adapterObjects[id].common.role && adapterObjects[id].common.role.startsWith('button')) state.val = !!state.val;
                if (typeof state.val !== adapterObjects[id].common.type) {
                    adapter.log.error(`Datatype "${typeof state.val}" for ${id} differs from expected "${adapterObjects[id].common.type}", ignore state change! Please write correct datatype`);
                    return;
                }
            }
            stateChangeTrigger[id](state.val);
        }

        if (!pushConnected) scheduleStatesUpdate(3000);
    });

    adapter.on('objectChange', (id, object) => {
        if (!initDone) return;
        adapter.log.debug(`Object changed ${id}: ${JSON.stringify(object)}`);
        if (!id || !id.startsWith(`${adapter.namespace}.Echo-Devices.`)) return;
        const ar = id.split('.');
        if (ar[2] === 'Echo-Devices' && ar.length === 4) {
            if (object === null) {
                //deleted, do nothing
                return;
            }
            const device = alexa.serialNumbers[ar[3]];
            if (device && object && object.common && object.common.name && device._name && object.common.name !== device._name) {
                if (typeof device.rename === 'function') device.rename(object.common.name);
            }
        }
    });

    adapter.on('message', function(msg) {
        processMessage(msg);
    });

    adapter.on('ready', () => {
        initSentry(() => loadExistingAccessories(checkInstanceObject(main)));
    });

    return adapter;
}

function checkInstanceObject(callback) {
    adapter.getForeignObject('system.adapter.' + adapter.namespace, (err, obj) => {
        if (obj && obj.common && obj.common.restartSchedule) {
            const cronParts = obj.common.restartSchedule.split(' ');
            if ((cronParts[0] || '').startsWith('*') || (cronParts[1] || '').startsWith('*') || (cronParts.length === 6 && cronParts[2].startsWith('*'))) {
                adapter.log.error(`Restart schedule "${obj.common.restartSchedule}" is too often, please set a restart schedule that makes sense. Disabling adapter now.`);
                adapter.terminate && adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
                return;
            }
        }
        callback();
    });
}

function processMessage(msg) {
    adapter.log.debug(`Message: ${JSON.stringify(msg)}`);
    switch (msg.command) {
        case 'getStatusInfo':
            getStatusInfo(msg);
            break;
        case 'sendSequenceCommand':
            sendSequenceCommand(msg);
            break;
    }
}

function getStatusInfo(msg) {
    adapter.sendTo(msg.from, msg.command, {
        result: {
            proxyActive: proxyUrl !== null,
            proxyUrl: proxyUrl,
            cookieTimestamp: (adapter.config.cookieData && adapter.config.cookieData.tokenDate) ? adapter.formatDate(adapter.config.cookieData.tokenDate) : 0
        },
        error: null
    }, msg.callback);
}

function sendSequenceCommand(msg) {
    if (!msg.message.sequenceNodes) {
        adapter.sendTo(msg.from, msg.command, {
            result: null,
            error: 'No sequenceNodes given'
        }, msg.callback);
        return;
    }
    if (!msg.message.deviceSerialNumber) {
        adapter.sendTo(msg.from, msg.command, {
            result: null,
            error: 'No deviceId given'
        }, msg.callback);
        return;
    }
    if (!alexa) {
        adapter.sendTo(msg.from, msg.command, {
            result: null,
            error: 'Alexa connection not initialized'
        }, msg.callback);
        return;
    }
    alexa.sendMultiSequenceCommand(msg.message.deviceSerialNumber, msg.message.sequenceNodes, msg.message.sequenceType, alexa.ownerCustomerId, (err, res) => {
        adapter.sendTo(msg.from, msg.command, {
            result: res,
            error: err
        }, msg.callback);
    });
}

function setRequestResult(err, res) {
    if (!err) return;
    adapter.setState('requestResult', err.message ? err.message : err, true);
}

/**
 * Konvertiert eine Sekundenzahl in einen String im Format (HH:)MM:SS
 *
 * @param {number} sec seconds
 * @return string
 */
function sec2HMS(sec) {
    if (sec  === 0) {
        return '0';
    }

    const sec_num = parseInt(sec, 10);
    let hours   = Math.floor(sec_num / 3600);
    let minutes = Math.floor((sec_num - (hours * 3600)) / 60);
    let seconds = sec_num - (hours * 3600) - (minutes * 60);

    if (minutes < 10) {minutes = `0${minutes}`;}
    if (seconds < 10) {seconds = `0${seconds}`;}
    if (hours === 0) {
        return `${minutes}:${seconds}`;
    }

    if (hours < 10) {hours = `0${hours}`;}
    return `${hours}:${minutes}:${seconds}`;
}


function scheduleNotificationUpdate(deviceId, delay, onlyIfNew) {
    if (updateNotificationTimer[deviceId]) {
        if (onlyIfNew) return;
        clearTimeout(updateNotificationTimer[deviceId]);
    }
    updateNotificationTimer[deviceId] = setTimeout(() => {
        updateNotificationTimer[deviceId] = null;
        updateNotificationStates(deviceId);
    }, delay);
}

function schedulePlayerUpdate(deviceId, delay, onlyIfNew) {
    if (updatePlayerTimer[deviceId]) {
        if (onlyIfNew) return;
        clearTimeout(updatePlayerTimer[deviceId]);
    }
    adapter.log.debug(`Schedule new Player Update in ${delay}ms`);
    updatePlayerTimer[deviceId] = setTimeout(() => {
        updatePlayerTimer[deviceId] = null;
        updatePlayerStatus(deviceId);
    }, delay);
}

function scheduleStatesUpdate(delay) {
    if (updateStateTimer) {
        clearTimeout(updateStateTimer);
    }
    if (delay === undefined) {
        if (!adapter.config.updateStateInterval) return;
        delay = adapter.config.updateStateInterval * 1000;
        if (pushConnected) delay = 60 * 60 * 1000; // 1h
    }
    delay = Math.max(delay, 300000);
    updateStateTimer = setTimeout(() => {
        if (stopped) return;
        updateStateTimer = null;
        updateStates();
    }, delay);
}

async function setEqualizer(device) {
    delete equalizerUpdateTimeouts[device.serialNumber];

    const bassState = await adapter.getStateAsync(`Echo-Devices.${device.serialNumber}.Preferences.equalizerBass`);
    const midState = await adapter.getStateAsync(`Echo-Devices.${device.serialNumber}.Preferences.equalizerMidRange`);
    const trebleState = await adapter.getStateAsync(`Echo-Devices.${device.serialNumber}.Preferences.equalizerTreble`);

    alexa.setEqualizerSettings(device, bassState ? bassState.val : undefined, midState ? midState.val : undefined, trebleState ? trebleState.val : undefined, (err, res) => {
        if (err || !res) {
            adapter.log.error(`${device.serialNumber} Error setting equalizer settings: ${err}`);
            return;
        }
        if (device.capabilities.includes('EQUALIZER_CONTROLLER_BASS') && res.bass !== undefined) {
            adapter.setState(`Echo-Devices.${device.serialNumber}.Preferences.equalizerBass`, res.bass, true);
        }
        if (device.capabilities.includes('EQUALIZER_CONTROLLER_MIDRANGE') && res.mid !== undefined) {
            adapter.setState(`Echo-Devices.${device.serialNumber}.Preferences.equalizerMidRange`, res.mid, true);
        }
        if (device.capabilities.includes('EQUALIZER_CONTROLLER_TREBLE') && res.treble !== undefined) {
            adapter.setState(`Echo-Devices.${device.serialNumber}.Preferences.equalizerTreble`, res.treble, true);
        }
    });
}

function initEqualizerData(device) {
    return new Promise(resolve => {
        if (!device.capabilities.includes('EQUALIZER_CONTROLLER_BASS') && !device.capabilities.includes('EQUALIZER_CONTROLLER_MIDRANGE') && !device.capabilities.includes('EQUALIZER_CONTROLLER_TREBLE')) {
            return resolve(0);
        }
        alexa.getEqualizerEnabled(device, (err, res) => {
            if (err || !res) {
                adapter.log.error(`${device.serialNumber} Error getting equalizer enabled: ${err}`);
                return resolve(0);
            }
            if (!res.enabled) {
                return resolve(0);
            }
            alexa.getEqualizerRange(device, (err, res) => {
                if (err || !res) {
                    adapter.log.error(`${device.serialNumber} Error getting equalizer range: ${err}`);
                    return resolve(0);
                }
                const rangeMin = res.min || -6;
                const rangeMax = res.max || 6;

                alexa.getEqualizerSettings(device, (err, res) => {
                    if (err || !res) {
                        adapter.log.error(`${device.serialNumber} Error getting equalizer setting: ${err}`);
                        return resolve(0);
                    }

                    let numStates = 0;

                    if (device.capabilities.includes('EQUALIZER_CONTROLLER_BASS')) {
                        numStates++;
                        setOrUpdateObject(`Echo-Devices.${device.serialNumber}.Preferences.equalizerBass`, {
                            common: {
                                name: `Equalizer Bass`,
                                type: 'number',
                                role: 'level.bass',
                                min: rangeMin,
                                max: rangeMax
                            }
                        }, res.bass, function (device, value) {
                            if (typeof value !== 'number') {
                                value = parseInt(value, 10);
                                if (isNaN(value)) {
                                    adapter.log.error(`${device.serialNumber} Error bass value must be a number`);
                                    return;
                                }
                            }
                            equalizerUpdateTimeouts[device.serialNumber] && clearTimeout(equalizerUpdateTimeouts[device.serialNumber]);
                            equalizerUpdateTimeouts[device.serialNumber] = setTimeout(() => setEqualizer(device), 500);
                        }.bind(alexa, device));
                    }
                    if (device.capabilities.includes('EQUALIZER_CONTROLLER_MIDRANGE')) {
                        numStates++;
                        setOrUpdateObject(`Echo-Devices.${device.serialNumber}.Preferences.equalizerMidRange`, {
                            common: {
                                name: `Equalizer Midrange`,
                                type: 'number',
                                role: 'level.midrange',
                                min: rangeMin,
                                max: rangeMax
                            }
                        }, res.mid, function (device, value) {
                            if (typeof value !== 'number') {
                                value = parseInt(value, 10);
                                if (isNaN(value)) {
                                    adapter.log.error(`${device.serialNumber} Error midrange value must be a number`);
                                    return;
                                }
                            }
                            equalizerUpdateTimeouts[device.serialNumber] && clearTimeout(equalizerUpdateTimeouts[device.serialNumber]);
                            equalizerUpdateTimeouts[device.serialNumber] = setTimeout(() => setEqualizer(device), 500);
                        }.bind(alexa, device));
                    }
                    if (device.capabilities.includes('EQUALIZER_CONTROLLER_TREBLE')) {
                        numStates++;
                        setOrUpdateObject(`Echo-Devices.${device.serialNumber}.Preferences.equalizerTreble`, {
                            common: {
                                name: `Equalizer Treble`,
                                type: 'number',
                                role: 'level.treble',
                                min: rangeMin,
                                max: rangeMax
                            }
                        }, res.treble, function (device, value) {
                            if (typeof value !== 'number') {
                                value = parseInt(value, 10);
                                if (isNaN(value)) {
                                    adapter.log.error(`${device.serialNumber} Error treble value must be a number`);
                                    return;
                                }
                            }
                            equalizerUpdateTimeouts[device.serialNumber] && clearTimeout(equalizerUpdateTimeouts[device.serialNumber]);
                            equalizerUpdateTimeouts[device.serialNumber] = setTimeout(() => setEqualizer(device), 500);
                        }.bind(alexa, device));
                    }

                    resolve(numStates);
                });
            });
        });
    });
}

function initDeviceAuxController(device) {
    return new Promise(resolve => {
        let numStates = 0;
        alexa.getAuxControllerState(device, (err, res) => {
            if (err) {
                adapter.log.error(`${device.serialNumber} Error getting aux controller state: ${err}`);
                return resolve(0);
            }
            if (res && res.ports && Array.isArray(res.ports) && device.capabilities.includes('AUX_SETTINGS')) {
                res.ports.forEach(port => {
                    numStates++;
                    setOrUpdateObject(`Echo-Devices.${device.serialNumber}.Preferences.auxPort-${port.id}-Direction`, {
                        common: {
                            name: `Port ${port.id} direction`,
                            type: 'string',
                            role: 'text',
                            states: {'INPUT': 'INPUT', 'OUTPUT': 'OUTPUT'}
                        }
                    }, port.direction, function (device, port, value) {
                        if (value !== 'INPUT' && value !== 'OUTPUT') {
                            adapter.log.error(`${device.serialNumber} Error port direction value invalid`);
                            return;
                        }
                        alexa.setAuxControllerPortDirection(device, value, port.id, (err, res) => {
                            if (err) {
                                adapter.log.error(`${device.serialNumber} Error setting aux controller port direction: ${err}`);
                                return;
                            }
                            adapter.setState(`Echo-Devices.${device.serialNumber}.Preferences.auxPort-${port.id}-Direction`, value, true);
                        });
                    }.bind(alexa, device, port));
                });
            }

            alexa.getConnectedSpeakerOptionSetting(device, (err, res2) => {
                if (err) {
                    adapter.log.error(`${device.serialNumber} Error getting connected speaker setting: ${err}`);
                    return resolve(numStates);
                }
                if (res2) {
                    numStates++;
                    const states = {
                        'Bluetooth': 'Bluetooth',
                        'InternalSpeaker': 'InternalSpeaker'
                    };
                    if (res && res.ports && res.ports.length) {
                        states['Aux'] = 'Aux (if supported)';
                    }
                    setOrUpdateObject(`Echo-Devices.${device.serialNumber}.Preferences.connectedSpeaker`, {
                        common: {
                            name: `Connected Speaker Option`,
                            type: 'string',
                            role: 'text',
                            states
                        }
                    }, res2, function (device, value) {
                        if (states[value] === undefined) {
                            adapter.log.error(`${device.serialNumber} Error connected speaker value invalid`);
                            return;
                        }
                        alexa.setConnectedSpeakerOptionSetting(device, value, (err,res) => {
                            if (err) {
                                adapter.log.error(`${device.serialNumber} Error setting connected speaker setting: ${err}`);
                                return;
                            }
                            adapter.setState(`Echo-Devices.${device.serialNumber}.Preferences.connectedSpeaker`, value, true);
                        });
                    }.bind(alexa, device));
                }
                resolve(numStates);
            });
        });
    });
}

function initDisplaySettings(device) {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async resolve => {
        if (!device.capabilities.includes('DISPLAY_POWER_TOGGLE') && !device.capabilities.includes('DISPLAY_BRIGHTNESS_ADJUST') && !device.capabilities.includes('DISPLAY_ADAPTIVE_BRIGHTNESS')) {
            return resolve(0);
        }
        let numStates = 0;
        if (device.capabilities.includes('DISPLAY_POWER_TOGGLE')) {
            numStates++;
            const displayPower = await new Promise(resolve => {
                alexa.getDisplayPowerSetting(device, (err, res) => {
                    if (err) {
                        adapter.log.error(`${device.serialNumber} Error getting display enabled setting: ${err}`);
                        return resolve(undefined);
                    }
                    resolve(res);
                });
            });
            setOrUpdateObject(`Echo-Devices.${device.serialNumber}.Preferences.displayEnabled`, {
                common: {
                    name: `Display enabled`,
                    type: 'boolean',
                    role: 'switch'
                }
            }, displayPower, function (device, value) {
                alexa.setDisplayPowerSetting(device, !!value, (err, res) => {
                    if (err) {
                        adapter.log.error(`${device.serialNumber} Error setting display enabled: ${err}`);
                        return;
                    }
                    adapter.setState(`Echo-Devices.${device.serialNumber}.Preferences.displayEnabled`, !!value, true);
                });
            }.bind(alexa, device));
        }
        if (device.capabilities.includes('DISPLAY_BRIGHTNESS_ADJUST')) {
            numStates++;
            const displayBrightness = await new Promise(resolve => {
                alexa.getBrightnessSetting(device, (err, res) => {
                    if (err) {
                        adapter.log.error(`${device.serialNumber} Error getting display brightness setting: ${err}`);
                        return resolve(undefined);
                    }
                    resolve(res);
                });
            });
            setOrUpdateObject(`Echo-Devices.${device.serialNumber}.Preferences.displayBrightness`, {
                common: {
                    name: `Display Brightness`,
                    type: 'number',
                    role: 'level.brightness',
                    min: 0,
                    max: 100,
                    unit: '%'
                }
            }, displayBrightness, function (device, value) {
                if (typeof value !== 'number') {
                    value = parseInt(value, 10);
                    if (isNaN(value)) {
                        adapter.log.error(`${device.serialNumber} Error brightness value must be a number`);
                        return;
                    }
                }
                if (value < 0 || value > 100) {
                    adapter.log.error(`${device.serialNumber} Error brightness value must be between 0 and 100`);
                    return;
                }
                alexa.setBrightnessSetting(device, value, (err, res) => {
                    if (err) {
                        adapter.log.error(`${device.serialNumber} Error setting display brightness: ${err}`);
                        return;
                    }
                    adapter.setState(`Echo-Devices.${device.serialNumber}.Preferences.displayBrightness`, value, true);
                });
            }.bind(alexa, device));
        }
        if (device.capabilities.includes('DISPLAY_ADAPTIVE_BRIGHTNESS')) {
            numStates++;
            const adaptiveBrightness = await new Promise(resolve => {
                alexa.getAdaptiveBrightnessSetting(device, (err, res) => {
                    if (err) {
                        adapter.log.error(`${device.serialNumber} Error getting display adaptive brightness setting: ${err}`);
                        return resolve(undefined);
                    }
                    resolve(res);
                });
            });
            setOrUpdateObject(`Echo-Devices.${device.serialNumber}.Preferences.displayAdaptiveBrightnessEnabled`, {
                common: {
                    name: `Display adaptive brightness`,
                    type: 'boolean',
                    role: 'switch'
                }
            }, adaptiveBrightness, function (device, value) {
                alexa.setAdaptiveBrightnessSetting(device, !!value, (err, res) => {
                    if (err) {
                        adapter.log.error(`${device.serialNumber} Error setting display adaptive brightness: ${err}`);
                        return;
                    }
                    adapter.setState(`Echo-Devices.${device.serialNumber}.Preferences.displayAdaptiveBrightnessEnabled`, !!value, true);
                });
            }.bind(alexa, device));
        }
        resolve(numStates);
    });
}


function updateDeviceConfigurationStates(callback) {
    if (stopped) return;
    alexa.getDoNotDisturb((err, res) => {
        if (stopped) return;

        if (!err && res && res.doNotDisturbDeviceStatusList && Array.isArray(res.doNotDisturbDeviceStatusList)) {
            res.doNotDisturbDeviceStatusList.forEach(status => {
                const device = alexa.find(status.deviceSerialNumber);
                if (device && device.deviceTypeDetails && device.deviceTypeDetails.commandSupport) {
                    adapter.setState(`Echo-Devices.${device.serialNumber}.Commands.doNotDisturb`, status.enabled, true);
                }
            });
        }

        alexa.getDevicePreferences((err, res) => {
            if (stopped) return;
            if (!err && res && res.devicePreferences && Array.isArray(res.devicePreferences)) {
                res.devicePreferences.forEach(pref => {
                    if (!pref.deviceSerialNumber) return;
                    const device = alexa.find(pref.deviceSerialNumber);
                    if (!device) return;
                    device.preferences = pref;

                    if (device.capabilities.includes('EARCONS') && pref.notificationEarconEnabled !== undefined && adapterObjects[`Echo-Devices.${device.serialNumber}.Preferences.ringNotificationsEnabled`]) {
                        adapter.setState(`Echo-Devices.${device.serialNumber}.Preferences.ringNotificationsEnabled`, pref.notificationEarconEnabled, true);
                    }
                });
            }

            if (adapter.config.updateConfigurationInterval > 0) {
                updateConfigurationTimer = setTimeout(() => {
                    updateDeviceConfigurationStates();
                }, Math.max(adapter.config.updateConfigurationInterval * 1000, 300000));
            }
            callback && callback();
        });
    });
}

function updateStates(callback) {
    if (updateStateTimer) {
        clearTimeout(updateStateTimer);
        updateStateTimer = null;
    }
    if (stopped) return;

    updateDeviceStatus(() => {
        updateBluetoothStatus(() => {
            updatePlayerStatus(callback);
        });
    });
}

/**
 * Inkrementiert 'mediaProgress' alle 2 Sekunden um 2. So wird ein permanentes https-get überflüssig
 * ruft sich nach 2 Sekunden erneut selbst auf, wenn 'currentState' noch auf 'PLAYING' steht.
 * ist 'mediaProgress' größer als 'mediaLength', so ist der Song zu Ende und 'updateDevice' wird aufgerufen.
 *
 * @param {string} serialNumber serial number
 */
function updateMediaProgress(serialNumber) {
    if (!lastPlayerState[serialNumber] || !lastPlayerState[serialNumber].resPlayer) return;

    if (lastPlayerState[serialNumber].timeout) {
        clearTimeout(lastPlayerState[serialNumber].timeout);
        lastPlayerState[serialNumber].timeout = null;
    }

    const resPlayer = lastPlayerState[serialNumber].resPlayer;
    const devId = lastPlayerState[serialNumber].devId;
    const lastTimestamp = lastPlayerState[serialNumber].ts;

    const currentState = resPlayer.playerInfo.state;

    if (currentState === 'PLAYING' && resPlayer.playerInfo && resPlayer.playerInfo.progress) {
        const mediaProgress = parseInt(resPlayer.playerInfo.progress.mediaProgress, 10);
        const mediaLength = parseInt(resPlayer.playerInfo.progress.mediaLength || '0', 10);
        const timeframe = ~~((Date.now() - lastTimestamp) / 1000); // calculate time since last data
        const mediaProgressNew = mediaProgress + timeframe; // add this to the progress

        // Am Ende des Titels soll neu geladen werden. Ist es Radio (länge = 0) dann alle 200 sekunden
        if (mediaProgressNew > mediaLength && (mediaLength > 0 || mediaProgressNew % 200 < 2)) {
            schedulePlayerUpdate(serialNumber, 2000);
            return;
        }

        // Nun mediaProgress und mediaProgressPercent neu berechnen
        let mediaProgressPercent = 0;
        let mediaRemaining = 0;
        if (mediaLength > 0) {
            mediaProgressPercent = Math.round((((mediaProgressNew) * 100) / mediaLength));
            mediaRemaining = mediaLength - mediaProgressNew;
        }
        adapter.setState(`${devId}.Player.mediaProgressPercent`, mediaProgressPercent, true);
        adapter.setState(`${devId}.Player.mediaProgress`, mediaProgressNew, true);
        adapter.setState(`${devId}.Player.mediaProgressStr`, sec2HMS(mediaProgressNew), true);
        adapter.setState(`${devId}.Player.mediaRemaining`, mediaRemaining, true);
        adapter.setState(`${devId}.Player.mediaLengthStr`, sec2HMS(mediaRemaining), true);

        lastPlayerState[serialNumber].timeout = setTimeout( () => {
            lastPlayerState[serialNumber].timeout = null;
            updateMediaProgress(serialNumber);
        }, 2000);
    }
    else {
        schedulePlayerUpdate(serialNumber, (2 * 60 * 60 + 5) * 1000);
    }
}

function generateApplianceQueryArray(applianceId, queryAllProperties) {
    let propertiesToQuery;
    if (!queryAllProperties) {
        propertiesToQuery = shApplianceEntityMap[applianceId].supportedProperties;
    }
    if (!queryAllProperties && (!propertiesToQuery || !propertiesToQuery.length)) {
        return [];
    }

    const reqArr = [];
    const reqApplianceIds = {};
    reqApplianceIds[applianceId] = true;
    if (shApplianceEntityMap[applianceId].mergedApplianceIds && Array.isArray(shApplianceEntityMap[applianceId].mergedApplianceIds)) {
        shApplianceEntityMap[applianceId].mergedApplianceIds.forEach(id => {
            reqApplianceIds[id] = true;
        });
    }
    Object.keys(reqApplianceIds).forEach(id => {
        reqArr.push({
            entityId: id,
            entityType: 'APPLIANCE',
            properties: propertiesToQuery
        });
    });
    if (reqArr.length > 1 || (reqArr.length === 1 && !reqArr[0].entityId.startsWith('SKILL'))) {
        reqArr.push({
            entityId: shApplianceEntityMap[applianceId].entityId,
            entityType: 'ENTITY'
        });
    }
    return reqArr;
}

function queryAllSmartHomeDevices(initial, cloudOnly, callback) {
    if (updateSmartHomeDevicesTimer) {
        clearTimeout(updateSmartHomeDevicesTimer);
        updateSmartHomeDevicesTimer = null;
    }

    if (!adapter.config.synchronizeSmartHomeDevices) {
        return callback && callback();
    }

    const reqArr = [];
    const blocked = [];
    for (const applianceId of Object.keys(shApplianceEntityMap)) {
        const queryIt = shQueryEnabled[applianceId] && (cloudOnly ? shApplianceEntityMap[applianceId].cloudReadable : shApplianceEntityMap[applianceId].readable);

        if (queryIt) {
            if (shQueryBlocker[applianceId]) {
                blocked.push(applianceId);
                continue;
            }
            reqArr.push(...generateApplianceQueryArray(applianceId, false));
            if (!initial) {
                /**
                 * Please DO NOT modify these block values and DO NOT lower them! Doing this might mean that Amazon
                 * blocks the Smart home device queries for all > 20k ioBroker Adapter users!
                 */
                let delay = 1200000;
                if (!applianceId.startsWith('SKILL_') && shApplianceEntityMap[applianceId].cloudReadable) delay = 900000;
                shQueryBlocker[applianceId] = setTimeout(() => {
                    shQueryBlocker[applianceId] = null;
                }, delay);
            }
        }
    }
    if (blocked.length) {
        adapter.log.warn(`Smarthome device queries blocked for ${blocked.length} devices: ${blocked.join(',')}`);
    }

    if (!reqArr.length) {
        adapter.log.info('No smart home devices to query');
        return callback && callback();
    }

    const cachedDeviceStatesFileName = path.join(__dirname, `cachedDeviceStates.${adapter.namespace}.json`);
    try {
        if (fs.existsSync(cachedDeviceStatesFileName)) {
            const stats = fs.statSync(cachedDeviceStatesFileName);
            if (stats.mtime.getTime() + 900 * 1000 > Date.now()) {
                adapter.log.info(`Home Device states last requested ${stats.mtime} ... Do not request again now`);

                return callback && callback();
            }
        }
    } catch (err) {
        adapter.log.info('Could not cache devices: ' + err.message);
    }

    alexa.querySmarthomeDevices(reqArr, (err, res) => {
        if (!err) {
            if (res && !blocked.length) {
                try {
                    fs.writeFileSync(cachedDeviceStatesFileName, JSON.stringify(res));
                } catch (err) {
                    adapter.log.info(`Cannot write cached device states to file: ${err}`);
                }
            }
            updateSmarthomeDeviceStates(res);
        }

        return callback && callback();
    });
}

function buildSmartHomeControlParameters(entityId, objs, selectorName, changedParamName, changedParamvalue, capInstance) {
    function getValueToSend(obj, value) {
        if (value && obj.native.valueTrue) {
            value = obj.native.valueTrue;
        }
        else if (!value && obj.native.valueFalse) {
            value = obj.native.valueFalse;
        }
        else if (obj.native.valueMap) {
            value = obj.native.valueMap[value];
        }
        else {
            if (value === undefined && obj.native.defaultValue !== undefined) {
                value = obj.native.defaultValue;
            }
            if (typeof value === 'number' && obj.native.factor) {
                value *= obj.native.factor;
            }
            value = String(value);
        }
        return value;
    }

    adapter.log.debug(`buildSmartHomeControlParameters: ${entityId} ${selectorName} ${changedParamName} ${changedParamvalue} for objs = ${JSON.stringify(objs)}`);

    const fullObj = objs;
    if (selectorName !== null) {
        objs = objs[selectorName];
    }

    const parameters = {};
    let sendAdditional = [];
    if (!Array.isArray(objs)) objs = [objs];
    if (capInstance) {
        parameters.instance = capInstance;
    }
    for (const obj of objs) {
        let paramName = obj.common.name;
        const stateId = capInstance ? `${capInstance.replace(/\./g, '-')}-${obj.common.name}`: obj.common.name;
        if (obj.common.name === changedParamName) {
            if (obj.native.action) {
                parameters.action = obj.native.action;
                if (obj.native.paramName) paramName = obj.native.paramName;
                if (obj.native.sendInSubStructureOf) {
                    parameters[obj.native.sendInSubStructureOf] = parameters[obj.native.sendInSubStructureOf] || {};
                    parameters[obj.native.sendInSubStructureOf][paramName] = getValueToSend(obj, changedParamvalue);
                } else {
                    parameters[paramName] = getValueToSend(obj, changedParamvalue);
                }
            }
            else {
                if (changedParamvalue && obj.native.actionTrue) {
                    parameters.action = obj.native.actionTrue;
                }
                else if (!changedParamvalue && obj.native.actionFalse) {
                    parameters.action = obj.native.actionFalse;
                }
            }
            if (obj.native.sendAdditional) {
                sendAdditional = sendAdditional.concat(obj.native.sendAdditional);
            }
        }
        else if (!obj.native.donotsend) {
            if (obj.native.paramName) paramName = obj.native.paramName;
            if (obj.native.sendInSubStructureOf) {
                parameters[obj.native.sendInSubStructureOf] = parameters[obj.native.sendInSubStructureOf] || {};
                parameters[obj.native.sendInSubStructureOf][paramName] = getValueToSend(obj, shDeviceParamValues[`Smart-Home-Devices.${entityId}.${stateId}`]);
            } else {
                parameters[paramName] = getValueToSend(obj, shDeviceParamValues[`Smart-Home-Devices.${entityId}.${stateId}`]);
            }
        }
    }
    if (sendAdditional.length) {
        sendAdditional.forEach(actionName => {
            let addObjs = fullObj[actionName];
            if (!Array.isArray(addObjs)) addObjs = [addObjs];
            for (const obj of addObjs) {
                let paramName = obj.common.name;
                if (!obj.native.donotsend) {
                    if (obj.native.paramName) paramName = obj.native.paramName;
                    if (obj.native.sendInSubStructureOf) {
                        parameters[obj.native.sendInSubStructureOf] = parameters[obj.native.sendInSubStructureOf] || {};
                        parameters[obj.native.sendInSubStructureOf][paramName] = getValueToSend(obj, shDeviceParamValues[`Smart-Home-Devices.${entityId}.${obj.common.name}`]);
                    } else {
                        parameters[paramName] = getValueToSend(obj, shDeviceParamValues[`Smart-Home-Devices.${entityId}.${obj.common.name}`]);
                    }
                }
            }
        });
    }

    adapter.log.debug(`buildSmartHomeControlParameters Response: ${JSON.stringify(parameters)}`);
    return parameters;
}

function padding(num) {
    num = num.toString(16);
    if (num.length < 2) num = `0${num}`;
    return num;
}

// expected hue range: [0, 360]
// expected saturation range: [0, 1]
// expected lightness range: [0, 1]
// Based on http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
function hsvToRgb(h, s, v) {
    let r;
    let g;
    let b;
    h = h / 360;
    const i = Math.floor(h * 6);
    const f = h * 6 - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);

    switch(i % 6){
        case 0:
            r = v;
            g = t;
            b = p;
            break;

        case 1:
            r = q;
            g = v;
            b = p;
            break;

        case 2:
            r = p;
            g = v;
            b = t;
            break;

        case 3:
            r = p;
            g = q;
            b = v;
            break;

        case 4:
            r = t;
            g = p;
            b = v;
            break;

        case 5:
            r = v;
            g = p;
            b = q;
            break;
    }
    return `#${padding(Math.round(r * 255))}${padding(Math.round(g * 255))}${padding(Math.round(b * 255))}`;
}

function updateSmarthomeDeviceStates(res) {
    function handleObject(deviceEntityId, cap, stateName) {
        if (!adapterObjects[`Smart-Home-Devices.${deviceEntityId}.${stateName}`]) {
            adapter.log.debug(`ignoring value "${cap.namespace}.${cap.value}" for Smart-Home-Devices.${deviceEntityId}.${stateName}`);
            return null;
        }
        const native = adapterObjects[`Smart-Home-Devices.${deviceEntityId}.${stateName}`].native;
        const common = adapterObjects[`Smart-Home-Devices.${deviceEntityId}.${stateName}`].common;
        let value = cap.value;
        if (typeof value === 'object') {
            if (value[native.valueSubKey || 'value'] === undefined) {
                if (!native.noFallbackStringifiedValue) {
                    value = JSON.stringify(value);
                } else {
                    value = undefined;
                }
            } else {
                value = value[native.valueSubKey || 'value'];
                if (value !== null && typeof value === 'object' && !native.noFallbackStringifiedValue) { // TODO: maybe always stringified?
                    value = JSON.stringify(value);
                }
            }
        } else if (native.valueSubKey && native.valueSubKey !== 'value') {
            // We requested a sub value !== 'value' key but it is a plain value, so value requested not present
            value = undefined;
        }
        if (value === undefined) {
            adapter.log.debug(`Value not provided in answer for Smart-Home-Devices.${deviceEntityId}.${stateName}`);
            return null;
        }
        if (native.valueTrue && native.valueTrue === value) {
            value = true;
        } else if (native.valueFalse && native.valueFalse === value) {
            value = false;
        } else if (native.valueTrue && !native.valueFalse && native.valueTrue !== value) {
            value = false;
        } else if (native.valueFalse && !native.valueTrue && native.valueFalse !== value) {
            value = true;
        } else if (native.valueMap && Array.isArray(native.valueMap) && native.valueMap.length) {
            adapter.log.debug(`Get Index for value "${cap.namespace}.${cap.value}" for Smart-Home-Devices.${deviceEntityId}.${stateName}, value=${value} of ${JSON.stringify(native.valueMap)}`);
            value = native.valueMap.indexOf(value);
            if (value === -1) return null;
        }
        if (typeof value !== common.type && common.type !== 'mixed') {
            if (common.type === 'number') {
                const convertedValue = parseFloat(value);
                if (!isNaN(convertedValue)) {
                    value = convertedValue;
                }
            } else if (common.type === 'boolean') {
                value = !!value;
            }
        }
        value = {
            val: value,
            ack: true
        };
        if (cap.timeOfSample) value.ts = new Date(cap.timeOfSample).getTime();
        adapter.setState(`Smart-Home-Devices.${deviceEntityId}.${stateName}`, value);
        shDeviceParamValues[`Smart-Home-Devices.${deviceEntityId}.${stateName}`] = value.val;
        return value.val;
    }

    if (!res) return;
    if (res && res.errors && res.errors.length === 1 && res.errors[0] && res.errors[0].code) {
        if (!res.deviceStates || res.deviceStates.length === 0) {
            adapter.setState('requestResult', res.errors[0].code, true);
        }
    }
    if (res.deviceStates) {
        for (const states of res.deviceStates) {
            if (!states.entity || !states.entity.entityId) continue;
            const inputEntityId = states.entity.entityId;
            let mainApplianceId;
            if (shApplianceEntityMap[inputEntityId]) { // ID is a "main appliance id"
                mainApplianceId = inputEntityId;
            } else if (shMergedApplianceIdMap[inputEntityId]) { // ID is a "merged appliance id"
                mainApplianceId = shMergedApplianceIdMap[inputEntityId];
            } else if (shEntityApplianceMap[inputEntityId]) { // ID is an "entity id"
                mainApplianceId = shEntityApplianceMap[inputEntityId];
            }
            if (!mainApplianceId) {
                adapter.log.debug(`No main appliance id found for ${inputEntityId}`);
                continue;
            }

            const deviceEntityId = shApplianceEntityMap[mainApplianceId].entityId;
            if (deviceEntityId && states.capabilityStates) {
                let colorDataIncluded = false;
                const capValues = {};
                for (let cap of states.capabilityStates) {
                    try {
                        cap = JSON.parse(cap);
                    }
                    catch (e) {
                        adapter.log.warn(e);
                        continue;
                    }
                    if (!shObjects.capabilityObjects[cap.namespace]) {
                        if (shObjects.capabilityObjects[cap.namespace] !== null) {
                            adapter.log.debug(`unsupported namespace "${cap.namespace}" for Smart-Home-Devices.${deviceEntityId}.${cap.name}`);
                        }
                        continue;
                    }
                    if (!shObjects.capabilityObjects[cap.namespace][cap.name]) {
                        adapter.log.debug(`unsupported name "${cap.namespace}.${cap.name}" for Smart-Home-Devices.${deviceEntityId}.${cap.name}`);
                        continue;
                    }
                    for (const obj of shObjects.capabilityObjects[cap.namespace][cap.name]) {
                        if (typeof obj === 'string') { // Redirect!!
                            capValues[obj] = handleObject(deviceEntityId, cap, obj);
                            adapter.log.debug(`${cap.namespace}.${cap.value}: setValueFor=${obj} to ${capValues[obj]}`);
                        }
                        else {
                            let name = obj.common.name;
                            if (cap.instance) {
                                name = `${cap.instance.replace(/\./g, '-')}-${name}`;
                            }
                            let val = handleObject(deviceEntityId, cap, name);
                            if (val === null && cap.instance && !adapterObjects[`Smart-Home-Devices.${deviceEntityId}.${name}`] && adapterObjects[`Smart-Home-Devices.${deviceEntityId}.${obj.common.name}`]) {
                                // seems Amazon provided invalid details about cap.instance, try fallback
                                val = handleObject(deviceEntityId, cap, obj.common.name);
                                name = obj.common.name;
                            }
                            capValues[name] = val;
                        }
                    }
                    if (cap.namespace === 'Alexa.ColorController') {
                        if (capValues['color-hue'] !== null && capValues['color-saturation'] !== null && capValues['color-brightness'] !== null) {
                            const colorRgb = hsvToRgb(capValues['color-hue'], capValues['color-saturation'], capValues['color-brightness']);
                            adapter.setState(`Smart-Home-Devices.${deviceEntityId}.colorRgb`, colorRgb, true);
                            shDeviceParamValues[`Smart-Home-Devices.${deviceEntityId}.colorRgb`] = colorRgb;
                            capValues.colorRgb = colorRgb;
                            colorDataIncluded = true;
                        }
                    }
                }
                if (colorDataIncluded && capValues.colorRgb && capValues.colorName === null) {
                    const colorRgbSearch = hsvToRgb(capValues['color-hue'], capValues['color-saturation'], 1.0);
                    const nearestColor = shObjects.nearestColor(colorRgbSearch);
                    const native = adapterObjects[`Smart-Home-Devices.${deviceEntityId}.colorName`].native;
                    const value = native.valueMap.indexOf(nearestColor.name);
                    adapter.log.debug(`find nearest color for ${colorRgbSearch} (${capValues.colorRgb}): index=${value} / ${JSON.stringify(nearestColor)}`);
                    if (value !== -1) {
                        adapter.setState(`Smart-Home-Devices.${deviceEntityId}.colorName`, value, true);
                        shDeviceParamValues[`Smart-Home-Devices.${deviceEntityId}.colorName`] = value;
                        capValues.colorName = value;
                    }
                }
            }
        }
    }
    if (res.errors) {
        for (const states of res.errors) {
            if (!states.entity || !states.entity.entityId || !shApplianceEntityMap[states.entity.entityId]) continue;
            const deviceEntityId = shApplianceEntityMap[states.entity.entityId].entityId;
            if (states.code === 'ENDPOINT_UNREACHABLE' && adapterObjects[`Smart-Home-Devices.${deviceEntityId}.connectivity`]) {
                adapter.setState(`Smart-Home-Devices.${deviceEntityId}.connectivity`, false, true);
                adapter.log.debug(`Set Connectivity for ${deviceEntityId} to false because ${states.code}`);
            }
        }
    }
}

function getCachedSmarthomeDevices(callback) {
    const cachedDevicesFilename = path.join(__dirname, `cachedDevices.${adapter.namespace}.json`);

    function getCachedDeviceList(ignoreTimestamp) {
        try {
            if (fs.existsSync(cachedDevicesFilename)) {
                const stats = fs.statSync(cachedDevicesFilename);
                if (ignoreTimestamp || stats.mtime.getTime() + 30 * 60 * 1000 > Date.now()) {
                    const cachedDevices = JSON.parse(fs.readFileSync(cachedDevicesFilename, 'utf8'));
                    adapter.log.info(`Using cached smart home devices list from ${stats.mtime}`);
                    adapter.log.debug(JSON.stringify(cachedDevices));
                    return cachedDevices;
                }
            }
        } catch (err) {
            adapter.log.info('Could not cache devices: ' + err.message);
        }
        return null;
    }
    const cachedDeviceList = getCachedDeviceList();
    if (cachedDeviceList) {
        callback(null, cachedDeviceList);
        return;
    }

    alexa.getSmarthomeDevices((err, res) => {
        if (!err && res && res.locationDetails && res.locationDetails.Default_Location) {
            try {
                fs.writeFileSync(cachedDevicesFilename, JSON.stringify(res));
            } catch (err) {
                adapter.log.info('Could not cache devices: ' + err.message);
            }
        }
        if (err || !res || !res.locationDetails || !res.locationDetails.Default_Location) {
            res = getCachedDeviceList(true);
            if (res) {
                err = null;
                adapter.log.info('Could not get smart home devices from Amazon. Using cached list.');
            }
        }
        callback(err, res);
    });
}

function checkSmartHomeControlParameters(parameterId, value) {
    let counter = 1;
    const now = Date.now();
    if (shDeviceParamControlValues[parameterId]) {
        if (shDeviceParamControlValues[parameterId].ts > now - 300000) {
            if (shDeviceParamControlValues[parameterId].value == value && typeof shDeviceParamControlValues[parameterId].value !== 'boolean') {
                adapter.log.info(`Ignore update of ${parameterId} because it was set to the same value in last 5min`);
                return false;
            }
            if (typeof shDeviceParamControlValues[parameterId].value === 'number') {
                const difference = Math.abs(shDeviceParamControlValues[parameterId].value - value);
                if (difference < 0.5) {
                    adapter.log.info(`Ignore update of ${parameterId} because value only changed ${difference.toFixed(2)} since last set within 5min`);
                    return false;
                }
            }
        }
        if (shDeviceParamControlValues[parameterId].ts > now - 600000) {
            counter = ++shDeviceParamControlValues[parameterId].counter;
            if (counter > 4) {
                adapter.log.info(`Ignore update of ${parameterId} because it was set too often in the last time (${counter})`);
                return false;
            }
        }
    }
    shDeviceParamControlValues[parameterId] = {
        value,
        ts: now,
        counter
    };
    return true;
}

function createSmarthomeStates(callback) {
    if (!adapter.config.synchronizeSmartHomeDevices) {
        return callback && callback();
    }

    // TODO alexa.getSmarthomeGroups nutzen

    adapter.getStates('Smart-Home-Devices.*.#includeInAllQuery', (err, states) => {
        const shQueryEnabledEntities = {};
        if (!err && states) {
            Object.keys(states).forEach(id => {
                if (!states[id]) return;
                const entityId = id.replace(new RegExp(`^${adapter.namespace}.Smart-Home-Devices.`), '').replace(/\.#includeInAllQuery$/, '');
                shQueryEnabledEntities[entityId] = !!states[id].val;
                adapter.log.debug(`${id} for ${entityId} is ${shQueryEnabledEntities[entityId] ? 'enabled' : 'disabled'}`);
            });
        }
        alexa.getSmarthomeBehaviourActionDefinitions((err, resProperties) => {
            if (stopped) return;
            if (!err && resProperties) shObjects.patchProperties(resProperties);

            getCachedSmarthomeDevices((err, res) => {
                if (stopped) return;
                setOrUpdateObject('Smart-Home-Devices', {type: 'folder', common: {name: 'Smart Home Devices'}});

                setOrUpdateObject('Smart-Home-Devices.deleteAll', {common: { type: 'boolean', read: false, write: true, role: 'button'}}, false, (val) => {
                    const cachedDevicesFilename = path.join(__dirname, `cachedDevices.${adapter.namespace}.json`);
                    try {
                        if (fs.existsSync(cachedDevicesFilename)) {
                            fs.unlinkSync(cachedDevicesFilename);
                        }
                    } catch (err) {
                        adapter.log.info('Could not delete cached devices: ' + err.message);
                    }
                    alexa.deleteAllSmarthomeDevices((err, res) => {
                        adapter.deleteDevice('Smart-Home-Devices', () => {
                            setTimeout(createSmarthomeStates, 1000);
                        });
                    });
                });
                setOrUpdateObject('Smart-Home-Devices.discoverDevices', {common: {name: 'Let Alexa search for devices', type: 'boolean', read: false, write: true, role: 'button'}}, false, (val) => {
                    if (shDeviceDiscoveryTimeout) {
                        adapter.log.info('Discovery was executed too short ago, can not trigger it');
                        return;
                    }
                    const cachedDevicesFilename = path.join(__dirname, `cachedDevices.${adapter.namespace}.json`);
                    try {
                        if (fs.existsSync(cachedDevicesFilename)) {
                            fs.unlinkSync(cachedDevicesFilename);
                        }
                    } catch (err) {
                        adapter.log.info('Could not delete cached devices: ' + err.message);
                    }
                    shDeviceDiscoveryTimeout = setTimeout(() => shDeviceDiscoveryTimeout = null, 300000);
                    alexa.discoverSmarthomeDevice((err, res) => {
                        return createSmarthomeStates();
                    });
                });

                if (err || !res) {
                    return processObjectQueue(() => callback && callback(err));
                }

                alexa.getSmarthomeEntities((err, res2) => {
                    if (stopped) return;
                    const behaviours = {};
                    if (res2 && Array.isArray(res2)) {
                        res2.forEach((behaviour) => {
                            behaviours[behaviour.id] = behaviour;
                        });
                    }

                    let readableCounter = 0;
                    let all = {};
                    if (
                        res &&
                        res.locationDetails &&
                        res.locationDetails.Default_Location &&
                        res.locationDetails.Default_Location.amazonBridgeDetails &&
                        res.locationDetails.Default_Location.amazonBridgeDetails.amazonBridgeDetails
                    ) {
                        all = res.locationDetails.Default_Location.amazonBridgeDetails.amazonBridgeDetails;
                    }
                    for (const i of Object.keys(all)) {
                        for (const n of Object.keys(all[i].applianceDetails.applianceDetails)) {
                            const shDevice = all[i].applianceDetails.applianceDetails[n];
                            if (!shDevice.isEnabled) continue;
                            let friendlyName = shDevice.friendlyName;
                            shApplianceEntityMap[shDevice.applianceId] = {
                                entityId: shDevice.entityId,
                                readable: false,
                                cloudReadable: false,
                                mergedApplianceIds: shDevice.mergedApplianceIds,
                                supportedProperties: []
                            };
                            shEntityApplianceMap[shDevice.entityId] = shDevice.applianceId;
                            if (shDevice.mergedApplianceIds && Array.isArray(shDevice.mergedApplianceIds)) {
                                shDevice.mergedApplianceIds.forEach((applianceId) => {
                                    shMergedApplianceIdMap[applianceId] = shDevice.applianceId;
                                });
                            }
                            if (shDevice.aliases && shDevice.aliases[0] && shDevice.aliases[0].friendlyName) {
                                friendlyName = shDevice.aliases[0].friendlyName;
                            }
                            setOrUpdateObject(`Smart-Home-Devices.${shDevice.entityId}`, {
                                type: 'channel',
                                common: {
                                    name: friendlyName,
                                    role: 'channel'
                                },
                                native: {
                                    friendlyDescription: shDevice.friendlyDescription,
                                    friendlyName: friendlyName,
                                    modelName: shDevice.modelName,
                                    additionalApplianceIds:  shDevice.additionalApplianceDetails.additionalApplianceDetails.ids || null,
                                    object: n,
                                    manufacturerName: shDevice.manufacturerName,
                                }
                            });
                            setOrUpdateObject(`Smart-Home-Devices.${shDevice.entityId}.#enabled`, {common: {role: 'indicator', write: true}}, shDevice.isEnabled, function (val) {
                                alexa.setEnablementForSmarthomeDevice(n, val);
                            }.bind(alexa));
                            setOrUpdateObject(`Smart-Home-Devices.${shDevice.entityId}.#delete`, {common: { type: 'boolean', read: false, write: true, role: 'button'}}, false, function (entityId, val) {
                                alexa.deleteSmarthomeDevice(n);
                                adapter.deleteChannel('Smart-Home-Devices', entityId);
                            }.bind(alexa, shDevice.entityId));

                            const excludeReadable = shDevice.manufacturerName.startsWith('ioBroker') || shDevice.manufacturerName.startsWith('openHAB');
                            const deviceActions = {};
                            if (behaviours[shDevice.entityId] && behaviours[shDevice.entityId].supportedOperations) {
                                behaviours[shDevice.entityId].supportedOperations.forEach((a) => {
                                    deviceActions[a] = true;
                                });
                            }
                            if (shDevice.actions && shDevice.actions.length) {
                                shDevice.actions.forEach((a) => {
                                    deviceActions[a] = true;
                                });
                            }
                            const applianceDriverIdentity = shDevice.applianceDriverIdentity ? (shDevice.applianceDriverIdentity.identifier || '') : '';
                            let readableProperties = 0;
                            let capabilitiesReadable = null;
                            let capabilitiesCloudReadable = null;
                            if (shDevice.capabilities.length) {
                                for (const cap of shDevice.capabilities) {
                                    if (cap.interfaceName) {
                                        // For Scenes we add the action
                                        if ((!cap.properties || !cap.properties.supported) && cap.interfaceName === 'Alexa.SceneController') {
                                            cap.properties = {
                                                'supported': [{
                                                    'name': 'active'
                                                }]
                                            };
                                        } else if (!cap.properties || !cap.properties.supported || !cap.properties.supported.length) {
                                            continue;
                                        } else if (!cap.properties.retrievable) {
                                            capabilitiesReadable = capabilitiesReadable || false;
                                            if (!(cap.properties.proactivelyReported && applianceDriverIdentity === 'SonarCloudService' && !!shDevice.connectedVia && !shDevice.applianceId.startsWith('SKILL_'))) {
                                                continue;
                                            }
                                        }
                                        capabilitiesCloudReadable = capabilitiesCloudReadable || cap.properties.proactivelyReported;
                                        if (!shObjects.capabilityObjects[cap.interfaceName]) {
                                            if (shObjects.capabilityObjects[cap.interfaceName] !== null) {
                                                adapter.log.debug(`Smarthome-Device Capability ${cap.interfaceName} unknown. Report to developer this and next log line from logfile on disk!`);
                                                adapter.log.debug(`${JSON.stringify(shDevice)} / ${JSON.stringify(behaviours[shDevice.entityId])}`);
                                            }
                                            continue;
                                        }

                                        for (const capProp of cap.properties.supported) {
                                            if (!shObjects.capabilityObjects[cap.interfaceName][capProp.name]) {
                                                adapter.log.debug(`Smarthome-Device Capability ${cap.interfaceName} for ${capProp.name} unknown. Report to developer this and next log line from logfile on disk!`);
                                                adapter.log.debug(`${JSON.stringify(shDevice)} / ${JSON.stringify(behaviours[shDevice.entityId])}`);
                                                continue;
                                            }

                                            let propertyToQuery = false;
                                            for (let obj of shObjects.capabilityObjects[cap.interfaceName][capProp.name]) {
                                                if (typeof obj === 'string') continue;
                                                obj = JSON.parse(JSON.stringify(obj));
                                                if (obj.experimental) {
                                                    adapter.log.debug(`Smarthome-Device Capability ${cap.interfaceName} for ${capProp.name}.${obj.common.name} experimentally supported. Please check and report to developer this and next log line from logfile on disk if it works!!`);
                                                    adapter.log.debug(`${JSON.stringify(shDevice)} / ${JSON.stringify(`${behaviours[shDevice.entityId]} / ${JSON.stringify(obj)}`)}`);
                                                }
                                                if (obj.experimental) delete obj.experimental;
                                                if (obj.common && obj.common.read) {
                                                    if (!excludeReadable && (cap.properties.retrievable || (!cap.properties.retrievable && cap.properties.proactivelyReported && applianceDriverIdentity === 'SonarCloudService' && !!shDevice.connectedVia && !shDevice.applianceId.startsWith('SKILL_'))) ) {
                                                        readableProperties++;
                                                        propertyToQuery = true;
                                                    }
                                                    else {
                                                        obj.common.read = false;
                                                    }
                                                }

                                                const origName = obj.common.name;
                                                if (cap.instance) {
                                                    if (!obj.native.paramName) {
                                                        obj.native.paramName = obj.common.name;
                                                    }
                                                    obj.common.name = `${cap.instance.replace(/\./g, '-')}-${obj.common.name}`;
                                                }

                                                if (cap.configuration) {
                                                    obj = shObjects.configureCapabilityObject(cap, obj);
                                                }

                                                if (obj.native.supportedActions && obj.native.supportedActions.length) {
                                                    obj.native.supportedActions.forEach((n) => {
                                                        if (deviceActions[n] !== undefined) delete deviceActions[n];
                                                        if (cap.instance && deviceActions[`${n}@${shDevice.entityId}_${cap.instance}`] !== undefined) delete deviceActions[`${n}@${shDevice.entityId}_${cap.instance}`];
                                                    });
                                                }

                                                setOrUpdateObject(`Smart-Home-Devices.${shDevice.entityId}.${obj.common.name}`, obj, undefined, function (entityId, paramName, applianceId, value) {
                                                    if (!obj.common.write) return;
                                                    const parameters = buildSmartHomeControlParameters(entityId, shObjects.capabilityObjects[cap.interfaceName], capProp.name, paramName, value, cap.instance);
                                                    let actionName = parameters.action;
                                                    if (cap.instance) {
                                                        if (actionName === 'turnOffToggle') {
                                                            actionName = `turnOff@${shDevice.entityId}_${cap.instance}`;
                                                        } else if (actionName === 'turnOnToggle') {
                                                            actionName = `turnOn@${shDevice.entityId}_${cap.instance}`;
                                                        } else {
                                                            actionName = `${actionName}@${shDevice.entityId}_${cap.instance}`;
                                                        }
                                                    }
                                                    if (!parameters.action || !behaviours[entityId] || ! behaviours[entityId].supportedOperations || !behaviours[entityId].supportedOperations.includes(actionName)) {
                                                        if (parameters.action && !parameters.action.startsWith('turn') && !parameters.action.startsWith('scene')) {
                                                            adapter.log.debug(`Invalid action ${parameters.action} provided for Capability ${cap.interfaceName} for ${obj.common.name}. Report to developer this and next log line from logfile on disk!`);
                                                            adapter.log.debug(`${JSON.stringify(shDevice)} / ${JSON.stringify(behaviours[entityId])}`);
                                                        }
                                                        else {
                                                            adapter.log.debug(`Action ${actionName} provided for Capability ${cap.interfaceName} for ${obj.common.name} is not supported, ignore`);
                                                        }
                                                        return;
                                                    }

                                                    if (!checkSmartHomeControlParameters(`${entityId}.${obj.common.name}`, value)) return;

                                                    alexa.executeSmarthomeDeviceAction(entityId, parameters, (err, res) => {
                                                        if (!err && res && res.controlResponses && res.controlResponses[0] && res.controlResponses[0].code && res.controlResponses[0].code === 'SUCCESS' && !excludeReadable) {
                                                            if (shQueryBlocker[applianceId]) {
                                                                clearTimeout(shQueryBlocker[applianceId]);
                                                                shQueryBlocker[applianceId] = null;
                                                            }
                                                            if (shDeviceRefreshTimeoutAfterControl[applianceId]) {
                                                                clearTimeout(shDeviceRefreshTimeoutAfterControl[applianceId]);
                                                                shDeviceRefreshTimeoutAfterControl[applianceId] = null;
                                                            }
                                                            shDeviceRefreshTimeoutAfterControl[applianceId] = setTimeout(() => {
                                                                shDeviceRefreshTimeoutAfterControl[applianceId] = null;

                                                                if (shQueryBlocker[applianceId]) {
                                                                    clearTimeout(shQueryBlocker[applianceId]);
                                                                    shQueryBlocker[applianceId] = null;
                                                                }
                                                                /**
                                                                 * Please do not change these delay, else Amazon might block the smart home device state query function
                                                                 * for all >20k Adapter users!
                                                                 */
                                                                let delay = 900000;
                                                                if (!applianceId.startsWith('SKILL_') || shApplianceEntityMap[applianceId].cloudReadable) delay = 600000;
                                                                shQueryBlocker[applianceId] = setTimeout(() => {
                                                                    shQueryBlocker[applianceId] = null;
                                                                }, delay);

                                                                alexa.querySmarthomeDevices(generateApplianceQueryArray(applianceId, true), (err, res) => {
                                                                    if (!err) {
                                                                        updateSmarthomeDeviceStates(res);
                                                                    }
                                                                });
                                                            }, 2000);
                                                        }
                                                        else {
                                                            updateSmarthomeDeviceStates(res);
                                                        }
                                                    });
                                                }.bind(alexa, shDevice.entityId, origName, shDevice.applianceId));

                                                if (shDevice.tags && shDevice.tags.tagNameToValueSetMap && shDevice.tags.tagNameToValueSetMap.groupIdentity) {
                                                    for (const group of shDevice.tags.tagNameToValueSetMap.groupIdentity) {
                                                        shGroupDetails[group] = shGroupDetails[group] || {
                                                            applianceIds: {},
                                                            entityIds: {},
                                                            parameters: {}
                                                        };
                                                        shGroupDetails[group].applianceIds[shDevice.applianceId] = true;
                                                        shGroupDetails[group].entityIds[shDevice.entityId] = true;
                                                        shGroupDetails[group].parameters[obj.common.name] = obj;
                                                    }
                                                }
                                            }
                                            if (propertyToQuery) {
                                                shApplianceEntityMap[shDevice.applianceId].supportedProperties.push({
                                                    namespace: cap.interfaceName,
                                                    name: capProp.name,
                                                    instance: cap.instance // ???
                                                });
                                            }
                                        }
                                    }
                                }
                            }
                            const deviceActionsArr = Object.keys(deviceActions);
                            if (deviceActionsArr.length) {
                                let readable = false;
                                if (!excludeReadable) {
                                    for (const action of deviceActionsArr) {
                                        if (action.startsWith('get') || action.startsWith('retrieve')) {
                                            readable = true;
                                            readableProperties++;
                                        }
                                    }
                                }

                                let ignoreSecondTurnOnOff = false;
                                for (let action of deviceActionsArr) {
                                    if (ignoreSecondTurnOnOff && (action === 'turnOn' || action === 'turnOff')) continue;
                                    if ((action === 'turnOn' && deviceActionsArr.includes('turnOff')) || (action === 'turnOff' && deviceActionsArr.includes('turnOn'))) {
                                        action = 'turnOnOff';
                                        ignoreSecondTurnOnOff = true;
                                    }
                                    if (!shObjects.actionObjects[action]) {
                                        if (!action.includes('@')) {
                                            adapter.log.debug(`Smarthome-Device Action ${action} unknown. Report to developer this and next log line from logfile on disk!`);
                                            adapter.log.debug(`${JSON.stringify(shDevice)} / ${JSON.stringify(behaviours[shDevice.entityId])}`);
                                        }
                                        continue;
                                    }
                                    for (let obj of shObjects.actionObjects[action]) {
                                        if (typeof obj === 'string') continue;
                                        obj = JSON.parse(JSON.stringify(obj));
                                        if (obj.experimental) {
                                            adapter.log.debug(`Smarthome-Device Action ${action}.${obj.common.name} experimentally supported. Please check and report to developer this and next log line from logfile on disk if it works!!`);
                                            adapter.log.debug(`${JSON.stringify(shDevice)} / ${JSON.stringify(behaviours[shDevice.entityId])} / ${JSON.stringify(obj)}`);
                                        }
                                        if (obj.experimental) delete obj.experimental;
                                        if (obj.common && obj.common.read && excludeReadable) {
                                            obj.common.read = false;
                                        }
                                        if (obj.native.supportedActions && obj.native.supportedActions.length) {
                                            obj.native.supportedActions.forEach((n) => {
                                                if (deviceActions[n] !== undefined) delete deviceActions[n];
                                            });
                                        }
                                        if (
                                            (action === 'turnOn') ||
                                            (action === 'sceneActivate' && behaviours[shDevice.entityId] && behaviours[shDevice.entityId].supportedOperations && !behaviours[shDevice.entityId].supportedOperations.includes('sceneDeactivate'))
                                        ) {
                                            obj.common.role = 'button';
                                            obj.common.read = false;
                                        }
                                        obj.native.readable = readable;

                                        setOrUpdateObject(`Smart-Home-Devices.${shDevice.entityId}.${obj.common.name}`, obj, undefined, function (entityId, paramName, applianceId, value) {
                                            if (!obj.common.write) return;
                                            const origValue = value;
                                            const parameters = buildSmartHomeControlParameters(shDevice.entityId, shObjects.actionObjects[action], null, paramName, value);

                                            if (!behaviours[entityId] || !behaviours[entityId].supportedOperations || !behaviours[entityId].supportedOperations.includes(parameters.action)) {
                                                if (!parameters.action.startsWith('turn') && !parameters.action.startsWith('scene')) {
                                                    adapter.log.debug(`Invalid action ${parameters.action} provided for Action ${action}. Report to developer this and next log line from logfile on disk!`);
                                                    adapter.log.debug(`${JSON.stringify(shDevice)} / ${JSON.stringify(behaviours[entityId])}`);
                                                }
                                                else {
                                                    adapter.log.debug(`Action ${parameters.action} provided for Action ${action} for ${obj.common.name} is not supported, ignore`);
                                                }
                                                return;
                                            }

                                            if (!checkSmartHomeControlParameters(`${entityId}.${obj.common.name}`, value)) return;

                                            alexa.executeSmarthomeDeviceAction(entityId, parameters, (err, res) => {
                                                if (!err && res && res.controlResponses && res.controlResponses[0] && res.controlResponses[0].code && res.controlResponses[0].code === 'SUCCESS') {
                                                    if (obj.native.readable) {
                                                        if (shQueryBlocker[applianceId]) {
                                                            clearTimeout(shQueryBlocker[applianceId]);
                                                            shQueryBlocker[applianceId] = null;
                                                        }
                                                        if (shDeviceRefreshTimeoutAfterControl[applianceId]) {
                                                            clearTimeout(shDeviceRefreshTimeoutAfterControl[applianceId]);
                                                            shDeviceRefreshTimeoutAfterControl[applianceId] = null;
                                                        }
                                                        shDeviceRefreshTimeoutAfterControl[applianceId] = setTimeout(() => {
                                                            shDeviceRefreshTimeoutAfterControl[applianceId] = null;

                                                            if (shQueryBlocker[applianceId]) {
                                                                clearTimeout(shQueryBlocker[applianceId]);
                                                                shQueryBlocker[applianceId] = null;
                                                            }
                                                            /**
                                                             * Please do not change these delay, else Amazon might block the smart home device state query function
                                                             * for all >20k Adapter users!
                                                             */
                                                            let delay = 900000;
                                                            if (!applianceId.startsWith('SKILL_') || shApplianceEntityMap[applianceId].cloudReadable) delay = 600000;
                                                            shQueryBlocker[applianceId] = setTimeout(() => {
                                                                shQueryBlocker[applianceId] = null;
                                                            }, delay);

                                                            alexa.querySmarthomeDevices(generateApplianceQueryArray(applianceId, true), (err, res) => {
                                                                if (!err) {
                                                                    updateSmarthomeDeviceStates(res);
                                                                }
                                                            });
                                                        }, 2000);
                                                    }
                                                    else {
                                                        adapter.setState(`Smart-Home-Devices.${shDevice.entityId}.${obj.common.name}`, origValue, true);
                                                    }
                                                }
                                                else {
                                                    updateSmarthomeDeviceStates(res);
                                                }
                                            });
                                        }.bind(alexa, shDevice.entityId, obj.common.name, shDevice.applianceId));

                                        if (shDevice.tags && shDevice.tags.tagNameToValueSetMap && shDevice.tags.tagNameToValueSetMap.groupIdentity) {
                                            for (const group of shDevice.tags.tagNameToValueSetMap.groupIdentity) {
                                                shGroupDetails[group] = shGroupDetails[group] || {
                                                    applianceIds: {},
                                                    entityIds: {},
                                                    parameters: {}
                                                };
                                                shGroupDetails[group].applianceIds[shDevice.applianceId] = true;
                                                shGroupDetails[group].entityIds[shDevice.entityId] = true;
                                                shGroupDetails[group].parameters[obj.common.name] = obj;
                                            }
                                        }
                                    }
                                }
                            }
                            if (readableProperties > 0 && !excludeReadable) {
                                shApplianceEntityMap[shDevice.applianceId].readable = true;
                                shApplianceEntityMap[shDevice.applianceId].cloudReadable = capabilitiesCloudReadable;
                                adapter.log.debug(`Smarthome-Device ${shDevice.entityId} is readable / cloud readable (${capabilitiesCloudReadable})`);
                                readableCounter++;
                                setOrUpdateObject(`Smart-Home-Devices.${shDevice.entityId}.#query`, {common: {type: 'boolean', read: false, write: true, role: 'button'}}, false, function (applianceId, value) {
                                    if (shQueryBlocker[applianceId]) {
                                        adapter.log.warn(`Smart Home device request blocked for ${applianceId}`);
                                        return;
                                    }
                                    /**
                                     * Please do not change these delay, else Amazon might block the smart home device state query function
                                     * for all >20k Adapter users!
                                     */
                                    let delay = 900000;
                                    if (!applianceId.startsWith('SKILL_') || shApplianceEntityMap[applianceId].cloudReadable) delay = 600000;
                                    shQueryBlocker[applianceId] = setTimeout(() => {
                                        shQueryBlocker[applianceId] = null;
                                    }, delay);
                                    alexa.querySmarthomeDevices(generateApplianceQueryArray(applianceId, true), (err, res) => {
                                        if (!err) {
                                            updateSmarthomeDeviceStates(res);
                                        }
                                    });
                                }.bind(alexa, shDevice.applianceId));
                                shQueryEnabled[shDevice.applianceId] = !!shQueryEnabledEntities[shDevice.entityId];
                                adapter.log.debug(`Smarthome-Device ${shDevice.applianceId} is query enabled (${shQueryEnabled[shDevice.applianceId]})`);
                                setOrUpdateObject(`Smart-Home-Devices.${shDevice.entityId}.#includeInAllQuery`, {common: {type: 'boolean', read: true, write: true, role: 'switch', def: false}}, undefined, function (applianceId, value) {
                                    shQueryEnabled[applianceId] = !!value;
                                    adapter.setState(`Smart-Home-Devices.${shDevice.entityId}.#includeInAllQuery`, !!value, true);
                                }.bind(alexa, shDevice.applianceId));
                            }
                        }
                    }
                    let allGroups = {};
                    if (
                        res &&
                        res.locationDetails &&
                        res.locationDetails.Default_Location &&
                        res.locationDetails.Default_Location.applianceGroups &&
                        res.locationDetails.Default_Location.applianceGroups.applianceGroups
                    ) {
                        allGroups = res.locationDetails.Default_Location.applianceGroups.applianceGroups;
                    }
                    for (const i of Object.keys(allGroups)) {
                        /*
                        "amzn1.HomeAutomation.ApplianceGroup.A3NSX4MMJVG96V.550a4bf5-4852-4a35-81c4-b3568b222033": {
                            "applianceGroupName": "Lichter Küche",
                            "applianceGroupIdentifier": {
                                "value": "amzn1.HomeAutomation.ApplianceGroup.A3NSX4MMJVG96V.550a4bf5-4852-4a35-81c4-b3568b222033"
                            },
                            "spaceTypes": [],
                            "children": [],
                            "alexaEndpoints": [],
                            "defaults": []
                        }
                        */
                        const groupData = allGroups[i];
                        const friendlyName = groupData.applianceGroupName;
                        const groupParamData = shGroupDetails[groupData.applianceGroupIdentifier.value];
                        if (!groupParamData) continue;
                        const groupIdShort = i.substr(i.lastIndexOf('.') + 1);
                        setOrUpdateObject(`Smart-Home-Devices.${groupIdShort}`, {
                            type: 'channel',
                            common: {
                                name: `Gruppe ${friendlyName}`,
                                role: 'channel'
                            },
                            native: {
                                friendlyName: friendlyName,
                                ids:  groupData.applianceGroupIdentifier.value,
                                object: groupData
                            }
                        });
                        setOrUpdateObject(`Smart-Home-Devices.${groupIdShort}.#delete`, {common: { type: 'boolean', read: false, write: true, role: 'button'}}, false, function (entityId, val) {
                            alexa.deleteSmarthomeGroup(entityId);
                            adapter.deleteChannel('Smart-Home-Devices', groupIdShort);
                        }.bind(alexa, i));

                        for (const param of Object.keys(groupParamData.parameters)) {
                            const obj = groupParamData.parameters[param];
                            if (obj.native && obj.native.hideInGroups) continue;
                            //obj.common.read = false;
                            setOrUpdateObject(`Smart-Home-Devices.${groupIdShort}.${obj.common.name}`, obj, undefined, function (entityId, paramName, applianceId, value) {
                                if (!obj.common.write) return;
                                const parameters = buildSmartHomeControlParameters(entityId, obj, null, paramName, value);

                                if (!behaviours[groupIdShort] || ! behaviours[groupIdShort].supportedOperations || !behaviours[groupIdShort].supportedOperations.includes(parameters.action)) {
                                    adapter.log.debug(`Invalid action ${parameters.action} provided for Group-Action ${parameters.action}. Report to developer this and next log line from logfile on disk!`);
                                    adapter.log.debug(`${JSON.stringify(groupData)} / ${JSON.stringify(behaviours[groupIdShort])}`);
                                    return;
                                }

                                if (!checkSmartHomeControlParameters(`${groupIdShort}.${obj.common.name}`, value)) return;

                                alexa.executeSmarthomeDeviceAction(groupIdShort, parameters, 'GROUP', (err, res) => {
                                    if (!err && res && res.controlResponses && res.controlResponses[0] && res.controlResponses[0].code && res.controlResponses[0].code === 'SUCCESS') {
                                        if (obj.native.readable) {
                                            if (shQueryBlocker[applianceId]) {
                                                clearTimeout(shQueryBlocker[applianceId]);
                                                shQueryBlocker[applianceId] = null;
                                            }
                                            if (shDeviceRefreshTimeoutAfterControl[applianceId]) {
                                                clearTimeout(shDeviceRefreshTimeoutAfterControl[applianceId]);
                                                shDeviceRefreshTimeoutAfterControl[applianceId] = null;
                                            }
                                            shDeviceRefreshTimeoutAfterControl[applianceId] = setTimeout(() => {
                                                shDeviceRefreshTimeoutAfterControl[applianceId] = null;

                                                if (shQueryBlocker[applianceId]) {
                                                    clearTimeout(shQueryBlocker[applianceId]);
                                                    shQueryBlocker[applianceId] = null;
                                                }
                                                /**
                                                 * Please do not change these delay, else Amazon might block the smart home device state query function
                                                 * for all >20k Adapter users!
                                                 */
                                                let delay = 900000;
                                                if (!applianceId.startsWith('SKILL_') || shApplianceEntityMap[applianceId].cloudReadable) delay = 600000;
                                                shQueryBlocker[applianceId] = setTimeout(() => {
                                                    shQueryBlocker[applianceId] = null;
                                                }, delay);
                                                alexa.querySmarthomeDevices(generateApplianceQueryArray(applianceId, true), (err, res) => {
                                                    if (!err) {
                                                        updateSmarthomeDeviceStates(res);
                                                    }
                                                });
                                            }, 2000);
                                        }
                                    }
                                    else {
                                        updateSmarthomeDeviceStates(res);
                                    }
                                });
                            }.bind(alexa, Object.keys(groupParamData.entityIds), obj.common.name, Object.keys(groupParamData.applianceIds)));

                        }
                    }
                    if (readableCounter) {
                        setOrUpdateObject('Smart-Home-Devices.queryAll', {common: { type: 'boolean', read: false, write: true, role: 'button'}}, false, (val) => {
                            queryAllSmartHomeDevices(false, false);
                        });
                    }
                    processObjectQueue(callback);
                });
            });
        });
    });
}

function scheduleHistoryUpdate(delay) {
    if (delay === undefined) {
        if (adapter.config.updateStateInterval === 0) return;
        delay = adapter.config.updateHistoryInterval * 1000;
    }
    if (updateHistoryTimer) {
        clearTimeout(updateHistoryTimer);
    }
    if (pushConnected) return;
    if (stopped) return;
    delay = Math.max(delay, 60000);
    updateHistoryTimer = setTimeout(() => {
        updateHistoryTimer = null;
        if (stopped) return;
        updateHistory();
    }, delay);
}

function updateHistory(callback) {
    if (updateHistoryTimer) {
        clearTimeout(updateHistoryTimer);
        updateHistoryTimer = null;
    }
    if (stopped) return;
    alexa.getCustomerHistoryRecords({maxRecordSize: 3, filter: true, startTime: Date.now() - 60000}, (err, res) => {
        if (stopped) return;
        if (err || !res || !Array.isArray(res)) {
            if (adapter.config.updateHistoryInterval > 0) {
                scheduleHistoryUpdate();
            }
            return callback && callback();
        }

        adapter.getState('History.creationTime', (err, state) => {
            if (err || !state) {
                if (adapter.config.updateHistoryInterval > 0) {
                    scheduleHistoryUpdate();
                }
                return callback && callback();
            }

            let last = state.val;
            let i = res.length - 1;
            (function doIt() {
                if (i < 0) {
                    if (adapter.config.updateHistoryInterval > 0) {
                        scheduleHistoryUpdate();
                    }
                    return callback && callback();
                }

                const o = res[i--];
                if (last >= o.creationTimestamp) return doIt();

                updateHistoryStates(o);
                last = o.creationTimestamp;

                doIt();
            })();
        });
    });
}

/*
activityCardContent - > activity.domainAttributes.card.content
activityCard - > JSON.stringify(activity.domainAttributes.card)
*/

function updateHistoryStates(o) {
    if (adapter.config.historyIgnoreEmptySummary && !o.description.summary.length && !o.alexaResponse) {
        adapter.log.debug(`Ignore History entry because configured: ${JSON.stringify(o)}`);
        return;
    }

    adapter.setState('History.name', o.name, true);
    adapter.setState('History.serialNumber', o.deviceSerialNumber, true);
    adapter.setState('History.summary', o.description.summary || '', true);
    o.activityStatus !== undefined && adapter.setState('History.status', o.activityStatus, true);
    adapter.setState('History.creationTime', o.creationTimestamp, true);

    const jsonHistory = {
        name: o.name,
        serialNumber: o.deviceSerialNumber,
        summary: o.description.summary,
        creationTime: o.creationTimestamp,
        status: o.activityStatus,
        domainApplicationId: '',
        domainApplicationName: o.data.skillName,
        cardContent: '',
        card: '',
        answerText: o.alexaResponse || '',
        utteranceType: o.data.utteranceType,
        domain: o.data.domain,
        intent: o.data.intent
    };

    if (o.domainAttributes) { // deprecated
        if (o.domainAttributes.applicationMetadata) {
            adapter.setState('History.domainApplicationId', o.domainAttributes.applicationMetadata.applicationId || '', true);
            jsonHistory.domainApplicationId = o.domainAttributes.applicationMetadata.applicationId || '';
            adapter.setState('History.domainApplicationName', o.domainAttributes.applicationMetadata.applicationName || '', true);
            jsonHistory.domainApplicationName = o.domainAttributes.applicationMetadata.applicationName;
        }
        else {
            adapter.setState('History.domainApplicationId', '', true);
            adapter.setState('History.domainApplicationName', '', true);
        }
        if (o.domainAttributes.card) {
            adapter.setState('History.cardContent', o.domainAttributes.card.content || '', true);
            jsonHistory.cardContent = o.domainAttributes.card.content || '';
            adapter.setState('History.cardJson', JSON.stringify(o.domainAttributes.card), true);
            jsonHistory.card = o.domainAttributes.card;
        }
        else {
            adapter.setState('History.cardContent', '', true);
            adapter.setState('History.cardJson', '', true);
        }
        if (o.domainAttributes.nBestList && o.domainAttributes.nBestList[0]) {
            adapter.setState('History.answerText', o.domainAttributes.nBestList[0].answerText || o.domainAttributes.nBestList[0].text || '', true);
            jsonHistory.answerText = o.domainAttributes.nBestList[0].answerText;
        }
        else {
            adapter.setState('History.answerText', '', true);
        }
    }
    else {
        adapter.setState('History.domainApplicationId', jsonHistory.domainApplicationId, true);
        adapter.setState('History.domainApplicationName', jsonHistory.domainApplicationName, true);
        adapter.setState('History.cardContent', jsonHistory.cardContent, true);
        adapter.setState('History.cardJson', JSON.stringify(jsonHistory.card), true);
        adapter.setState('History.answerText', jsonHistory.answerText, true);
        adapter.setState('History.utteranceType', jsonHistory.utteranceType, true);
        adapter.setState('History.domain', jsonHistory.domain, true);
        adapter.setState('History.intent', jsonHistory.intent, true);

        if (jsonHistory.domain === 'Global' && jsonHistory.intent === 'StopIntent') {
            if (lastPlayerState[jsonHistory.serialNumber] && lastPlayerState[jsonHistory.serialNumber].resPlayer && lastPlayerState[jsonHistory.serialNumber].resPlayer.state === 'PLAYING') {
                schedulePlayerUpdate(jsonHistory.serialNumber, 5000, true);
            }
        } else if (jsonHistory.domain === 'Music') {
            schedulePlayerUpdate(jsonHistory.serialNumber, 5000, true);
        } else if (jsonHistory.domain === 'Notifications') {
            scheduleNotificationUpdate(jsonHistory.deviceSerialNumber, 2000);
        }
    }
    adapter.setState('History.json', JSON.stringify(jsonHistory), true);
}

function iterateMultiroom(device, commandCallback, doneCallback, counter) {
    if (!device.isMultiroomDevice) {
        return commandCallback(device, doneCallback);
    }
    if (counter === undefined) {
        adapter.log.debug(`iterate START: ${JSON.stringify(device.clusterMembers)}`);
        counter = 0;
    }
    if (counter >= device.clusterMembers.length) {
        adapter.log.debug(`iterate done ${counter} vs. ${device.clusterMembers.length}`);
        return doneCallback && doneCallback();
    }
    const currDevice = alexa.find(device.clusterMembers[counter]);
    counter++;
    if (!currDevice) {
        adapter.log.debug(`iterate ${counter}: NOT FOUND`);
        return iterateMultiroom(device, commandCallback, doneCallback, counter);
    }
    adapter.log.debug(`iterate ${counter}: ${currDevice.serialNumber}`);
    return commandCallback(currDevice, () => iterateMultiroom(device, commandCallback, doneCallback, counter));
}

function createStatesForDevice(device, additionalDeviceData) {
    return new Promise(resolve => {
        const devId = `Echo-Devices.${device.serialNumber}`;

        device.getNotificationSounds('Alarm', (err, res) => {
            if (!err && res && res.notificationSounds && Array.isArray(res.notificationSounds)) {
                device.alarmNotificationSounds = res.notificationSounds;
                device.alarmNotificationSoundsStateList = {};
                device.alarmNotificationSounds.forEach((n) => {
                    let soundId = n.id;
                    let displayName = n.displayName;
                    if (n.providerId !== 'ECHO') {
                        const folder = n.folder.replace(/^FOLDER_/, '');
                        soundId = `${folder}-${n.id}`;
                        displayName = `${n.providerId}: ${displayName}`;
                        device.alarmNotificationSounds.push(Object.assign({}, n, {id: soundId, origId: n.id}));
                    }
                    device.alarmNotificationSoundsStateList[soundId] = displayName;
                });
            }

            device.getNotificationSounds('Timer', (err, res) => {
                if (!err && res && res.notificationSounds && Array.isArray(res.notificationSounds)) {
                    device.timerNotificationSounds = res.notificationSounds;
                    device.timerNotificationSoundsStateList = {};
                    device.timerNotificationSounds.forEach((n) => {
                        device.timerNotificationSoundsStateList[n.id] = n.displayName;
                    });
                }

                device.getDeviceNotificationState((err, res) => {
                    if (!err && res && res.volumeLevel !== undefined) {
                        additionalDeviceData.notificationVolume = res.volumeLevel;
                    }

                    device.getDeviceNotificationDefaultSound('Alarm', (err, res) => {
                        if (!err && res && res.defaultNotificationSound !== undefined) {
                            additionalDeviceData.defaultAlarmNotificationSound = res.defaultNotificationSound;
                        }

                        device.getDeviceNotificationDefaultSound('Timer', (err, res) => {
                            if (!err && res && res.defaultNotificationSound !== undefined) {
                                additionalDeviceData.defaultTimerNotificationSound = res.defaultNotificationSound;
                            }

                            createDeviceStates(device, additionalDeviceData, () => {
                                if (device.ignore) {
                                    setTimeout(() => !stopped && resolve(), 300);
                                }

                                if (device.isControllable) {
                                    playerDevices[device.serialNumber] = true;
                                    setOrUpdateObject(`${devId}.Player`, {type: 'channel'});

                                    setOrUpdateObject(`${devId}.Player.contentType`, {common: {role: 'text', write: false, def: ''}}); // 'LIVE_STATION' | 'TRACKS' | 'CUSTOM_STATION'
                                    setOrUpdateObject(`${devId}.Player.currentState`, {common: {role: 'media.state', write: false, def: false}}); // 'PAUSED' | 'PLAYING'
                                    setOrUpdateObject(`${devId}.Player.imageURL`, {common: {name: 'Huge image', role: 'media.cover.big', write: false, def: ''}});
                                    setOrUpdateObject(`${devId}.Player.providerId`, {common: {role: 'text', write: false, def: ''}}); // 'TUNE_IN' | 'CLOUD_PLAYER' | 'ROBIN'
                                    setOrUpdateObject(`${devId}.Player.radioStationId`, {common: {role: 'text', write: false, def: ''}}); // 's24885' | null
                                    setOrUpdateObject(`${devId}.Player.service`, {common: {role: 'text', write: false, def: ''}}); // 'TUNE_IN' | 'CLOUD_PLAYER' | 'PRIME_STATION'
                                    setOrUpdateObject(`${devId}.Player.providerName`, {common: {name: 'active provider', role: 'media.input', write: false, def: ''}}); // 'Amazon Music' | 'TuneIn Live-Radio'

                                    setOrUpdateObject(`${devId}.Player.currentTitle`, {common: {name:'current title', type:'string', role:'media.title', write: false, def: ''}});
                                    setOrUpdateObject(`${devId}.Player.currentArtist`, {common: {name:'current artist', type:'string', role:'media.artist', write: false, def: ''}});
                                    setOrUpdateObject(`${devId}.Player.currentAlbum`, {common: {name:'current album', type:'string', role:'media.album', write: false, def: ''}});
                                    setOrUpdateObject(`${devId}.Player.mainArtUrl`, {common: {name:'current main Art', type:'string', role:'media.cover', write: false, def: ''}});
                                    setOrUpdateObject(`${devId}.Player.miniArtUrl`, {common: {name:'current mini Art', type:'string', role:'media.cover.small', write: false, def: ''}});

                                    setOrUpdateObject(`${devId}.Player.mediaId`, {common: {name:'current mediaId', type:'string', role:'media.playid', write: true, def: ''}}, function (device, value) {
                                        alexa.sendCommand(device, 'jump', value);
                                    }.bind(alexa, device));
                                    setOrUpdateObject(`${devId}.Player.queueId`, {common: {name:'current queueId', type:'string', role:'text', write: false, def: ''}});
                                    setOrUpdateObject(`${devId}.Player.quality`, {common: {name:'current media quality', type:'string', role:'text', write: false, def: ''}});
                                    setOrUpdateObject(`${devId}.Player.qualityCodec`, {common: {name:'current media codec', type:'string', write: false, role:'text', def: ''}});
                                    setOrUpdateObject(`${devId}.Player.qualityDataRate`, {common: {name:'current media bitrate', type:'number', write: false, role:'media.bitrate', def: null, unit: 'kbps'}});
                                    setOrUpdateObject(`${devId}.Player.qualitySampleRate`, {common: {name:'current media sample rate', type:'number', write: false, role:'value', def: null, unit: 'Hz'}});
                                    setOrUpdateObject(`${devId}.Player.allowNext`, {common: {name:'allow action Next', type:'boolean', role:'indicator', write: false, def: false}});
                                    setOrUpdateObject(`${devId}.Player.allowPlayPause`, {common: {name:'allow action Play/Pause', type:'boolean', role:'indicator', write: false, def: false}});
                                    setOrUpdateObject(`${devId}.Player.allowPrevious`, {common: {name:'allow action Previous', type:'boolean', role:'indicator', write: false, def: false}});
                                    setOrUpdateObject(`${devId}.Player.allowRepeat`, {common: {name:'allow action Repeat', type:'boolean', role:'indicator', write: false, def: false}});
                                    setOrUpdateObject(`${devId}.Player.allowShuffle`, {common: {name:'allow action Shuffle', type:'boolean', role:'indicator', write: false, def: false}});
                                    setOrUpdateObject(`${devId}.Player.playingInGroup`, {common: {name:'is Playing in Group?', type:'boolean', role:'indicator', write: false, def: false}});
                                    setOrUpdateObject(`${devId}.Player.playingInGroupId`, {common: {name:'Current playing group ID', type:'string', role:'text', write: false, def: ''}});

                                    setOrUpdateObject(`${devId}.Player.mediaLength`, {common: {name:'active media length', type:'number', role:'media.duration', def: 0}});
                                    setOrUpdateObject(`${devId}.Player.mediaLengthStr`, {common: {name:'active media length as (HH:)MM:SS', type:'string', role:'media.duration.text', def: ''}});
                                    setOrUpdateObject(`${devId}.Player.mediaProgress`,  {common: {name:'active media progress', type:'number', role:'media.elapsed', def: 0}});
                                    setOrUpdateObject(`${devId}.Player.mediaProgressStr`, {common: {name:'active media progress as (HH:)MM:SS', type:'string', role:'media.elapsed.text', def: ''}});
                                    setOrUpdateObject(`${devId}.Player.mediaProgressPercent`, {common: {name:'active media progress as percent', type:'number', role:'media.elapsed.percent', def: 0}});
                                    setOrUpdateObject(`${devId}.Player.mediaRemaining`,  {common: {name:'active media remaining time', type:'number', role:'value', def: 0}});
                                    setOrUpdateObject(`${devId}.Player.mediaRemainingStr`, {common: {name:'active media remaining time as (HH:)MM:SS', type:'string', role:'value', def: ''}});

                                    for (const c of Object.keys(playerControls)) {
                                        const obj = JSON.parse (JSON.stringify (playerControls[c]));
                                        setOrUpdateObject(`${devId}.Player.${c}`, {common: obj.common}, obj.val, alexa.sendCommand.bind(alexa, device, obj.command));
                                    }

                                    if (device.capabilities.includes('VOLUME_SETTING')) {
                                        setOrUpdateObject(`${devId}.Player.muted`, {common: {type: 'boolean', role: 'media.mute', write: false, def: false}});
                                        setOrUpdateObject(`${devId}.Player.volume`, {common: {type: 'number', role: 'level.volume', min: 0, max: 100, def: null}}, undefined, function (device, value) {
                                            if (device.isMultiroomDevice) {
                                                alexa.sendCommand(device, 'volume', value, (err, res) => {
                                                    // on unavailability {"message":"No routes found","userFacingMessage":null}
                                                    if (res && res.message === 'No routes found') {
                                                        const volumeCommands = [];
                                                        iterateMultiroom(device, (iteratorDevice, nextCallback) => {
                                                            volumeCommands.push({
                                                                command: 'volume',
                                                                value,
                                                                device: iteratorDevice.serialNumber
                                                            });
                                                            nextCallback && nextCallback();
                                                        }, () => {
                                                            alexa.sendMultiSequenceCommand(device.serialNumber, volumeCommands, 'ParallelNode', alexa.ownerCustomerId);
                                                        });
                                                    }
                                                });
                                            }
                                            else {
                                                try {
                                                    alexa.sendSequenceCommand(device, 'volume', value, alexa.ownerCustomerId);
                                                } catch (err) {
                                                    adapter.log.error(`${device.serialNumber} Error setting volume: ${err}`);
                                                }
                                            }
                                        }.bind(alexa, device));
                                    }

                                    if (device.hasMusicPlayer) {
                                        for (const c of Object.keys(musicControls)) {
                                            const obj = JSON.parse (JSON.stringify (musicControls[c]));
                                            setOrUpdateObject(`${devId}.Player.${c}`, {common: obj.common}, obj.val, alexa.sendCommand.bind(alexa, device, obj.command));
                                        }
                                        setOrUpdateObject(`${devId}.Music-Provider`, {type: 'channel'});
                                        for (const p in musicProviders) {
                                            if (musicProviders[p].availability !== 'AVAILABLE') continue;
                                            if (!musicProviders[p].supportedOperations.includes('Alexa.Music.PlaySearchPhrase')) continue;
                                            const displayName = musicProviders[p].displayName.replace(adapter.FORBIDDEN_CHARS, '-').replace(/\./g, '_').replace(/ /g, '-');
                                            if (!displayName.length) {
                                                musicProviders[p].id !== 'DEFAULT' && adapter.log.warn(`Music Provider has no name, ignoring! (${JSON.stringify(musicProviders[p])})`);
                                                continue;
                                            }

                                            setOrUpdateObject(`${devId}.Music-Provider.${displayName}`, {common: {name:`Phrase to play with ${musicProviders[p].displayName}`, type:'string', role:'text', def: ''}}, '', playMusicProvider.bind(alexa, device, musicProviders[p].id));
                                            setOrUpdateObject(`${devId}.Music-Provider.${displayName}-Playlist`, {common: {name:`Playlist to play with ${musicProviders[p].displayName}`, type:'string', role:'text', def: ''}}, '', function(device, providerId, value) {
                                                if (value === '') return;
                                                playMusicProvider(device, providerId, `playlist ${value}`);
                                            }.bind(alexa, device, musicProviders[p].id));
                                        }
                                    }

                                    if (device.capabilities.includes ('TUNE_IN')) {
                                        setOrUpdateObject(`${devId}.Player.TuneIn-Station`, {common: {role: 'text', def: ''}}, '', function (device, query) {
                                            if (query.match(/^s[0-9]+$/)) {
                                                device.setTunein(query, 'station', (err, ret) => {
                                                    if (!err) {
                                                        adapter.setState(`${devId}.Player.TuneIn-Station`, query, true);
                                                        schedulePlayerUpdate(device, 5000);
                                                    }
                                                });
                                                /*} else if (query.match(/^p[0-9]+$/)) {
                                                    device.setTunein(query, 'show', (err, ret) => {
                                                        if (!err) {
                                                            adapter.setState(`${devId}.Player.TuneIn-Station`, query, true);
                                                            schedulePlayerUpdate(device, 5000);
                                                        }
                                                    });*/
                                            } else if (query.match(/^t[0-9]+$/)) {
                                                device.setTunein(query, 'topic', (err, ret) => {
                                                    if (!err) {
                                                        adapter.setState(`${devId}.Player.TuneIn-Station`, query, true);
                                                        schedulePlayerUpdate(device, 5000);
                                                    }
                                                });
                                            } else {
                                                alexa.tuneinSearch(query, (err, res) => {
                                                    setRequestResult(err, res);
                                                    if (err || !res || !Array.isArray (res.browseList)) return;
                                                    const station = res.browseList[0];
                                                    device.setTunein(station.id, station.contentType, (err, ret) => {
                                                        if (!err) {
                                                            adapter.setState(`Echo-Devices.${device.serialNumber}.Player.TuneIn-Station`, station.name, true);
                                                            schedulePlayerUpdate(device, 5000);
                                                        }
                                                    });
                                                });
                                            }
                                        }.bind(alexa, device));
                                    }

                                    if (device.capabilities.includes ('AUDIBLE')) {
                                        setOrUpdateObject(`${devId}.Music-Provider.Audible`, {common: {role: 'text', def: ''}}, '', function (device, query) {
                                            device.playAudible(query, (err, ret) => {
                                                if (!err) {
                                                    adapter.setState(`${devId}.Music-Provider.Audible`, query, true);
                                                    schedulePlayerUpdate(device, 5000);
                                                }
                                            });
                                        }.bind(alexa, device));
                                    }
                                }
                                createBluetoothStates(device);

                                if (device.notifications) {
                                    createNotificationStates(device);
                                }

                                if (!device.isMultiroomDevice && device.deviceFamily === 'FIRE_TV') {
                                    setOrUpdateObject(`${devId}.FireTVCommands`, {type: 'channel'});
                                    for (const c of Object.keys(fireTVCommands)) {
                                        const obj = JSON.parse (JSON.stringify(fireTVCommands[c]));
                                        setOrUpdateObject(`${devId}.FireTVCommands.${c}`, {common: obj.common}, obj.val, function (device, command, value) {
                                            command = fireTVCommands[command].command || command;
                                            try {
                                                alexa.sendSequenceCommand(device, command, value, alexa.ownerCustomerId);
                                            } catch (err) {
                                                adapter.log.error(`${device.serialNumber} Error sending command ${command} to FireTV: ${err}`);
                                            }
                                        }.bind(alexa, device, c));
                                    }
                                    /*setOrUpdateObject(`${devId}.FireTVCommands.playPhrase`, {common: {role: 'text', def: '', write: true, read: false}}, '', function (device, query) {
                                        alexa.playFireTV(device, query, (err, ret) => {
                                            if (!err) {
                                                adapter.setState(`${devId}.FireTVCommands.playPhrase`, query, true);
                                            }
                                        });
                                    }.bind(alexa, device));*/
                                }

                                if (device.deviceTypeDetails && device.deviceTypeDetails.commandSupport) {
                                    setOrUpdateObject(`${devId}.Commands`, {type: 'channel'});
                                    for (const c of Object.keys(commands)) {
                                        if (c === 'notification' && device.isMultiroomDevice) continue;
                                        const obj = JSON.parse (JSON.stringify (commands[c]));
                                        if (c === 'sound' && routineSounds && Object.keys(routineSounds).length) {
                                            obj.common.states = routineSounds;
                                        }
                                        if (c === 'skillYours' && routineSkills && Object.keys(routineSkills).length) {
                                            obj.common.states = routineSkills;
                                        }
                                        setOrUpdateObject(`${devId}.Commands.${c}`, {common: obj.common}, obj.val, function (device, command, value) {
                                            command = commands[command].command || command;
                                            const commandsToExecute = [];
                                            const speakVolumeCommands = [];
                                            const speakVolumeResetCommands = [];

                                            iterateMultiroom(device, (iteratorDevice, nextCallback) => {
                                                if (command === 'notification' && value && typeof value === 'string' && value.includes(';')) {
                                                    const parts = value.split(';');
                                                    const title = parts.shift();
                                                    value = {
                                                        title,
                                                        text: parts.join(';')
                                                    };
                                                }

                                                if (command === 'deviceStop' || command === 'textCommand' || command.startsWith('skill')) {
                                                    commandsToExecute.push({
                                                        command,
                                                        value,
                                                        device: iteratorDevice.serialNumber
                                                    });
                                                    return nextCallback && nextCallback();
                                                }
                                                const speakVolume = iteratorDevice.speakVolume;
                                                adapter.getState(`Echo-Devices.${iteratorDevice.serialNumber}.Player.volume`, (err, state) => {
                                                    let speakVolumeReset = 0;
                                                    if (!err && state && state.val !== false && state.val !== null) {
                                                        speakVolumeReset = state.val;
                                                    }
                                                    if (speakVolume && speakVolume > 0 && speakVolume !== speakVolumeReset) {
                                                        speakVolumeCommands.push({
                                                            command: 'volume',
                                                            value: speakVolume,
                                                            device: iteratorDevice.serialNumber
                                                        });
                                                    }
                                                    commandsToExecute.push({
                                                        command,
                                                        value,
                                                        device: iteratorDevice.serialNumber
                                                    });
                                                    if (speakVolume && speakVolume > 0 && speakVolumeReset && speakVolumeReset > 0 && speakVolume !== speakVolumeReset) {
                                                        speakVolumeResetCommands.push({
                                                            command: 'volume',
                                                            value: speakVolumeReset,
                                                            device: iteratorDevice.serialNumber
                                                        });
                                                    }
                                                    nextCallback && nextCallback();
                                                });
                                            }, () => {
                                                if (!commandsToExecute.length) return;
                                                if (command === 'deviceStop' || command === 'textCommand') {
                                                    alexa.sendMultiSequenceCommand(device.serialNumber, commandsToExecute, 'ParallelNode', alexa.ownerCustomerId);
                                                } else {
                                                    const allCommands = [];
                                                    speakVolumeCommands.length && allCommands.push({sequenceType: 'ParallelNode', nodes: speakVolumeCommands});
                                                    allCommands.push({sequenceType: 'ParallelNode', nodes: commandsToExecute});
                                                    speakVolumeResetCommands.length && allCommands.push({sequenceType: 'ParallelNode', nodes: speakVolumeResetCommands});
                                                    alexa.sendMultiSequenceCommand(device.serialNumber, allCommands, null, alexa.ownerCustomerId);
                                                }
                                            });
                                        }.bind(alexa, device, c));
                                    }
                                    setOrUpdateObject(`${devId}.Commands.speak`, {common: { role: 'media.tts', def: ''}}, '', function (device, value) {
                                        if (typeof value !== 'string') return;
                                        if (!value) return;

                                        const speakVolumeCommands = [];
                                        const speakCommands = [];
                                        const speakVolumeResetCommands = [];

                                        iterateMultiroom(device, (iteratorDevice, nextCallback) => {
                                            let valueArr = value.match(/^(([^;0-9]+);)?(([0-9]{1,3});)?(.+)$/);
                                            if (!valueArr) valueArr = [];
                                            const speakVolume = valueArr[4] || iteratorDevice.speakVolume;
                                            value = valueArr[5] || value;
                                            if (!valueArr[4] && valueArr[1]) value = valueArr[1] + value;
                                            adapter.getState(`Echo-Devices.${iteratorDevice.serialNumber}.Player.volume`, (err, state) => {
                                                let speakVolumeReset = 0;
                                                if (!err && state && state.val !== false && state.val !== null) {
                                                    speakVolumeReset = state.val;
                                                }
                                                if (speakVolume && speakVolume > 0 && speakVolume !== speakVolumeReset) {
                                                    speakVolumeCommands.push({
                                                        command: 'volume',
                                                        value: speakVolume,
                                                        device: iteratorDevice.serialNumber
                                                    });
                                                }
                                                const speakCommandsFromValue = [];
                                                value.split(';').forEach((v) => {
                                                    const value = v.trim();
                                                    if (!value || !value.length) return;
                                                    speakCommandsFromValue.push({
                                                        command: 'speak',
                                                        value,
                                                        device: iteratorDevice.serialNumber
                                                    });
                                                });
                                                speakCommands.push({sequenceType: 'SerialNode', nodes: speakCommandsFromValue});
                                                if (speakVolume && speakVolume > 0 && speakVolumeReset && speakVolumeReset > 0 && speakVolume !== speakVolumeReset) {
                                                    speakVolumeResetCommands.push({
                                                        command: 'volume',
                                                        value: speakVolumeReset,
                                                        device: iteratorDevice.serialNumber
                                                    });
                                                }
                                                nextCallback && nextCallback();
                                            });
                                        }, () => {
                                            // Done
                                            if (!speakCommands.length) return;
                                            const allCommands = [];
                                            speakVolumeCommands.length && allCommands.push({sequenceType: 'ParallelNode', nodes: speakVolumeCommands});
                                            allCommands.push({sequenceType: 'ParallelNode', nodes: speakCommands});
                                            speakVolumeResetCommands.length && allCommands.push({sequenceType: 'ParallelNode', nodes: speakVolumeResetCommands});
                                            alexa.sendMultiSequenceCommand(device.serialNumber, allCommands, null, alexa.ownerCustomerId);
                                        });
                                    }.bind(alexa, device));
                                    setOrUpdateObject(`${devId}.Commands.announcement`, {common: { role: 'media.tts', def: ''}}, '', function (device, value) {
                                        if (typeof value !== 'string') return;
                                        if (!value) return;

                                        const speakVolumeCommands = [];
                                        const speakVolumeResetCommands = [];

                                        let speakValue = '';
                                        iterateMultiroom(device, (iteratorDevice, nextCallback) => {
                                            let valueArr = value.match(/^(([^;0-9]+);)?(([0-9]{1,3});)?(.+)$/);
                                            if (!valueArr) valueArr= [];
                                            const speakVolume = valueArr[4] || iteratorDevice.speakVolume;
                                            value = valueArr[5] || value;
                                            if (!valueArr[4] && valueArr[1]) value = valueArr[1] + value;
                                            adapter.getState(`Echo-Devices.${iteratorDevice.serialNumber}.Player.volume`, (err, state) => {
                                                let speakVolumeReset = 0;
                                                if (!err && state && state.val !== false && state.val !== null) {
                                                    speakVolumeReset = state.val;
                                                }
                                                if (speakVolume && speakVolume > 0 && speakVolume !== speakVolumeReset) {
                                                    speakVolumeCommands.push({
                                                        command: 'volume',
                                                        value: speakVolume,
                                                        device: iteratorDevice.serialNumber
                                                    });
                                                }
                                                if (!speakValue) speakValue = value;
                                                if (speakVolume && speakVolume > 0 && speakVolumeReset && speakVolumeReset > 0 && speakVolume !== speakVolumeReset) {
                                                    speakVolumeResetCommands.push({
                                                        command: 'volume',
                                                        value: speakVolumeReset,
                                                        device: iteratorDevice.serialNumber
                                                    });
                                                }
                                                nextCallback && nextCallback();
                                            });
                                        }, () => {
                                            const announceCommands = [];
                                            let volumeResetDelay = 3000;
                                            speakValue.split(';').forEach((v) => {
                                                const value = v.trim();
                                                if (!value || !value.length) return;
                                                announceCommands.push({command: 'announcement', value});
                                                const lengthValue = value.replace(/<.+?>/g, ' ').replace(/\s+/g, ' ').trim();
                                                volumeResetDelay += lengthValue.length * 150;
                                            });
                                            if (!announceCommands.length) return;

                                            const allCommands = [];
                                            speakVolumeCommands.length && allCommands.push({sequenceType: 'ParallelNode', nodes: speakVolumeCommands});
                                            if (announceCommands.length === 1) {
                                                allCommands.push(announceCommands[0]);
                                            } else {
                                                allCommands.push({sequenceType: 'SerialNode', nodes: announceCommands});
                                            }
                                            alexa.sendMultiSequenceCommand((device.isMultiroomDevice && device.clusterMembers) ? device.clusterMembers: device, allCommands, null, alexa.ownerCustomerId, () => {
                                                // Amazon requires us to send volume down separately for announcement
                                                if (speakVolumeResetCommands.length) {
                                                    setTimeout(() => {
                                                        alexa.sendMultiSequenceCommand((device.isMultiroomDevice && device.clusterMembers) ? device.clusterMembers: device, speakVolumeResetCommands, 'ParallelNode', alexa.ownerCustomerId);
                                                    },volumeResetDelay);
                                                }
                                            });
                                        });
                                    }.bind(alexa, device));
                                    setOrUpdateObject(`${devId}.Commands.ssml`, {common: { role: 'media.tts', def: ''}}, '', function (device, value) {
                                        if (typeof value !== 'string') return;
                                        value = value.trim();
                                        if (!value) return;

                                        const speakVolumeCommands = [];
                                        const speakVolumeResetCommands = [];

                                        iterateMultiroom(device, (iteratorDevice, nextCallback) => {
                                            const speakVolume = iteratorDevice.speakVolume;
                                            adapter.getState(`Echo-Devices.${iteratorDevice.serialNumber}.Player.volume`, (err, state) => {
                                                let speakVolumeReset = 0;
                                                if (!err && state && state.val !== false && state.val !== null) {
                                                    speakVolumeReset = state.val;
                                                }
                                                if (speakVolume && speakVolume > 0 && speakVolume !== speakVolumeReset) {
                                                    speakVolumeCommands.push({
                                                        command: 'volume',
                                                        value: speakVolume,
                                                        device: iteratorDevice.serialNumber
                                                    });
                                                }
                                                if (speakVolume && speakVolume > 0 && speakVolumeReset && speakVolumeReset > 0 && speakVolume !== speakVolumeReset) {
                                                    speakVolumeResetCommands.push({
                                                        command: 'volume',
                                                        value: speakVolumeReset,
                                                        device: iteratorDevice.serialNumber
                                                    });
                                                }
                                                nextCallback && nextCallback();
                                            });
                                        }, () => {
                                            const allCommands = [];
                                            speakVolumeCommands.length && allCommands.push({sequenceType: 'ParallelNode', nodes: speakVolumeCommands});
                                            allCommands.push({command: 'ssml', value});
                                            speakVolumeResetCommands.length && allCommands.push({sequenceType: 'ParallelNode', nodes: speakVolumeResetCommands});
                                            alexa.sendMultiSequenceCommand((device.isMultiroomDevice && device.clusterMembers) ? device.clusterMembers: device, allCommands, null, alexa.ownerCustomerId);

                                        });
                                    }.bind(alexa, device));
                                    if (!device.isMultiroomDevice) {
                                        if (existingStates[`${devId}.Commands.speak-volume`]) {
                                            adapter.getState(`${devId}.Commands.speak-volume`, function (device, err, state) {
                                                if (!err && state && state.val && state.val > 0) {
                                                    device.speakVolume = state.val;
                                                    adapter.log.debug(`Initialize speak-Volume for ${device.serialNumber}: ${state.val}`);
                                                }
                                            }.bind(alexa, device));
                                        }
                                        setOrUpdateObject(`${devId}.Commands.speak-volume`, {common: {name: 'Volume to use for speak commands', type: 'number', role: 'level.volume', min: 0, max: 100, def: null}}, undefined, function (device, value) {
                                            if (typeof value !== 'number') {
                                                value = parseInt(value, 10);
                                            }
                                            if (isNaN(value)) return;
                                            device.speakVolume = value;
                                            adapter.log.debug(`Set speak-Volume for ${device.serialNumber}: ${value}`);
                                            adapter.setState(`${devId}.Commands.speak-volume`, value, true);
                                        }.bind(alexa, device));
                                    }
                                }
                                setOrUpdateObject(`${devId}.Commands.doNotDisturb`, {common: {type: 'mixed', role: 'state'}}, undefined, function (device, value) {

                                    if (value === 'true') {
                                        value = true;
                                    } else if (value === 'false') {
                                        value = false;
                                    } else if (value === '') {
                                        return;
                                    } else if (typeof value === 'string' && isFinite(value)) {
                                        value = parseInt(value, 10);
                                    }

                                    const deviceList = [];
                                    iterateMultiroom(device, (iteratorDevice, nextCallback) => {
                                        deviceList.push(iteratorDevice.serialNumber);
                                        return nextCallback && nextCallback();
                                    }, () => {
                                        if (!deviceList.length) return;
                                        alexa.sendSequenceCommand(deviceList, 'deviceDoNotDisturb', value, alexa.ownerCustomerId, (err, res) => {
                                            if (err) {
                                                adapter.log.error(`Error setting doNotDisturb for ${JSON.stringify(deviceList)}: ${err}`);
                                            } else {
                                                deviceList.forEach(serialNumber => {
                                                    adapter.setState(`Echo-Devices.${serialNumber}.Commands.doNotDisturb`, !!value, true);
                                                });
                                            }
                                        });
                                    });
                                }.bind(alexa, device));

                                if (!device.isMultiroomDevice && device.deviceTypeDetails && device.deviceTypeDetails.commandSupport) {
                                    if (automationRoutines) {
                                        setOrUpdateObject(`${devId}.Routines`, {type: 'channel'});
                                        for (const i of Object.keys(automationRoutines)) {
                                            setOrUpdateObject(`${devId}.Routines.${automationRoutines[i].friendlyAutomationId}`, {common: { type: 'boolean', role: 'indicator', read: true, write: true, name: automationRoutines[i].friendlyName}}, false, alexa.executeAutomationRoutine.bind(alexa, device, automationRoutines[i]));
                                            if (automationRoutines[i].utteranceWords) {
                                                if (!routineTriggerUtterances[device.serialNumber]) routineTriggerUtterances[device.serialNumber] = {};
                                                automationRoutines[i].utteranceWords.forEach(utterance => {
                                                    if (!utterance) return;
                                                    routineTriggerUtterances[device.serialNumber][utterance.toLowerCase()] = `${devId}.Routines.${automationRoutines[i].friendlyAutomationId}`;
                                                });
                                            }
                                        }
                                    }
                                }

                                setTimeout(() => !stopped && resolve(), 750);
                            });
                        });
                    });
                });
            });
        });
    });
}

function createStates(callback) {

    alexa.getAscendingAlarmState(async (err, alarmStates) => {
        const ascendingAlarmStates = {};
        if (!err && alarmStates && Array.isArray(alarmStates.ascendingAlarmModelList)) {
            alarmStates.ascendingAlarmModelList.forEach(alarmState => {
                if (alarmState.serialNumber) {
                    ascendingAlarmStates[alarmState.deviceSerialNumber] = alarmState.ascendingAlarmEnabled;
                }
            });
        }

        setOrUpdateObject('requestResult', {common: {name: 'Request Result', write: false, role: 'text'}}, '');
        setOrUpdateObject('Echo-Devices', {type: 'folder', common: {name: 'Echo devices'}});

        for (const n of Object.keys(alexa.serialNumbers)) {
            const device = alexa.serialNumbers[n];
            const additionalDeviceData = {};
            if (ascendingAlarmStates[device.serialNumber] !== undefined) {
                additionalDeviceData.ascendingAlarmState = ascendingAlarmStates[device.serialNumber];
            }

            await createStatesForDevice(device, additionalDeviceData);
        }

        setOrUpdateObject('Echo-Devices.CommandsAll', {type: 'channel', common: {name: 'Commands to all devices'}});
        for (const c of Object.keys(allDevicesCommands)) {
            const obj = JSON.parse (JSON.stringify(allDevicesCommands[c]));
            setOrUpdateObject(`Echo-Devices.CommandsAll.${c}`, {common: obj.common}, obj.val, function (command, value) {
                command = allDevicesCommands[command].command || command;

                if (command === 'deviceDoNotDisturbAll') {
                    if (value === 'true') {
                        value = true;
                    } else if (value === 'false') {
                        value = false;
                    } else if (value === '') {
                        return;
                    } else if (typeof value === 'string' && isFinite(value)) {
                        value = parseInt(value, 10);
                    }
                }
                try {
                    alexa.sendSequenceCommand('', command, value, alexa.ownerCustomerId, (err, res) => {
                        if (!err && res && command === 'deviceDoNotDisturbAll') {
                            updateConfigurationTimer && clearTimeout(updateConfigurationTimer);
                            updateConfigurationTimer = setTimeout(() => {
                                updateDeviceConfigurationStates();
                            }, 3000);
                        }
                    });
                } catch (err) {
                    adapter.log.error(`Error sending command ${command} to all devices: ${err}`);
                }
            }.bind(alexa, c));
        }


        setOrUpdateObject('History', {type: 'channel', common: {name: 'Last detected commands and devices'}});
        setOrUpdateObject('History.#trigger', {common: { type: 'boolean', read: false, write: true, role: 'button', name: 'Trigger/Rescan', desc: 'Set to true, to start a request'}}, false,
            (val) => updateHistory());
        setOrUpdateObject('History.name', {common: {role: 'text', write: false, name: 'Echo Device name', desc: 'Device name of the last detected command'}}, '');
        let now = new Date();
        now = now.getTime() - now.getTimezoneOffset();
        setOrUpdateObject('History.creationTime', {common: {role: 'value.time'}}, now);
        setOrUpdateObject('History.serialNumber', {common: {role: 'text', write: false}}, '');
        setOrUpdateObject('History.summary', {common: {role: 'text', write: false}}, '');
        setOrUpdateObject('History.status', {common: {role: 'text', write: false}}, '');
        setOrUpdateObject('History.domainApplicationId', {common: {role: 'text', write: false}}, '');
        setOrUpdateObject('History.domainApplicationName', {common: {role: 'text', write: false}}, '');
        setOrUpdateObject('History.cardContent', {common: {role: 'text', write: false}}, '');
        setOrUpdateObject('History.cardJson', {common: {role: 'text', write: false}}, '');
        setOrUpdateObject('History.utteranceType', {common: {role: 'text', write: false}}, '');
        setOrUpdateObject('History.answerText', {common: {role: 'text', write: false}}, '');
        setOrUpdateObject('History.json', {common: {type: 'string', role: 'json', write: false}}, '');
        setOrUpdateObject('History.domain', {common: {role: 'text', write: false}}, '');
        setOrUpdateObject('History.intent', {common: {role: 'text', write: false}}, '');

        processObjectQueue(callback);
    });
}

function playMusicProvider(device, providerId, value) {
    if (value === '') return;
    if (device.isMultiroomDevice && device.clusterMembers.length) {
        value += ` auf ${device._name} `;
        device = alexa.find(device.clusterMembers[0]);
    }
    alexa.playMusicProvider(device, providerId, value.trim(), (err, res) => {
        schedulePlayerUpdate(device, 5000);
    });
}

async function createDeviceStates(serialOrName, additionalDeviceData, callback) {
    additionalDeviceData = additionalDeviceData || {};
    const device = alexa.find(serialOrName);
    const devId = `Echo-Devices.${device.serialNumber}`;

    let preserveSettings;
    if (device.parentDeviceSerialNumber) {
        // App device, add it but adjust name
        preserveSettings = { common: ['name'] };
        device._name += ` (${device.parentDeviceSerialNumber})`;
    }
    if (device.deviceType === 'A2IVLV5VM2W81') {
        if (!device.parentDeviceSerialNumber || !adapter.config.includeAppDevices) {
            // App main device, ignore them!
            adapter.log.debug(`Ignore Device ${device.serialNumber} because is App-Type`);
            device.ignore = true;
            device.deviceTypeDetails = {name: 'App', commandSupport: false};

            if (device.appDeviceList.length) {
                device.appDeviceList.forEach((app) => {
                    appDevices[app.serialNumber] = app;
                    appDevices[app.serialNumber].ownerDevice = device.serialNumber;
                });
            }
            return callback && callback();
        }
    }

    let deviceTypeDetails = knownDeviceType[device.deviceType];
    const commonDevice = {name: device._name};
    if (!deviceTypeDetails) {
        deviceTypeDetails =  {name: 'Unknown', commandSupport: true};
        if (!unknownDeviceWarnings[device.deviceType]) {
            adapter.log.info('Unknown Device, but enabling commands, Try it and report back if commands work.');
            adapter.log.info('Report to developer as GitHub issue with details for device. Please grab full next line pot. from logfile on disk if cutted');
            adapter.log.info(`    Device-type:${device.deviceType} - ${device._name} (${device.capabilities.join(',')})`);
            unknownDeviceWarnings[device.deviceType] = true;
        }
    } else if (deviceTypeDetails.icon) {
        commonDevice.icon = deviceTypeDetails.icon;
    }
    device.deviceTypeDetails = deviceTypeDetails;

    setOrUpdateObject(devId, {type: 'device', common: commonDevice, preserveSettings});
    setOrUpdateObject(`${devId}.online`, {common: {role: 'indicator.reachable', type: 'boolean'}}, device.online);
    //setOrUpdateObject(devId + '.delete', {common: {name: 'Delete (Log out of this device)', role: 'button'}}, false); TODO

    setOrUpdateObject(`${devId}.Info`, {type: 'channel'});
    setOrUpdateObject(`${devId}.Info.capabilities`, {common: {role: 'text', write: false}}, device.capabilities.join (','));
    setOrUpdateObject(`${devId}.Info.softwareVersion`, {common: {role: 'text', write: false}}, device.softwareVersion);
    setOrUpdateObject(`${devId}.Info.isMultiroomDevice`, {common: {type: 'boolean', role: 'indicator', write: false}}, device.isMultiroomDevice);
    if (device.isMultiroomDevice) {
        setOrUpdateObject(`${devId}.Info.multiroomMembers`, {common: {role: 'text', write: false}}, device.clusterMembers.join (','));
    }
    setOrUpdateObject(`${devId}.Info.isMultiroomMember`, {common: {type: 'boolean', role: 'indicator', write: false}}, device.isMultiroomMember);
    if (device.isMultiroomMember) {
        setOrUpdateObject(`${devId}.Info.multiroomParents`, {common: {role: 'text', write: false}}, device.parentClusters.join (','));
    }
    setOrUpdateObject(`${devId}.Info.deviceType`, {common: {name: 'deviceType', type: 'string', role: 'text'}}, device.deviceType || '');

    setOrUpdateObject(`${devId}.Info.deviceTypeString`, {common: {name: 'deviceType string', type: 'string', role: 'text'}}, deviceTypeDetails.name);
    setOrUpdateObject(`${devId}.Info.serialNumber`, {common: {name: 'serialNumber', type: 'string', role: 'text'}}, device.serialNumber);
    setOrUpdateObject(`${devId}.Info.name`, {common: {name: 'name', type: 'string', role: 'info.name'}}, device._name);
    setOrUpdateObject(`${devId}.Info.deviceFamily`, {common: {name: 'Device Family', type: 'string', role: 'info'}}, device.deviceFamily);

    let numPreferences = 0;
    if (device.capabilities.includes('EARCONS') && device.preferences && device.preferences.notificationEarconEnabled !== undefined) {
        numPreferences++;
        adapter.log.debug(`${devId} notificationEarconEnabled: ${device.preferences.notificationEarconEnabled}`);
        setOrUpdateObject(`${devId}.Preferences.ringNotificationsEnabled`, {
            common: {
                type: 'boolean',
                role: 'indicator',
                write: true
            }
        }, device.preferences.notificationEarconEnabled, function (device, value) {
            device.getDevicePreferences((err, res) => {
                if (err || !res) {
                    adapter.log.error(`Error getting preferences for ${device.serialNumber}: ${err.message}`);
                    return;
                }
                res.notificationEarconEnabled = !!value;
                device.setDevicePreferences(res, (err, res) => {
                    if (err || !res) {
                        adapter.log.error(`Error setting preferences for ${device.serialNumber}: ${err.message}`);
                        return;
                    }
                    device.preferences = res;
                    adapter.setState(`${devId}.Preferences.ringNotificationsEnabled`, !!res.notificationEarconEnabled, true);
                });
            });
        }.bind(alexa, device));
    }

    if (device.capabilities.includes('TIMERS_ALARMS_NOTIFICATIONS_VOLUME') && additionalDeviceData.notificationVolume !== undefined) {
        numPreferences++;
        adapter.log.debug(`${devId} notificationVolume: ${additionalDeviceData.notificationVolume}`);
        setOrUpdateObject(`${devId}.Preferences.notificationVolume`, {
            common: {
                type: 'number',
                role: 'level.volume',
                min: 0,
                max: 100,
                write: true
            }
        }, additionalDeviceData.notificationVolume, function (device, value) {
            value = parseInt(value, 10);
            if (isNaN(value) || value < 0 || value > 100) {
                adapter.log.error(`Invalid alarm volume ${value} for ${device.serialNumber}`);
                return;
            }
            device.setDeviceNotificationVolume(value, (err, res) => {
                if (err || !res) {
                    adapter.log.error(`Error setting alarm volume to ${value} for ${device.serialNumber}: ${err.message}`);
                    return;
                }
                adapter.setState(`${devId}.Preferences.notificationVolume`, value, true);
            });
        }.bind(alexa, device));
    }

    if (device.capabilities.includes('ASCENDING_ALARM_VOLUME') && additionalDeviceData.ascendingAlarmState !== undefined) {
        numPreferences++;
        adapter.log.debug(`${devId} ascendingAlarmState: ${additionalDeviceData.ascendingAlarmState}`);
        setOrUpdateObject(`${devId}.Preferences.ascendingAlarmState`, {
            common: {
                type: 'boolean',
                role: 'switch',
                write: true
            }
        }, additionalDeviceData.ascendingAlarmState, function (device, value) {
            value = !!value;
            device.setDeviceAscendingAlarmState(value, (err, res) => {
                if (err || !res) {
                    adapter.log.error(`Error setting ascending alarm state to ${value} for ${device.serialNumber}: ${err.message}`);
                    return;
                }
                adapter.setState(`${devId}.Preferences.ascendingAlarmState`, value, true);
            });
        }.bind(alexa, device));
    }

    if (additionalDeviceData.defaultAlarmNotificationSound !== undefined) {
        numPreferences++;
        adapter.log.debug(`${devId} defaultAlarmNotificationSound: ${additionalDeviceData.defaultAlarmNotificationSound.id}`);
        setOrUpdateObject(`${devId}.Preferences.defaultAlarmNotificationSound`, {
            common: {
                type: 'string',
                role: 'text',
                write: true,
                states: device.alarmNotificationSoundsStateList
            }
        }, additionalDeviceData.defaultAlarmNotificationSound.id, function (device, value) {
            const soundDef = device.alarmNotificationSounds.find(s => s.id === value);
            if (!soundDef) {
                adapter.log.error(`Invalid alarm sound ${value} for ${device.serialNumber}`);
                return;
            }
            device.setDeviceNotificationDefaultSound('Alarm', soundDef.id, (err, res) => {
                if (err || !res) {
                    adapter.log.error(`Error setting default notification sound to ${soundDef.id} for ${device.serialNumber}: ${err.message}`);
                    return;
                }
                adapter.setState(`${devId}.Preferences.defaultAlarmNotificationSound`, soundDef.id, true);
            });
        }.bind(alexa, device));
    }

    if (additionalDeviceData.defaultTimerNotificationSound !== undefined) {
        numPreferences++;
        adapter.log.debug(`${devId} defaultTimerNotificationSound: ${additionalDeviceData.defaultTimerNotificationSound.id}`);
        setOrUpdateObject(`${devId}.Preferences.defaultTimerNotificationSound`, {
            common: {
                type: 'string',
                role: 'text',
                write: true,
                states: device.alarmNotificationSoundsStateList
            }
        }, additionalDeviceData.defaultTimerNotificationSound.id, function (device, value) {
            const soundDef = device.alarmNotificationSounds.find(s => s.id === value);
            if (!soundDef) {
                adapter.log.error(`Invalid alarm sound ${value} for ${device.serialNumber}`);
                return;
            }
            device.setDeviceNotificationDefaultSound('Timer', soundDef.id, (err, res) => {
                if (err || !res) {
                    adapter.log.error(`Error setting default notification sound to ${soundDef.id} for ${device.serialNumber}: ${err.message}`);
                    return;
                }
                adapter.setState(`${devId}.Preferences.defaultTimerNotificationSound`, soundDef.id, true);
            });
        }.bind(alexa, device));
    }


    numPreferences += await initEqualizerData(device);
    numPreferences += await initDeviceAuxController(device);
    numPreferences += await initDisplaySettings(device);

    if (numPreferences > 0) {
        setOrUpdateObject(`${devId}.Preferences`, {type: 'channel'});
    }

    if (device.deviceType === 'A2IVLV5VM2W81' || device.serialNumber.length === 32) {
        return processObjectQueue(callback);
    }
    alexa.getDeviceWifiDetails(device, (err, res) => {
        if (!err && res && typeof res.macAddress === 'string' && res.macAddress.length) {
            setOrUpdateObject(`${devId}.Info.macAddress`, {
                common: {
                    name: 'name',
                    type: 'string',
                    role: 'info.mac'
                }
            }, res.macAddress.toUpperCase().replace(/(.{2})/g, '$1:'));
        }
        if (!err && res && res.essid) {
            setOrUpdateObject(`${devId}.Info.WifiSSID`, {
                common: {
                    name: 'name',
                    type: 'string',
                    role: 'text'
                }
            }, res.essid);
        }
        processObjectQueue(callback);
    });
}

function updateDeviceStatus(serialOrName, callback) {
    if (typeof serialOrName === 'function') {
        callback = serialOrName;
        serialOrName = null;
    }
    if (serialOrName) serialOrName = alexa.find(serialOrName);

    alexa.initDeviceState(async () => {
        for (const devId of Object.keys(alexa.serialNumbers)) {
            const device = alexa.find(devId);
            if (serialOrName && serialOrName !== device) return;

            await createDeviceStates(device);
        }
        if (callback) {
            callback();
        }
        else {
            processObjectQueue();
        }
    });
}


function createBluetoothStates(serialOrName) {
    const device = alexa.find(serialOrName);
    const devId = `Echo-Devices.${device.serialNumber}`;

    if (device.bluetoothState && !device.isMultiroomDevice && device.deviceTypeDetails && device.deviceTypeDetails.commandSupport) {
        setOrUpdateObject(`${devId}.Bluetooth`, {type: 'device'});
        device.bluetoothState.pairedDeviceList.forEach ((bt) => {
            setOrUpdateObject(`${devId}.Bluetooth.${bt.address}`, {type: 'channel', common: {name: bt.friendlyName}});
            setOrUpdateObject(`${devId}.Bluetooth.${bt.address}.connected`, {common: {role: 'switch'}}, bt.connected, bt.connect);
            setOrUpdateObject(`${devId}.Bluetooth.${bt.address}.unpair`, {common: { type: 'boolean', read: false, write: true, role: 'button'}}, false, bt.unpaire);
        });
    }
}

function updateBluetoothStatus(serialOrName, callback) {
    if (typeof serialOrName === 'function') {
        callback = serialOrName;
        serialOrName = null;
    }
    if (!alexa._options.bluetooth) {
        return callback && callback();
    }
    if (serialOrName) serialOrName = alexa.find(serialOrName);

    alexa.initBluetoothState(() => {
        Object.keys(alexa.serialNumbers).forEach ((n) => {
            const device = alexa.find(n);
            if (serialOrName && serialOrName !== device) return;

            createBluetoothStates(device);
        });
        if (callback) {
            callback();
        }
        else {
            processObjectQueue();
        }
    });
}

function createNotificationStates(serialOrName) {
    const device = alexa.find(serialOrName);
    const devId = `Echo-Devices.${device.serialNumber}`;

    if (device.notifications) {
        if (device.capabilities.includes('REMINDERS')) {
            setOrUpdateObject(`${devId}.Reminder`, {type: 'device'});
            setOrUpdateObject(`${devId}.Reminder.New`, {common: {type: 'mixed', role: 'state', name: 'Add new Reminder'}}, '', function(device, value) {
                if (typeof value !== 'string') {
                    adapter.log.error('Invalid value for new Reminder, please provide a string');
                    return;
                }
                const valueArr = value.split(';');
                let time = valueArr.shift().trim();
                if (parseInt(time, 10) == time) time = parseInt(time, 10);
                let label = valueArr.shift();
                if (label) label = label.trim();
                let sound = valueArr.shift();
                let recurring = valueArr.shift();
                if (sound) {
                    sound = sound.trim();
                    if (sound.startsWith('DAILY') || sound.startsWith('WEEKLY')) {
                        recurring = sound;
                        sound = undefined;
                    }
                    if (sound && device.alarmNotificationSounds) {
                        sound = device.alarmNotificationSounds.find(s => s.id === sound);
                    } else {
                        sound = undefined;
                    }
                }
                if (recurring) {
                    recurring = recurring.trim();
                    if (recurring === 'DAILY') {
                        recurring = {
                            freq: 'DAILY',
                            byDay: [],
                            interval: 1
                        };
                    } else if (recurring.startsWith('WEEKLY=')) {
                        recurring = {
                            freq: 'WEEKLY',
                            byDay: recurring.substring(7).split(',').map(d => d.trim()).filter(d => d.length),
                            interval: 1
                        };
                    } else if (recurring.startsWith('{') && recurring.endsWith('}')) {
                        try {
                            recurring = JSON.parse(recurring);
                        } catch(err) {
                            adapter.log.error(`Invalid recurring JSON value: ${recurring}`);
                            recurring = undefined;
                        }
                    } else {
                        recurring = undefined;
                    }
                }
                if (!label) {
                    adapter.log.error('Can not create new Reminder without label');
                    return;
                }
                adapter.log.debug(`New Reminder: ${time} ${label} ${JSON.stringify(sound)} ${JSON.stringify(recurring)}`);
                const notification = alexa.createNotificationObject(device, 'Reminder', label, time, true, sound, recurring);
                if (notification) {
                    alexa.createNotification(notification, (err, res) => {
                        scheduleNotificationUpdate(device, 2000, true);
                    });
                }
            }.bind(alexa, device));
        }
        if (device.capabilities.includes('TIMERS_AND_ALARMS')) {
            setOrUpdateObject(`${devId}.Alarm`, {type: 'device'});
            setOrUpdateObject(`${devId}.Alarm.New`, {common: {type: 'mixed', role: 'state', name: 'Add new Alarm'}}, '', function(device, value) {
                if (typeof value !== 'string') {
                    adapter.log.error('Invalid value for new Alarm, please provide a string');
                    return;
                }
                const valueArr = value.split(';');
                let time = valueArr.shift().trim();
                if (parseInt(time, 10) == time) time = parseInt(time, 10);
                let label = valueArr.shift();
                if (label) label = label.trim();
                let sound = valueArr.shift();
                let recurring = valueArr.shift();
                if (sound) {
                    sound = sound.trim();
                    if (sound.startsWith('DAILY') || sound.startsWith('WEEKLY') || (sound.startsWith('{') && sound.endsWith('}'))) {
                        recurring = sound;
                        sound = undefined;
                    }
                    if (sound && device.alarmNotificationSounds) {
                        sound = device.alarmNotificationSounds.find(s => s.id === sound);
                    } else {
                        sound = undefined;
                    }
                }
                if (recurring) {
                    recurring = recurring.trim();
                    if (recurring === 'DAILY') {
                        recurring = {
                            freq: 'DAILY',
                            byDay: [],
                            interval: 1
                        };
                    } else if (recurring.startsWith('WEEKLY=')) {
                        recurring = {
                            freq: 'WEEKLY',
                            byDay: recurring.substring(7).split(',').map(d => d.trim()).filter(d => d.length),
                            interval: 1
                        };
                    } else if (recurring.startsWith('{') && recurring.endsWith('}')) {
                        try {
                            recurring = JSON.parse(recurring);
                        } catch(err) {
                            adapter.log.error(`Invalid recurring JSON value: ${recurring}`);
                            recurring = undefined;
                        }
                    } else {
                        recurring = undefined;
                    }
                }
                adapter.log.debug(`New Alarm: ${time} ${label} ${JSON.stringify(sound)} ${JSON.stringify(recurring)}`);
                const notification = alexa.createNotificationObject(device, 'Alarm', label, time, true, sound, recurring);
                if (notification) {
                    alexa.createNotification(notification, (err, res) => {
                        scheduleNotificationUpdate(device, 2000, true);
                    });
                }
            }.bind(alexa, device));
            setOrUpdateObject(`${devId}.Alarm.triggered`, {common: {type: 'string', read: true, write: false, role: 'value', name: 'Alarm ID that got Triggered'}}, null);
            setOrUpdateObject(`${devId}.Reminder.triggered`, {common: {type: 'string', read: true, write: false, role: 'value', name: 'Reminder ID that got Triggered'}}, null);
            setOrUpdateObject(`${devId}.Timer`, {type: 'device'});
            setOrUpdateObject(`${devId}.Timer.triggered`, {common: {type: 'boolean', read: true, write: false, role: 'indicator', name: 'A timer got Triggered'}}, false);

            if (rememberedNotificationVolumeRestoreCallbacks[device.serialNumber] !== undefined) {
                adapter.log.debug(`Restoring notification volume for ${device.serialNumber} because triggered flag cleared`);
                rememberedNotificationVolumeRestoreCallbacks[device.serialNumber]();
                delete rememberedNotificationVolumeRestoreCallbacks[device.serialNumber];
            }
        }
        let nextTimerObject = null;
        const activeTimerList = [];
        for (const noti of device.notifications) {
            if (notificationTimer[noti.id]) {
                clearTimeout(notificationTimer[noti.id]);
                notificationTimer[noti.id] = null;
            }
            let isMusicAlarm = false;
            if (noti.type === 'MusicAlarm') {
                noti.type = 'Alarm';
                isMusicAlarm = true;
            }
            if (noti.type === 'Reminder' && !device.capabilities.includes('REMINDERS')) continue;
            if (noti.type === 'Alarm' && !device.capabilities.includes('TIMERS_AND_ALARMS')) continue;
            if (noti.type === 'Timer' && noti.status === 'ON' && noti.remainingTime > 0) {
                let remainingTime = noti.remainingTime;
                if (noti.triggerTime) {
                    remainingTime = noti.triggerTime - Date.now();
                    noti.remainingTime = remainingTime;
                }
                adapter.log.debug(`${noti.type} ${noti.id} triggered in ${Math.floor(remainingTime / 1000)}s`);
                if (remainingTime > 0) {
                    if (nextTimerObject === null || nextTimerObject.remainingTime > remainingTime) {
                        nextTimerObject = noti;
                    }
                    activeTimerList.push({
                        id: noti.notificationIndex,
                        triggerTime: noti.triggerTime || Date.now() + remainingTime,
                        label: noti.timerLabel
                    });
                    if (notificationTimer[noti.id]) {
                        clearTimeout(notificationTimer[noti.id]);
                        notificationTimer[noti.id] = null;
                    }
                    if (remainingTime < 14 * 24 * 60 * 60 * 1000) { // not longer then 14 days in future
                        notificationTimer[noti.id] = setTimeout(function (noti) {
                            notificationTimer[noti.id] = null;
                            adapter.log.debug(`${noti.type} ${noti.id} triggered`);
                            adapter.setState(`${devId}.Timer.triggered`, true, true);

                            // Check again status after 1min if no stop was arrived
                            notificationTimer[noti.id] = setTimeout(() => {
                                notificationTimer[noti.id] = null;
                                adapter.getState(`${devId}.Timer.triggered`, (err, state) => {
                                    if (!err && state && state.val) {
                                        updateNotificationStates(device);
                                    }
                                });
                            }, 60000);
                        }.bind(alexa, noti), remainingTime);
                    } else {
                        notificationTimer[noti.id] = setTimeout(function (noti) {
                            notificationTimer[noti.id] = null;
                            updateNotificationStates(device);
                        }.bind(alexa, noti), 14 * 24 * 60 * 60 * 1000);
                    }
                }
            } else if (noti.type !== 'Timer') {
                const id = noti.notificationIndex;
                const notiId = `${devId}.${noti.type}.${id}`;
                let displayName = noti.reminderLabel;
                let time = noti.originalTime;
                if (time) {
                    if (typeof time === 'string' && time.endsWith('.000')) {
                        time = time.substring(0, time.length - 4);
                    }
                    displayName = displayName ? `${displayName} ${time}`: time;
                }
                if (!displayName) {
                    displayName = noti.type;
                }

                let rRuleDaysList = '';
                if (noti.rRuleData && noti.rRuleData.byWeekDays) {
                    rRuleDaysList = noti.rRuleData.byWeekDays.join(',');
                } else if (noti.recurringPattern && noti.recurringPattern.endsWith('-WE')) {
                    rRuleDaysList = 'SA,SU';
                } else if (noti.recurringPattern && noti.recurringPattern.endsWith('-WD')) {
                    rRuleDaysList = 'MO,TU,WE,TH,FR';
                } else if (noti.recurringPattern && noti.recurringPattern === 'P1D') {
                    rRuleDaysList = 'MO,TU,WE,TH,FR,SA,SU';
                } else if (!noti.recurringPattern && noti.rRuleData && noti.rRuleData.recurrenceRules && noti.rRuleData.recurrenceRules.length && noti.rRuleData.recurrenceRules[0].startsWith('FREQ=DAILY;')) {
                    rRuleDaysList = 'MO,TU,WE,TH,FR,SA,SU';
                }

                setOrUpdateObject(notiId, {type: 'channel', common: {name: displayName}});
                setOrUpdateObject(`${notiId}.date`, {common: {type: 'mixed', read: true, write: true, role: 'state', name: `${displayName} Date`}}, noti.originalDate, value => {
                    noti.set(value, (err, res) => {
                        if (err || !res) {
                            adapter.log.warn(`Error setting ${notiId}.date to ${value}: ${err.message}`);
                        }
                    });
                });
                setOrUpdateObject(`${notiId}.time`, {common: {type: 'mixed', role: 'state', name: `${displayName} Time`}}, time,  value => {
                    noti.set(value, (err, res) => {
                        if (err || !res) {
                            adapter.log.warn(`Error setting ${notiId}.time to ${value}: ${err.message}`);
                        }
                    });
                });
                setOrUpdateObject(`${notiId}.enabled`, {common: {type: 'boolean', role: 'switch.enable', name: `${displayName} Enabled`}}, (noti.status === 'ON' || noti.status === 'SNOOZED'), value => {
                    noti.set(!!value, (err, res) => {
                        if (err | !res) {
                            adapter.log.error(`Error setting ${notiId}.enabled to ${value}: ${err.message}`);
                        }
                    });
                });
                setOrUpdateObject(`${notiId}.snoozed`, {common: {type: 'boolean', role: 'indicator', name: `${displayName} Snoozed`, write: false}}, (noti.status === 'SNOOZED'));
                setOrUpdateObject(`${notiId}.delete`, {common: {type: 'boolean', role: 'button', read: false, name: `${displayName} Delete`}}, false, (value) => {
                    if (value) {
                        noti.delete(err => {
                            if (err) {
                                adapter.log.error(`Error deleting ${noti.type} ${noti.id}: ${err.message}`);
                            } else {
                                if (notificationTimer[noti.id]) {
                                    clearTimeout(notificationTimer[noti.id]);
                                    notificationTimer[noti.id] = null;
                                }
                                if (notificationTimer[`${noti.id}-customVolume`]) {
                                    clearTimeout(notificationTimer[`${noti.id}-customVolume`]);
                                    notificationTimer[`${noti.id}-customVolume`] = null;
                                }
                                if (notificationTimer[`${noti.id}-customVolumeReset`]) {
                                    clearTimeout(notificationTimer[`${noti.id}-customVolumeReset`]);
                                    notificationTimer[`${noti.id}-customVolumeReset`] = null;
                                    if (rememberedNotificationVolumeRestoreCallbacks[device.serialNumber]) {
                                        const callback = rememberedNotificationVolumeRestoreCallbacks[device.serialNumber];
                                        delete rememberedNotificationVolumeRestoreCallbacks[device.serialNumber];
                                        callback();
                                    }
                                }
                                if (adapterObjects[notiId]) {
                                    deleteObject(notiId);
                                }
                            }
                        });
                    }
                });
                setOrUpdateObject(`${notiId}.cancel`, {common: {type: 'boolean', role: 'button', read: false, name: `${displayName} Delete`}}, false, (value) => {
                    if (value) {
                        noti.cancel((err, res) => {
                            if (err | !res) {
                                adapter.log.error(`Error setting ${notiId}.cancel: ${err.message}`);
                            }
                        });
                    }
                });
                setOrUpdateObject(`${notiId}.musicProvider`, {common: {type: 'string', role: 'state', name: `${displayName} Music Provider`}}, noti.provider || null);
                setOrUpdateObject(`${notiId}.musicEntity`, {common: {type: 'string', role: 'state', name: `${displayName} Music Entity`}}, noti.musicEntity || null);
                if (device.capabilities.includes('TIMERS_ALARMS_NOTIFICATIONS_VOLUME') || device.capabilities.includes('CUSTOM_ALARM_TONE') || isMusicAlarm) {
                    setOrUpdateObject(`${notiId}.customVolume`, {
                        common: {
                            type: 'number',
                            role: 'level.volume',
                            min: 0,
                            max: 100,
                            read: true,
                            write: true,
                            name: `${displayName} Custom Notification Volume`
                        }
                    }, undefined, value => {
                        let customVolume = parseInt(value, 10);
                        if (isNaN(customVolume) || customVolume < 0 || customVolume > 100) {
                            adapter.log.error(`Invalid custom volume value ${value}`);
                            customVolume = null;
                        }
                        adapter.setState(`${notiId}.customVolume`, customVolume, true);
                    });
                }
                setOrUpdateObject(`${notiId}.triggered`, {common: {type: 'boolean', read: true, write: false, role: 'indicator', name: `${displayName} Triggered`}}, false);
                setOrUpdateObject(`${notiId}.recurringPattern`, {common: {type: 'string', read: true, write: false, role: 'state', name: `${displayName} Recurring pattern`}}, noti.recurringPattern || '0');
                if (noti.reminderLabel !== undefined && noti.reminderLabel !== null) {
                    setOrUpdateObject(`${notiId}.label`, {common: {type: 'string', read: true, write: true, role: 'text', name: `${displayName} Label`}}, noti.reminderLabel, function(noti, value) {
                        if (!value) {
                            adapter.log.error(`Label is empty for ${noti.id}`);
                            return;
                        }
                        value = value.toString();
                        alexa.getNotifications((err, res) => {
                            if (!err && res && res.notifications && Array.isArray(res.notifications)) {
                                let notificationData = null;
                                for (const n of res.notifications) {
                                    if (n.id === noti.id) {
                                        notificationData = n;
                                        break;
                                    }
                                }
                                if (!notificationData) {
                                    adapter.log.error(`Cannot find notification ${noti.id}`);
                                    return;
                                }

                                notificationData.reminderLabel = value;

                                alexa.setNotification(notificationData, (err, res) => {
                                    if (err) {
                                        adapter.log.error(`Cannot set label ${value} for notification ${noti.id}: ${err.message}`);
                                    } else {
                                        adapter.setState(`${notiId}.label`, value, true);
                                    }
                                });
                            } else {
                                adapter.log.error(`Cannot get notification to set sound: ${err.message}`);
                            }
                        });
                    }.bind(alexa, noti));
                }
                if (noti.sound !== undefined && noti.sound !== null && noti.sound.id !== undefined) {
                    const soundId = isMusicAlarm ? `MUSIC-${noti.musicAlarmId}`: noti.sound.id;
                    setOrUpdateObject(`${notiId}.sound`, {common: {type: 'string', read: true, write: true, role: 'state', name: `${displayName} Sound`, states: device.alarmNotificationSoundsStateList}}, soundId, function(noti, value) {
                        alexa.getNotifications((err, res) => {
                            if (!err && res && res.notifications && Array.isArray(res.notifications)) {
                                let notificationData = null;
                                for (const n of res.notifications) {
                                    if (n.id === noti.id) {
                                        notificationData = n;
                                        break;
                                    }
                                }
                                if (!notificationData) {
                                    adapter.log.error(`Cannot find notification ${noti.id}`);
                                    return;
                                }

                                let soundData = null;
                                for (const s of device.alarmNotificationSounds) {
                                    if (s.id === value) {
                                        soundData = s;
                                        break;
                                    }
                                }
                                if (!soundData) {
                                    adapter.log.error(`Cannot find sound ${value}`);
                                    return;
                                }
                                if (soundData.providerId === 'ECHO') {
                                    notificationData.sound = soundData;
                                    notificationData.musicEntity = null;
                                    notificationData.musicAlarmId = null;
                                    notificationData.provider = null;
                                } else {
                                    notificationData.musicEntity = soundData.displayName;
                                    notificationData.musicAlarmId = soundData.origId;
                                    notificationData.provider = soundData.providerID;
                                }

                                if (notificationData.type === 'Reminder') {
                                    alexa.setNotification(notificationData, (err, res) => {
                                        if (err) {
                                            adapter.log.error(`Cannot set sound ${value} for notification ${noti.id}: ${err.message}`);
                                        } else {
                                            adapter.setState(`${notiId}.sound`, value, true);
                                        }
                                    });
                                } else {
                                    const finalNotification = alexa.convertNotificationToV2(notificationData);
                                    alexa.setNotificationV2(notificationData.notificationIndex, finalNotification, (err, res) => {
                                        if (err) {
                                            adapter.log.error(`Cannot set sound ${value} for notification ${noti.id}: ${err.message}`);
                                        } else {
                                            adapter.setState(`${notiId}.sound`, value, true);
                                        }
                                    });
                                }
                            } else {
                                adapter.log.error(`Cannot get notification to set sound: ${err.message}`);
                            }
                        });
                    }.bind(alexa, noti));
                }
                setOrUpdateObject(`${notiId}.recurringDays`, {common: {type: 'string', read: true, write: false, role: 'state', name: `${displayName} RRuleDay List`}}, rRuleDaysList);

                let nextTriggerTime = null;

                if (noti.status === 'ON') {
                    adapter.log.debug(`Handle notification ${noti.type} ${noti.id} ${noti.status} ${noti.originalDate} ${noti.originalTime}`);
                    const now = Date.now();
                    if (noti.originalDate && noti.originalTime) {
                        const alarmTime = new Date((`${noti.originalDate} ${noti.originalTime}`).replace(/-/g, '/')).getTime();
                        if ((alarmTime - now) > 0) {
                            adapter.log.debug(`${noti.type} ${noti.id} set from original Data ${noti.originalDate} ${noti.originalTime} -> (${alarmTime}) ${(alarmTime - now) / 1000}s`);
                            nextTriggerTime = alarmTime;
                        }
                    }
                    adapter.log.debug(`${noti.type} ${noti.id} ${nextTriggerTime}`);
                    if (!nextTriggerTime && noti.rRuleData && noti.rRuleData.nextTriggerTimes && Array.isArray(noti.rRuleData.nextTriggerTimes) && noti.rRuleData.nextTriggerTimes.length) {

                        noti.rRuleData.nextTriggerTimes.forEach(rule => {
                            const alarmDate = new Date(rule);
                            if (alarmDate) {
                                const alarmTime = new Date(alarmDate).getTime();
                                adapter.log.debug(`${noti.type} ${noti.id} Check next trigger time from data: ${alarmDate.toString()} -> ${alarmTime}`);
                                if (alarmTime && (alarmTime - now) > 0 && (alarmTime < nextTriggerTime || !nextTriggerTime)) {
                                    adapter.log.debug(`${noti.type} ${noti.id} Set from next trigger time from data: ${alarmDate.toString()} -> (${alarmTime}) ${(alarmTime - now) / 1000}s`);
                                    nextTriggerTime = alarmTime;
                                }
                            }
                        });
                    }

                    if (!nextTriggerTime && (noti.recurringPattern !== '0' || noti.rRuleData)) {
                        adapter.log.debug(`${noti.type} ${noti.id} Try to calculate ourself ...`);
                        let recurStartDate = noti.originalDate;
                        let recurStartTime = time || '00:00:00';
                        let recurEndDate = null;
                        let recurEndTime = null;
                        if (noti.rRuleData) {
                            if (noti.rRuleData.recurStartDate) {
                                recurStartDate = noti.rRuleData.recurStartDate;
                            }
                            if (noti.rRuleData.recurStartTime) {
                                recurStartTime = noti.rRuleData.recurStartTime;
                            }
                            if (noti.rRuleData.recurEndDate) {
                                recurEndDate = noti.rRuleData.recurEndDate;
                            }
                            if (noti.rRuleData.recurEndTime) {
                                recurEndTime = noti.rRuleData.recurEndTime;
                            }
                        }

                        const notificationTimes = noti.rRuleData && Array.isArray(noti.rRuleData.notificationTimes) && noti.rRuleData.notificationTimes || [];
                        if (!notificationTimes.length && noti.originalTime) {
                            notificationTimes.push(noti.originalTime);
                        }
                        notificationTimes.forEach((time, index) => {
                            if (typeof time === 'string' && time.endsWith('.000')) {
                                notificationTimes[index] = time.substring(0, time.length - 4);
                            }
                        });

                        adapter.log.debug(`${noti.id} - ${recurStartDate} ${recurStartTime}`);
                        if (recurStartDate && recurStartTime) {
                            const recurringStartDate = new Date((`${recurStartDate} ${recurStartTime}`).replace(/-/g,'/'));
                            const recurringEndDate = (recurEndDate && recurEndTime) ? new Date((`${recurEndDate} ${recurEndTime}`).replace(/-/g,'/')) : null;
                            const ruleStrAdd = recurringEndDate ? `;UNTIL=${recurringEndDate.toISOString().replace(/[-:]/g, '').replace(/\.[0-9]{3}Z$/, 'Z')}` : '';
                            const ruleStrBase = `DTSTART:${recurringStartDate.toISOString().replace(/[-:]/g, '').replace(/\.[0-9]{3}Z$/, 'Z')}\nRRULE:`;

                            // We use the provided rules, else we add one ones
                            const recurRules = noti.rRuleData && noti.rRuleData.recurrenceRules || [];
                            if (!recurRules.length) {
                                if (noti.recurringPattern === 'P1D') {
                                    recurRules.push(`FREQ=DAILY;INTERVAL=1`);
                                } else if (rRuleDaysList.length) {
                                    recurRules.push(`FREQ=WEEKLY;INTERVAL=1;BYDAY=${rRuleDaysList}`);
                                }
                            }

                            const nowDate = new Date(now);
                            //nowDate.setMinutes(nowDate.getMinutes() + nowDate.getTimezoneOffset());
                            recurRules.forEach(rule => {
                                if (rule.endsWith(';')) {
                                    rule = rule.substring(0, rule.length - 1);
                                }
                                const ruleStr = ruleStrBase + rule + ruleStrAdd;

                                adapter.log.debug(`${noti.type} ${noti.id} Check recurring pattern: ${ruleStr}`);
                                let alarmDate;
                                try {
                                    alarmDate = rrulestr(ruleStr).after(nowDate, false);
                                } catch (err) {
                                    adapter.log.warn(`${noti.type} ${noti.id} Error while calculating recurring pattern: ${ruleStr}. Please report together with a debug log.`);
                                }
                                if (alarmDate) {
                                    const alarmTimeDate = new Date(alarmDate);
                                    // If there was an hour given in the RRule, we need to fix the Timezone
                                    if (rule.includes(';BYHOUR=') || rule.startsWith('BYHOUR=')) {
                                        alarmTimeDate.setMinutes(alarmTimeDate.getMinutes() + alarmTimeDate.getTimezoneOffset());
                                    }
                                    const alarmTime = alarmTimeDate.getTime();
                                    adapter.log.debug(`${noti.type} ${noti.id} Check recurring pattern: ${ruleStr} -> ${alarmTimeDate} / ${alarmTime}`);
                                    if (alarmTime && (alarmTime - now) > 0 && (alarmTime < nextTriggerTime || !nextTriggerTime)) {
                                        nextTriggerTime = alarmTime;
                                    }
                                }
                            });
                        }
                        adapter.log.debug(`${noti.type} ${noti.id} now = ${new Date(now).toString()} / ${now} / next date: ${new Date(nextTriggerTime).toString()} / ${nextTriggerTime}`);
                    }

                    const alarmDelay = (nextTriggerTime || 0) - now;
                    adapter.log.debug(`${noti.type} ${noti.id} trigger expected in ${Math.floor(alarmDelay / 1000)}s at ${new Date(nextTriggerTime).toString()}`);
                    if (alarmDelay > 0) {
                        if (alarmDelay < 14 * 24 * 60 * 60 * 1000) { // not longer then 14 days in future
                            if (notificationTimer[`${noti.id}-customVolume`]) {
                                clearTimeout(notificationTimer[`${noti.id}-customVolume`]);
                                notificationTimer[`${noti.id}-customVolume`] = null;
                            }
                            if (device.capabilities.includes('TIMERS_ALARMS_NOTIFICATIONS_VOLUME') || device.capabilities.includes('CUSTOM_ALARM_TONE') || isMusicAlarm) {
                                notificationTimer[`${noti.id}-customVolume`] = setTimeout(function (notiId, noti) {
                                    notificationTimer[`${noti.id}-customVolume`] = null;

                                    adapter.getState(`${notiId}.customVolume`, (err, state) => {
                                        if (err || !state || state.val === null) return;
                                        const customVolume = parseInt(state.val, 10);
                                        if (isNaN(customVolume) || customVolume < 0 || customVolume > 100) return;

                                        if (isMusicAlarm) {
                                            try {
                                                alexa.sendSequenceCommand(device, 'volume', customVolume, alexa.ownerCustomerId);
                                            } catch (err) {
                                                adapter.log.error(`${noti.type} ${noti.id} Error while setting volume: ${err}`);
                                            }
                                            return;
                                        }
                                        device.getDeviceNotificationState((err, origNotificationState) => {
                                            if (err || !origNotificationState || origNotificationState.volumeLevel === undefined) return;

                                            if (adapterObjects[`Echo-Devices.${device.serialNumber}.Preferences.notificationVolume`]) {
                                                adapter.setState(`Echo-Devices.${device.serialNumber}.Preferences.notificationVolume`, origNotificationState.volumeLevel, true);
                                            }
                                            device.setDeviceNotificationVolume(customVolume, err => {
                                                if (err) return;
                                                if (adapterObjects[`Echo-Devices.${device.serialNumber}.Preferences.notificationVolume`]) {
                                                    adapter.setState(`Echo-Devices.${device.serialNumber}.Preferences.notificationVolume`, customVolume, true);
                                                }
                                                if (rememberedNotificationVolumeRestoreCallbacks[device.serialNumber] === undefined) {
                                                    rememberedNotificationVolumeRestoreCallbacks[device.serialNumber] = function (notiId, noti, volumeToRestore) {
                                                        if (notificationTimer[`${noti.id}-customVolumeReset`]) {
                                                            clearTimeout(notificationTimer[`${noti.id}-customVolumeReset`]);
                                                            notificationTimer[`${noti.id}-customVolumeReset`] = null;
                                                        }
                                                        device.setDeviceNotificationVolume(volumeToRestore, err => {
                                                            if (err) return;
                                                            if (adapterObjects[`Echo-Devices.${device.serialNumber}.Preferences.notificationVolume`]) {
                                                                adapter.setState(`Echo-Devices.${device.serialNumber}.Preferences.notificationVolume`, volumeToRestore, true);
                                                            }
                                                            adapter.log.debug(`${noti.type} ${noti.id} - Reset notification volume level: ${volumeToRestore}`);
                                                            delete rememberedNotificationVolumeRestoreCallbacks[device.serialNumber];
                                                        });
                                                    }.bind(alexa, notiId, noti, origNotificationState.volumeLevel);

                                                    adapter.log.debug(`${noti.type} ${noti.id} - Remember notification volume level: ${origNotificationState.volumeLevel}`);
                                                } else {
                                                    adapter.log.debug(`${noti.type} ${noti.id} - Do not remember notification value because already set!`);
                                                }

                                                if (notificationTimer[`${noti.id}-customVolumeReset`]) {
                                                    clearTimeout(notificationTimer[`${noti.id}-customVolumeReset`]);
                                                    notificationTimer[`${noti.id}-customVolumeReset`] = null;
                                                }
                                                notificationTimer[`${noti.id}-customVolumeReset`] = setTimeout(() => {
                                                    notificationTimer[`${noti.id}-customVolumeReset`] = null;
                                                    if (rememberedNotificationVolumeRestoreCallbacks[device.serialNumber]) {
                                                        rememberedNotificationVolumeRestoreCallbacks[device.serialNumber](notiId, noti, origNotificationState.volumeLevel);
                                                    }
                                                }, 120000);

                                            });
                                        });
                                    });

                                    // Check again status after 1min if no stop was arrived
                                    notificationTimer[noti.id] = setTimeout(() => {
                                        notificationTimer[noti.id] = null;
                                        adapter.getState(`${notiId}.triggered`, (err, state) => {
                                            if (!err && state && state.val) {
                                                updateNotificationStates(device);
                                            }
                                        });
                                    }, 60000);
                                }.bind(alexa, notiId, noti), alarmDelay > 2000 ? alarmDelay - 2000 : 0);
                            }

                            if (notificationTimer[noti.id]) {
                                clearTimeout(notificationTimer[noti.id]);
                                notificationTimer[noti.id] = null;
                            }
                            notificationTimer[noti.id] = setTimeout(function (notiId, noti) {
                                notificationTimer[noti.id] = null;
                                adapter.log.debug(`${noti.type} ${noti.id} triggered`);
                                adapter.setState(`${notiId}.triggered`, true, true);
                                if (noti.type === 'Alarm') {
                                    adapter.setState(`${devId}.Alarm.triggered`, noti.notificationIndex, true);
                                } else if (noti.type === 'Reminder') {
                                    adapter.setState(`${devId}.Reminder.triggered`, noti.notificationIndex, true);
                                }
                                // Check again status after 1min if no stop was arrived
                                notificationTimer[noti.id] = setTimeout(() => {
                                    notificationTimer[noti.id] = null;
                                    adapter.getState(`${notiId}.triggered`, (err, state) => {
                                        if (!err && state && state.val) {
                                            updateNotificationStates(device);
                                        }
                                    });
                                }, 60000);
                            }.bind(alexa, notiId, noti), alarmDelay);
                        } else {
                            notificationTimer[noti.id] = setTimeout(function (noti) {
                                notificationTimer[noti.id] = null;
                                updateNotificationStates(device);
                            }.bind(alexa, noti), 14 * 24 * 60 * 60 * 1000);
                        }
                    }
                }
                setOrUpdateObject(`${notiId}.nextTriggerDate`, {common: {type: 'number', role: 'date', name: noti.reminderLabel ? noti.reminderLabel : `${displayName} Trigger Timestamp`}}, nextTriggerTime);
            }
        }
        setOrUpdateObject(`${devId}.Timer.nextTimerDate`, {common: {type: 'number', role: 'date', name: 'Unix epoch timestamp for next timer'}}, nextTimerObject ? (nextTimerObject.triggerTime || (Date.now() + nextTimerObject.remainingTime)) : 0, nextTimerObject ? nextTimerObject.set : null);
        setOrUpdateObject(`${devId}.Timer.activeTimerList`, {common: {type: 'string', role: 'array', name: 'Array of the active timers'}}, JSON.stringify(activeTimerList));
        setOrUpdateObject(`${devId}.Timer.nextTimerId`, {common: {type: 'string', role: 'text', name: 'ID of the next triggered timer'}}, nextTimerObject ? nextTimerObject.notificationIndex : null);
        setOrUpdateObject(`${devId}.Timer.stopTimerId`, {common: {type: 'string', role: 'text', name: 'ID of the timer to be stopped'}}, '', function(value) {
            if (!value) {
                return;
            }
            value = value.toString();
            const noti = device.notifications.find(n => n.notificationIndex === value);

            if (!noti) {
                adapter.log.error(`${devId} - Cannot stop timer ${value} - not found`);
                return;
            }
            noti.delete(err => {
                if (err) {
                    adapter.log.error(`${devId} - Cannot stop timer ${value} - ${err.message}`);
                } else {
                    adapter.setState(`${devId}.Timer.stopTimerId`, '', true);
                }
            });
        }.bind(alexa) );
    }
}

function updateNotificationStates(serialOrName, callback) {
    if (typeof serialOrName === 'function') {
        callback = serialOrName;
        serialOrName = null;
    }
    if (!alexa._options.notifications) return callback && callback();
    if (serialOrName) serialOrName = alexa.find(serialOrName);

    alexa.initNotifications(() => {
        Object.keys(alexa.serialNumbers).forEach ((n) => {
            const device = alexa.find(n);
            if ((serialOrName && serialOrName !== device) || (device && device.ignore)) return;

            createNotificationStates(device);
        });
        if (callback) {
            callback();
        }
        else {
            processObjectQueue();
        }
    });
}

function updatePlayerStatus(serialOrName, callback) {
    if (typeof serialOrName === 'function') {
        callback = serialOrName;
        serialOrName = null;
    }
    let serials;
    if (serialOrName) {
        serialOrName = alexa.find(serialOrName);
        if (!serialOrName) return callback && callback();
        serials = [serialOrName.serialNumber];
    }
    else {
        serials = Object.keys(playerDevices);
    }

    let i = 0;
    (function doIt() {
        if (i >= serials.length) {
            if (adapter.config.updateStateInterval > 0) {
                scheduleStatesUpdate();
            }
            return processObjectQueue(callback);
        }
        const device = alexa.find(serials[i++]);
        if (! device || !device.isControllable) return doIt();
        const devId = `Echo-Devices.${device.serialNumber}`;

        alexa.getPlayerInfo(device , (err, resPlayer) => {
            if (stopped) return;
            if (err || !resPlayer || !resPlayer.playerInfo) {
                const lastKnownPlayerState = ((lastPlayerState[device.serialNumber] && lastPlayerState[device.serialNumber].resPlayer && lastPlayerState[device.serialNumber].resPlayer.playerInfo) ? lastPlayerState[device.serialNumber].resPlayer.playerInfo.state : 'UNKNOWN') || 'UNKNOWN';
                // no player info means no player active
                const devId = `Echo-Devices.${device.serialNumber}`;
                adapter.setState(`${devId}.Player.controlPause`, lastKnownPlayerState === 'PAUSED' || (lastKnownPlayerState !== 'PLAYING' && lastKnownPlayerState !== 'FINISHED'), true);
                adapter.setState(`${devId}.Player.controlPlay`, lastKnownPlayerState === 'PLAYING', true);
                playingDevices[device.serialNumber] = lastKnownPlayerState === 'PLAYING';
                adapter.setState(`${devId}.Player.currentState`, lastKnownPlayerState === 'PLAYING', true);

                if ((lastKnownPlayerState !== 'PLAYING' && lastPlayerState[device.serialNumber] && lastPlayerState[device.serialNumber].resPlayer && lastPlayerState[device.serialNumber].resPlayer.playerInfo && lastPlayerState[device.serialNumber].resPlayer.playerInfo.isPlayingInLemur) && device.isMultiroomDevice && device.clusterMembers && playingDevices[device.serialNumber]) { // Played before but now no longer playing in group
                    device.clusterMembers.forEach(member => {
                        if (playingDevices[member]) {
                            return; // Device is updated itself while playing
                        }
                        const memberDevice = alexa.find(member);
                        if (memberDevice && memberDevice.isControllable) {
                            adapter.setState(`Echo-Devices.${memberDevice.serialNumber}.Player.playingInGroup`, false, true);
                            adapter.setState(`Echo-Devices.${memberDevice.serialNumber}.Player.playingInGroupId`, null, true);
                        }
                    });
                }

                if (initialDeviceVolumes[device.serialNumber] && device.capabilities.includes('VOLUME_SETTING')) {
                    let volume = initialDeviceVolumes[device.serialNumber].speakerVolume;
                    const muted = initialDeviceVolumes[device.serialNumber].speakerMuted;
                    if (muted !== null) adapter.setState(`${devId}.Player.muted`, muted, true);
                    if (volume === 0 && device.isMultiroomDevice) volume = null;
                    if (volume !== null) adapter.setState(`${devId}.Player.volume`, volume, true);
                    adapter.log.debug(`Initialize Volume for Device ${device.serialNumber}: volume=${volume} (muted=${muted})`);
                    delete initialDeviceVolumes[device.serialNumber];
                }
                return setTimeout(doIt, Math.floor(Math.random() * 2000) + 500);
            }

            const playerData = {
                providerName: '',
                providerId: '',
                radioStationId: '',
                service: '',
                contentType: '',
                controlShuffle: null,
                controlRepeat: null,
                imageURL: '',
                muted: null,
                volume: null,
                controlPause: false,
                controlPlay: false,
                currentState: false,
                title : '',
                artist : '',
                album : '',
                mainArtUrl : '',
                miniArtUrl : '',
                mediaLength : 0,
                mediaProgress : 0,
                mediaProgressPercent : 0,
                mediaId: '',
                queueId: '',
                quality: '',
                qualityCodec: '',
                qualityDataRate: null,
                qualitySampleRate: null,
                allowNext: false,
                allowPlayPause: false,
                allowPrevious: false,
                allowRepeat: false,
                allowShuffle: false,
                playingInGroup: false,
                playingInGroupId: ''
            };
            if (initialDeviceVolumes[device.serialNumber]) {
                playerData.volume = initialDeviceVolumes[device.serialNumber].speakerVolume;
                playerData.muted = initialDeviceVolumes[device.serialNumber].speakerMuted;
                adapter.log.debug(`Initialize Volume for Device ${device.serialNumber}: volume=${playerData.volume} (muted=${playerData.muted})`);
                delete initialDeviceVolumes[device.serialNumber];
            }

            function finalize(resMedia) {
                if (lastPlayerState[device.serialNumber] && lastPlayerState[device.serialNumber].timeout) {
                    clearTimeout(lastPlayerState[device.serialNumber].timeout);
                }
                lastPlayerState[device.serialNumber] = {
                    resPlayer,
                    resMedia,
                    ts: Date.now(),
                    devId: devId,
                    timeout: null
                };

                playerData.currentState = resPlayer.playerInfo.state === 'PLAYING';

                let mediaRemaining = 0;
                if (resPlayer.playerInfo) {
                    if (resPlayer.playerInfo.infoText) {
                        playerData.title = resPlayer.playerInfo.infoText.title;
                        playerData.artist = resPlayer.playerInfo.infoText.subText1;
                        playerData.album = resPlayer.playerInfo.infoText.subText2;
                    }

                    if (resPlayer.playerInfo.mainArt) {
                        playerData.mainArtUrl = resPlayer.playerInfo.mainArt.url;
                    }
                    if (resPlayer.playerInfo.miniArt) {
                        playerData.miniArtUrl = resPlayer.playerInfo.miniArt.url;
                    }
                    playerData.mediaId = resPlayer.playerInfo.mediaId;
                    playerData.queueId = resPlayer.playerInfo.queueId;
                    playerData.playingInGroup = resPlayer.playerInfo.isPlayingInLemur;
                    playerData.playingInGroupId = resPlayer.playerInfo.playingInLemurId;

                    if (resPlayer.playerInfo.progress) {
                        playerData.mediaLength = parseInt(resPlayer.playerInfo.progress.mediaLength || '0', 10);
                        playerData.mediaProgress = parseInt(resPlayer.playerInfo.progress.mediaProgress, 10);
                        if (playerData.mediaLength > 0) {
                            playerData.mediaProgressPercent = Math.round(((playerData.mediaProgress * 100) / playerData.mediaLength));
                            mediaRemaining = playerData.mediaLength - playerData.mediaProgress;
                        }
                    }

                    playerData.controlPause = resPlayer.playerInfo.state === 'PAUSED';
                    playerData.controlPlay = resPlayer.playerInfo.state === 'PLAYING';

                    if (resPlayer.playerInfo.quality) {
                        playerData.quality = resPlayer.playerInfo.quality.name;
                        if (resPlayer.playerInfo.quality.stats) {
                            playerData.qualityCodec = resPlayer.playerInfo.quality.stats.codec;
                            playerData.qualityDataRate = Math.round(resPlayer.playerInfo.quality.stats.dataRateInBitsPerSecond/1000);
                            playerData.qualitySampleRate = resPlayer.playerInfo.quality.stats.samplingRateInHertz;
                        }
                    }

                    if (resPlayer.playerInfo.transport) {
                        playerData.allowNext = resPlayer.playerInfo.transport.next === 'ENABLED';
                        playerData.allowPlayPause = resPlayer.playerInfo.transport.playPause === 'ENABLED';
                        playerData.allowPrevious = resPlayer.playerInfo.transport.previous === 'ENABLED';
                        playerData.allowRepeat = resPlayer.playerInfo.transport.repeat === 'ENABLED';
                        playerData.allowShuffle = resPlayer.playerInfo.transport.shuffle === 'ENABLED';
                    }
                }
                // Set States
                adapter.setState(`${devId}.Player.providerName`, playerData.providerName, true); // 'Amazon Music' | 'TuneIn Live-Radio'
                adapter.setState(`${devId}.Player.providerId`, playerData.providerId, true);
                adapter.setState(`${devId}.Player.radioStationId`, playerData.radioStationId, true); // 's24885' | null
                adapter.setState(`${devId}.Player.service`, playerData.service, true);
                adapter.setState(`${devId}.Player.contentType`, playerData.contentType, true); // 'LIVE_STATION' | 'TRACKS' | 'CUSTOM_STATION
                if (playerData.controlShuffle !== null) adapter.setState(`${devId}.Player.controlShuffle`, playerData.controlShuffle, true);
                if (playerData.controlRepeat !== null) adapter.setState(`${devId}.Player.controlRepeat`, playerData.controlRepeat, true);

                //let muted = res.playerInfo.volume.muted;
                adapter.setState(`${devId}.Player.controlPause`, playerData.controlPause, true);
                adapter.setState(`${devId}.Player.controlPlay`, playerData.controlPlay, true);

                adapter.setState(`${devId}.Player.imageURL`, playerData.imageURL, true);

                adapter.setState(`${devId}.Player.mediaId`, playerData.mediaId, true);
                adapter.setState(`${devId}.Player.queueId`, playerData.queueId, true);
                adapter.setState(`${devId}.Player.quality`, playerData.quality, true);
                adapter.setState(`${devId}.Player.qualityCodec`, playerData.qualityCodec, true);
                adapter.setState(`${devId}.Player.qualityDataRate`, playerData.qualityDataRate, true);
                adapter.setState(`${devId}.Player.qualitySampleRate`, playerData.qualitySampleRate, true);
                adapter.setState(`${devId}.Player.allowNext`, playerData.allowNext, true);
                adapter.setState(`${devId}.Player.allowPlayPause`, playerData.allowPlayPause, true);
                adapter.setState(`${devId}.Player.allowPrevious`, playerData.allowPrevious, true);
                adapter.setState(`${devId}.Player.allowRepeat`, playerData.allowRepeat, true);
                adapter.setState(`${devId}.Player.allowShuffle`, playerData.allowShuffle, true);
                adapter.setState(`${devId}.Player.playingInGroup`, playerData.playingInGroup, true);
                adapter.setState(`${devId}.Player.playingInGroupId`, playerData.playingInGroupId, true);

                if (playerData.playingInGroup && playerData.currentState && playerData.playingInGroupId && device.isMultiroomDevice && device.clusterMembers) {
                    device.clusterMembers.forEach(member => {
                        const memberDevice = alexa.find(member);
                        if (memberDevice && memberDevice.isControllable) {
                            adapter.setState(`Echo-Devices.${memberDevice.serialNumber}.Player.playingInGroup`, true, true);
                            adapter.setState(`Echo-Devices.${memberDevice.serialNumber}.Player.playingInGroupId`, playerData.playingInGroupId, true);
                        }
                    });
                } else if ((!playerData.playingInGroup || !playerData.currentState) && device.isMultiroomDevice && device.clusterMembers && playingDevices[device.serialNumber]) { // Played before but now no longer playing in group
                    device.clusterMembers.forEach(member => {
                        if (playingDevices[member]) {
                            return; // Device is updated itself while playing
                        }
                        const memberDevice = alexa.find(member);
                        if (memberDevice && memberDevice.isControllable) {
                            adapter.setState(`Echo-Devices.${memberDevice.serialNumber}.Player.playingInGroup`, false, true);
                            adapter.setState(`Echo-Devices.${memberDevice.serialNumber}.Player.playingInGroupId`, null, true);
                        }
                    });
                }
                playingDevices[device.serialNumber] = playerData.currentState;

                if (device.capabilities.includes('VOLUME_SETTING')) {
                    if (playerData.muted !== null) adapter.setState(`${devId}.Player.muted`, playerData.muted, true);
                    if (playerData.volume === 0 && device.isMultiroomDevice) playerData.volume = null;
                    if (playerData.volume !== null) adapter.setState(`${devId}.Player.volume`, playerData.volume, true);
                }

                adapter.setState(`${devId}.Player.currentState`, playerData.currentState, true);

                adapter.setState(`${devId}.Player.currentTitle`, playerData.title || '', true);
                adapter.setState(`${devId}.Player.currentArtist`, playerData.artist || '', true);
                adapter.setState(`${devId}.Player.currentAlbum`, playerData.album || '', true);

                adapter.setState(`${devId}.Player.mainArtUrl`, playerData.mainArtUrl || '', true);
                adapter.setState(`${devId}.Player.miniArtUrl`, playerData.miniArtUrl || '', true);

                adapter.setState(`${devId}.Player.mediaLength`, parseInt(playerData.mediaLength || '0', 10), true);
                adapter.setState(`${devId}.Player.mediaLengthStr`, sec2HMS(playerData.mediaLength), true);
                adapter.setState(`${devId}.Player.mediaProgress`, playerData.mediaProgress, true);
                adapter.setState(`${devId}.Player.mediaProgressStr`, sec2HMS(playerData.mediaProgress), true);
                adapter.setState(`${devId}.Player.mediaProgressPercent`, playerData.mediaProgressPercent, true);
                adapter.setState(`${devId}.Player.mediaRemaining`, mediaRemaining, true);
                adapter.setState(`${devId}.Player.mediaLengthStr`, sec2HMS(mediaRemaining), true);

                // Check Progress
                if (resPlayer.playerInfo.state === 'PLAYING') {
                    lastPlayerState[device.serialNumber].timeout = setTimeout( () => {
                        lastPlayerState[device.serialNumber].timeout = null;
                        updateMediaProgress(device.serialNumber);
                    }, 2000);
                }
                setTimeout(doIt, Math.floor(Math.random() * 2000) + 500);
            }

            if (resPlayer.playerInfo !== undefined && resPlayer.playerInfo.provider) {
                playerData.providerName = resPlayer.playerInfo.provider.providerName;
            }

            if (resPlayer.mainArt && resPlayer.mainArt.url !== undefined) playerData.mainArtUrl = resPlayer.mainArt.url;

            if (resPlayer.volume !== undefined) playerData.muted = !!resPlayer.volume.muted;
            if (resPlayer.playerInfo && resPlayer.playerInfo.volume && resPlayer.playerInfo.volume.volume !== null) {
                playerData.volume = ~~resPlayer.playerInfo.volume.volume;
            }

            if (playerData.providerName !== 'Spotify' && playerData.providerName !== '') { // Spotify Podcast -> empty providerName
                alexa.getMedia(device, (err, resMedia) => {
                    if (stopped) return;
                    if (err || !resMedia) return setTimeout(doIt, Math.floor(Math.random() * 2000) + 500);

                    if (resMedia.shuffling !== undefined) playerData.controlShuffle = resMedia.shuffling;
                    if (resMedia.looping !== undefined) playerData.controlRepeat = resMedia.looping;
                    playerData.contentType = resMedia.contentType || ''; // 'LIVE_STATION' | 'TRACKS' | 'CUSTOM_STATION'
                    if (resMedia.imageURL && resMedia.imageURL.endsWith('.')) resMedia.imageURL += 'png'; // Handle Amazon errors
                    playerData.imageURL = resMedia.imageURL || '';
                    playerData.muted = !!resMedia.muted;
                    playerData.providerId = resMedia.providerId || ''; // 'TUNE_IN' | 'CLOUD_PLAYER' | 'ROBIN'
                    playerData.radioStationId = resMedia.radioStationId || ''; // 's24885' | null
                    playerData.service = resMedia.service || ''; // 'TUNE_IN' | 'CLOUD_PLAYER' | 'PRIME_STATION'
                    if (resMedia && resMedia.volume !== undefined && resMedia.volume !== null) {
                        playerData.volume = ~~resMedia.volume;
                    }
                    finalize(resMedia);
                });
            } else {
                finalize();
            }
        });
    })();
}

function getLists(listId, callback) {
    if (typeof listId === 'function') {
        callback = listId;
        listId = null;
    }

    if (!adapter.config.synchronizeLists) {
        return callback && callback();
    }
    const allListItems = [];
    const node = 'Lists';
    alexa.getLists((err, lists) => {
        if (stopped) return;
        !listId && setOrUpdateObject(node, {type: 'device', common: { 'name': 'Lists' }});

        if (Array.isArray(lists)) {
            lists.forEach(list => {
                if (listId && list.itemId !== listId) return;
                // modify states
                list.name = list.name || list.type;
                list.id = list.name.replace(adapter.FORBIDDEN_CHARS, '-').replace(/ /g, '_').replace(/\./g, '_');
                list.listId = list.itemId;
                delete list.listIds;
                delete list.itemId;

                listMap[list.listId] = list.id;
                // create channel
                setOrUpdateObject(`${node}.${list.id}`, {
                    type: 'channel',
                    common: {name: `${ucFirst(list.name.toLowerCase().replace('list', '').replace(/_/g, ' '))} List`}
                });

                // create state for new item
                //adapter.subscribeStates(node + '.' + list.id + '.#New');
                setOrUpdateObject(`${node}.${list.id}.#New`, {
                    common: {
                        type: 'mixed',
                        role: 'state',
                        name: 'Add new list item'
                    }
                }, '', (value) => {
                    if (value) {
                        adapter.setState(`${node}.${list.id}.#New`, '', true);
                        addListItem(list, typeof value === 'string' ? {'value': value} : JSON.parse(value));
                    }
                });

                // write list contents as states
                for (const key in list) {
                    if (list[key] !== null) {
                        setOrUpdateObject(`${node}.${list.id}.${key}`, {common: listObjects[key] ? listObjects[key] : {'role': 'text'}}, list[key]);
                    }
                }

                // read list items
                adapter.log.debug(`Updating list ${list.name}...`);
                allListItems.push(updateListItems(list));
            });
        }

        Promise.all(allListItems).then(() => callback && callback());
    });
}

function addListItem(list, item) {
    adapter.log.info(`Adding item "${item.value}" (${JSON.stringify(item)}) to the list ${list.name}.`);
    alexa.addListItem(list.listId, item); // , (err, res) => updateListItems(list)
}

function updateListItem(list, item) {
    adapter.log.info(`Updating item "${item.value}" (${JSON.stringify(item)}) of the list ${list.name}.`);
    alexa.updateListItem(list.listId, item.id, item); // , (err, res) => updateListItems(list)
}

function deleteListItem(list, item) {
    adapter.log.info(`Deleting item "${item.value}" from the list ${list.name}.`);
    alexa.deleteListItem(list.listId, item.id); // , (err, res) => updateListItems(list)
}

function updateListItems(list, callback) {
    let node = `Lists.${list.id}`;
    return new Promise(resolve => {
        alexa.getListItems(list.listId, (err, items) => {
            if (stopped) return;
            setOrUpdateObject(`${node}.json`, {common: {name: 'List as json', role: 'json'}}, JSON.stringify(items));

            node = `${node}.items`;
            setOrUpdateObject(node, {type: 'channel', common: {name: 'All list items'}});

            if (Array.isArray(items)) {
                items.forEach((item, index) => {
                    item.index = index;
                    item['#delete'] = false;
                    item.listName = list.name;

                    /*
                     * EXAMPLE PAYLOAD
                     *
                    {
                        completed: true,
                        createdDateTime: 1574597641331,
                        customerId: null,
                        id: '8140fa62-XXXX-XXXX-XXXX-7380a2ccd6ab',
                        listId: 'YW16bjEuYWNXXXXXXXXXZCWFhRLVRBU0s=',
                        shoppingListItem: false,
                        updatedDateTime: 1574619085063,
                        value: 'Q',
                        version: 2
                    }
                    */

                    setOrUpdateObject(`${node}.${item.id}`, {
                        type: 'channel',
                        common: {name: `List item ${index + 1}`}
                    });
                    for (const key in item) {

                        if (item[key] !== null) {
                            if (key === '#delete') {
                                //adapter.subscribeStates(node + '.' + item.id + '.' + key);
                                setOrUpdateObject(`${node}.${item.id}.${key}`, {common: listItemsObjects[key] ? listItemsObjects[key] : {'role': 'text'}}, item[key], () => deleteListItem(list, item));
                            } else {
                                setOrUpdateObject(`${node}.${item.id}.${key}`, {common: listItemsObjects[key] ? listItemsObjects[key] : {'role': 'text'}}, item[key], ['completed', 'value'].indexOf(key) === -1 ? null : (value) => updateListItem(list, {
                                    ...item,
                                    [key]: value
                                }));
                            }
                        }
                    }
                });
            }

            callback && callback();
            resolve(true);
        });
    });
}

function initRoutines(callback) {
    alexa.getAutomationRoutines((err, routines) => {
        if (stopped) return;
        automationRoutines = [];
        routineTriggerUtterances = {};
        if (!err && routines && Array.isArray(routines)) {
            for (let i = 0; i < routines.length; i++) {
                const routine = routines[i];
                if (routine['@type'] !== 'com.amazon.alexa.behaviors.model.Automation') {
                    adapter.log.debug(`Ignore unknown type of Automation Routine ${routine['@type']}`);
                    continue;
                }
                if (!routine.sequence) {
                    adapter.log.debug(`Automation Routine has no sequence ${JSON.stringify(routine)}`);
                    continue;
                }
                let name = routine.name;
                let utteranceWords = [];
                if (routine.triggers && routine.triggers[0].payload && routine.triggers[0].payload.utterance) {
                    name = name || routine.triggers[0].payload.utterance;
                    utteranceWords = routine.triggers[0].payload.utterances || [routine.triggers[0].payload.utterance];
                }
                else if (routine.triggers && routine.triggers[0].payload && routine.triggers[0].payload.schedule && routine.triggers[0].payload.schedule.triggerTime) {
                    if (!name) {
                        name = name || routine.triggers[0].payload.schedule.triggerTime;
                        if (name.length === 6) name = name.replace(/^({0-9}{2})({0-9}{2})({0-9}{2})$/, '$1:$2:$3');
                        if (routine.triggers[0].payload.schedule.recurrence) name += ` ${routine.triggers[0].payload.schedule.recurrence}`;
                    }
                }
                else if (!name && routine.triggers && routine.triggers[0] && routine.triggers[0].type) {
                    name = name || routine.triggers[0].type.replace(/^Alexa\.Trigger\./, '');
                }
                else {
                    adapter.log.debug(`Ignore unknown type of Automation Routine Trigger${JSON.stringify(routine.triggers[0].payload)}`);
                    name = 'Unknown';
                }
                routine.friendlyName = name;
                const idSplit = routine.automationId.split('.');
                routine.friendlyAutomationId = idSplit[idSplit.length - 1];
                routine.utteranceWords = utteranceWords;
                automationRoutines.push(routine);
            }
        }
        callback && callback();
    });
}

function initCommUsers(callback) {
    alexa.getAccount((err, commOwnAccount) => {
        alexa.getHomeGroup((err, commHomeGroup) => {
            if (stopped) return;
            if (commHomeGroup && commHomeGroup.commsId) {
                alexa.commsId = commHomeGroup.commsId;
            }
            if (!commHomeGroup || !commHomeGroup.homeGroupId) {
                processObjectQueue(callback);
                return;
            }
            alexa.getContacts({homeGroupId: commHomeGroup.homeGroupId}, (err, commContacts) => {
                if (stopped) return;
                if (err || !commContacts || !Array.isArray(commContacts)) {
                    processObjectQueue(callback);
                    return;
                }
                setOrUpdateObject('Contacts', {type: 'device', common: {name: 'Communication contacts'}});

                commContacts.forEach((comEntry) => {
                    if (!comEntry.commsId || !comEntry.commsId.length || !comEntry.alexaEnabled || comEntry.commsId[0] === commHomeGroup.homeGroupId) return;

                    const contactId = comEntry.commsId[0].substr(comEntry.commsId[0].lastIndexOf('.') + 1);
                    let contactName = comEntry.name.firstName;
                    if (!contactName) {
                        contactName = comEntry.company;
                    }
                    else if (comEntry.name.lastName) {
                        contactName += ` ${comEntry.name.lastName}`;
                    }
                    if (comEntry.commsId[0] === alexa.commsId) {
                        contactName += ' (Self)';
                    }
                    contactName = contactName || 'Unknown';

                    setOrUpdateObject(`Contacts.${contactId}`, {type: 'channel', common: {name: contactName}});

                    setOrUpdateObject(`Contacts.${contactId}.textMessage`, {common: {role: 'text', def: ''}}, '', function (value) {
                        if (value === '') return;

                        alexa.sendTextMessage(comEntry.commsId[0], value, (err, res) => {
                            // Alexa-Remote: Response: {"conversationId":"amzn1.comms.messaging.id.conversationV2~b3e030bd-3ca7-4921-9084-ab16832fd1ca","messageIds":[1],"sequenceIds":[1],"time":"2019-07-21T08:49:13.522Z"}
                            //if (!err && res && res.messageIds && Array.isArray(res.messageIds) && res.messageIds.length === 1) {

                            //}
                        });
                    });

                    if (comEntry.commsId[0] === alexa.commsId) {
                        setOrUpdateObject(`Contacts.${contactId}.#clearOwnMessages`, {common: {role: 'button', type: 'boolean', read: false, write: true, def: false}}, false, function (value) {
                            alexa.getConversations((err, res) => {
                                if (stopped) return;
                                if (!err && res && res.conversations && Array.isArray(res.conversations)) {
                                    res.conversations.forEach((conversation) => {
                                        if (!conversation.participants || !conversation.participants.length || conversation.participants[0] !== alexa.commsId) return;
                                        adapter.log.debug(`Delete Conversation with ID ${conversation.conversationId}`);
                                        alexa.deleteConversation(conversation.conversationId, conversation.lastMessageId, (err, res) => {
                                            //TODO
                                        });
                                    });
                                }
                            });
                        });
                    }

                    adapter.log.debug(`Create contact "${contactName}" (${contactId})`);
                });

                processObjectQueue(callback);
            });
        });
    });
}


function loadExistingAccessories(callback) {
    adapter.getAdapterObjects((res) => {
        const objectKeys = Object.keys(res);
        for (let i = 0; i < objectKeys.length; i++) {
            if (objectKeys[i].indexOf(`${adapter.namespace}.info`) === 0) continue;
            existingStates[objectKeys[i].substr(adapter.namespace.length + 1)] = res[objectKeys[i]];
        }
        //adapter.log.debug('Existing States: ' + JSON.stringify(Object.keys(existingStates), null, 4));

        // devId + '.Bluetooth' = device , ChannelsOd = MACs
        // devId + '.Notifications' = channel, statesOf ??
        // devId + '.Routines' = channel, statesOf

        if (callback) callback();
    });
}


function main() {
    adapter.log.info('Starting Alexa2 adapter ... it can take several minutes to initialize all data. Please be patient! A done message is logged.');
    crashCheckFileName = path.join(__dirname, `crashCheck-${adapter.namespace}.json`);
    if (useCrashCheck) {
        let crashCheck = {
            startCounter: 0
        };
        try {
            if (fs.existsSync(crashCheckFileName)) {
                crashCheck = JSON.parse(fs.readFileSync(crashCheckFileName, 'utf8'));
            }
        } catch (err) {
            adapter.log.error(`Error reading crashCheck file: ${err.message}`);
        }
        crashCheck.startCounter++;
        try {
            fs.writeFileSync(crashCheckFileName, JSON.stringify(crashCheck));
        } catch (err) {
            adapter.log.error(`Error writing crashCheck file: ${err.message}`);
        }

        if (crashCheck.startCounter > 3) {
            crashCheck.startCounter = 2;
            try {
                fs.writeFileSync(crashCheckFileName, JSON.stringify(crashCheck));
            } catch (err) {
                adapter.log.error(`Error writing crashCheck file: ${err.message}`);
            }
            adapter.log.error('Adapter seems to have issues and crashed three times in a row. Disabling!! Please start again and check logs.');
            setTimeout(() => {
                isCrashStop = true; // Do not remove crash file
                adapter.terminate && adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
            }, 1000);
            return;
        }
    }

    if (!adapter.config.proxyOwnIp) {
        const ifaces = os.networkInterfaces();
        for (const eth of Object.keys(ifaces)) {
            for (let num = 0; num < ifaces[eth].length; num++) {
                if (ifaces[eth][num].family !== 'IPv6' && ifaces[eth][num].address !== '127.0.0.1' && ifaces[eth][num].address !== '0.0.0.0') {
                    adapter.config.proxyOwnIp = ifaces[eth][num].address;
                    adapter.log.info(`Proxy IP not set, use first network interface (${adapter.config.proxyOwnIp}) instead`);
                    break;
                }
            }
            if (adapter.config.proxyOwnIp) break;
        }
    }

    let proxyOwnIp = adapter.config.proxyOwnIp;
    if (adapter.config.proxyOverrideIp) {
        proxyOwnIp = adapter.config.proxyOverrideIp;
        adapter.log.info(`Use Override IP ${adapter.config.proxyOverrideIp} for Proxy`);
    }

    if (adapter.config.resetCookies) {
        adapter.config.cookieData = '';
        adapter.config.cookie = '';
    }

    const options = {
        cookie: adapter.config.cookieData || adapter.config.cookie, // cookie if there is already one
        macDms: adapter.config.macDms || (adapter.config.cookieData && adapter.config.cookieData.macDms) || undefined,
        email: '', // Amazon email for login
        password: '', // Amazon password for Login
        bluetooth: true, // fetch Bluetooth devices
        notifications: true, // fetch notifications (false because not works so far)
        userAgent: adapter.config.userAgent, // overwrite userAgent
        acceptLanguage: adapter.config.acceptLanguage, // overwrite acceptLanguage
        amazonPage: adapter.config.cookieLoginUrl, // overwrite amazonPage
        alexaServiceHost: adapter.config.alexaServiceHost, // overwrite alexa Servcie Host
        logger: adapter.log.debug, // Logger with detailed debug only in debug
        setupProxy: true,          // optional: should the library setup a proxy to get cookie when automatic way did not worked? Default false!
        proxyOwnIp: proxyOwnIp, // required if proxy enabled: provide own IP or hostname to later access the proxy. needed to setup all rewriting and proxy stuff internally
        proxyPort: adapter.config.proxyPort,           // optional: use this port for the proxy, default is 0 means random port is selected
        proxyListenBind: adapter.config.proxyListenBind,// optional: set this to bind the proxy to a special IP, default is '0.0.0.0'
        proxyLogLevel: null,      // optional: Loglevel of Proxy, default 'warn'
        usePushConnection: false,
        //deviceAppName: 'Amazon Alexa',
        formerDataStorePath: path.join(__dirname, `formerDataStore${adapter.namespace}.json`),
        apiUserAgentPostfix: `iBrokAlxa2/${require(path.join(__dirname, 'package.json')).version}`,
        usePushConnectType: 2,
        autoQueryActivityOnTrigger: adapter.config.autoQueryActivityOnTrigger,
    };
    adapter.config.updateHistoryInterval = parseInt(adapter.config.updateHistoryInterval, 10);
    if (!adapter.config.updateHistoryInterval || isNaN(adapter.config.updateHistoryInterval) || adapter.config.updateHistoryInterval < 0) {
        adapter.config.updateHistoryInterval = 0;
    }
    if (adapter.config.updateHistoryInterval !== 0 && adapter.config.updateHistoryInterval < 60) {
        adapter.config.updateHistoryInterval = 60 + Math.floor(Math.random() * 60);
        adapter.log.info(`Update History Interval is too low, set to ${adapter.config.updateHistoryInterval}s`);
    } else if (adapter.config.updateHistoryInterval !== 0 && adapter.config.updateHistoryInterval >= 60) {
        adapter.config.updateStateInterval += Math.floor(Math.random() * 10);
    } else {
        adapter.config.updateHistoryInterval = 0;
    }
    if (adapter.config.updateHistoryInterval !== 0) {
        adapter.config.updateHistoryInterval = Math.max(adapter.config.updateHistoryInterval, 60);
    }
    if (adapter.config.updateHistoryInterval > 2147482) { // max 2147483647/1000 --> 2147482
        adapter.config.updateHistoryInterval = 0;
    }
    adapter.log.debug(`Update History Interval: ${adapter.config.updateHistoryInterval !== 0 ? `${adapter.config.updateHistoryInterval}s` : 'disabled'}`);

    adapter.config.updateStateInterval = parseInt(adapter.config.updateStateInterval, 10);
    if (!adapter.config.updateStateInterval || isNaN(adapter.config.updateStateInterval) || adapter.config.updateStateInterval < 0) {
        adapter.config.updateStateInterval = 0;
    }
    if (adapter.config.updateStateInterval !== 0 && adapter.config.updateStateInterval < 300) {
        adapter.config.updateStateInterval = 300 + Math.floor(Math.random() * 60);
        adapter.log.info(`Update Device State Interval is too low, set to ${adapter.config.updateStateInterval}s`);
    } else if (adapter.config.updateStateInterval !== 0 && adapter.config.updateStateInterval >= 300) {
        adapter.config.updateStateInterval += Math.floor(Math.random() * 10);
    } else {
        adapter.config.updateStateInterval = 0;
    }
    if (adapter.config.updateStateInterval !== 0) {
        adapter.config.updateStateInterval = Math.max(adapter.config.updateStateInterval, 300);
    }
    if (adapter.config.updateStateInterval > 2147482) { // max 2147483647/1000 --> 2147482
        adapter.config.updateStateInterval = 0;
    }
    adapter.log.debug(`Update Device State Interval: ${adapter.config.updateStateInterval !== 0 ? `${adapter.config.updateStateInterval}s` : 'disabled'}`);

    adapter.config.updateConfigurationInterval = parseInt(adapter.config.updateConfigurationInterval, 10);
    if (!adapter.config.updateConfigurationInterval || isNaN(adapter.config.updateConfigurationInterval) || adapter.config.updateConfigurationInterval < 0) {
        adapter.config.updateConfigurationInterval = 0;
    }
    if (adapter.config.updateConfigurationInterval !== 0 && adapter.config.updateConfigurationInterval < 300) {
        adapter.config.updateConfigurationInterval = 3600 + Math.floor(Math.random() * 60);
        adapter.log.info(`Update Devices Configuration Interval is too low, set to ${adapter.config.updateConfigurationInterval}s`);
    } else if (adapter.config.updateConfigurationInterval !== 0 && adapter.config.updateConfigurationInterval >= 300) {
        adapter.config.updateConfigurationInterval += Math.floor(Math.random() * 10);
    } else {
        adapter.config.updateConfigurationInterval = 0;
    }
    if (adapter.config.updateConfigurationInterval !== 0) {
        adapter.config.updateConfigurationInterval = Math.max(adapter.config.updateConfigurationInterval, 300);
    }
    if (adapter.config.updateConfigurationInterval > 2147482) { // max 2147483647/1000 --> 2147482
        adapter.config.updateConfigurationInterval = 0;
    }
    adapter.log.debug(`Update Devices Configuration Interval: ${adapter.config.updateConfigurationInterval !== 0 ? `${adapter.config.updateConfigurationInterval}s` : 'disabled'}`);

    if (adapter.config.synchronizeLists === undefined) {
        adapter.config.synchronizeLists = true;
    }
    if (adapter.config.synchronizeSmartHomeDevices === undefined) {
        adapter.config.synchronizeSmartHomeDevices = true;
    }

    let connectAfterDisconnect = false;

    alexa = new Alexa();

    const origSHDQueryFunc = alexa.querySmarthomeDevices.bind(alexa);
    alexa.querySmarthomeDevices = function (toQuery, entityType, maxTimeout, callback) {
        toQuery.forEach(q => {
            if (q.entityId && q.entityId.startsWith('SKILL')) {
                shdCounters.getSkill++;
            } else {
                shdCounters.get++;
            }
        });
        origSHDQueryFunc(toQuery, entityType, maxTimeout, callback);
    };
    const origSHDExecFunc = alexa.executeSmarthomeDeviceAction.bind(alexa);
    alexa.executeSmarthomeDeviceAction = function (entityIds, parameters, entityType, callback) {
        if (!Array.isArray(entityIds)) entityIds = [entityIds];
        entityIds.forEach(id => {
            if (id.startsWith('SKILL')) {
                shdCounters.setSkill++;
            } else {
                shdCounters.set++;
            }
        });
        origSHDExecFunc(entityIds, parameters, entityType, callback);
    };

    alexa.on('ws-connect', () => {
        if (initDone && connectAfterDisconnect) {
            scheduleHistoryUpdate(2000);
            scheduleStatesUpdate(2000);
        }
        connectAfterDisconnect = false;
        pushConnected = true;
        adapter.log.info(`Alexa-Push-Connection (macDms = ${!!options.macDms}) established. Disable Polling`);
    });

    alexa.on('ws-disconnect', (retries, msg) => {
        adapter.log.info(`Alexa-Push-Connection disconnected${retries ? ' - retry' : ' - fallback to poll data'}: ${msg}`);
        if (initDone && pushConnected) {
            scheduleHistoryUpdate(2000);
            scheduleStatesUpdate(2000);
        }
        if (pushConnected) {
            connectAfterDisconnect = true;
            pushConnected = false;
        }
    });

    alexa.on('ws-error', (error) => {
        adapter.log.info(`Alexa-Push-Connection Error: ${error && error.message ? error.message :  error}`);
    });

    alexa.on('ws-unknown-message', (incomingMsg) => {
        adapter.log.info(`Alexa-Push-Connection Unknown Message - send to Developer: ${incomingMsg}`);
    });

    alexa.on('ws-device-connection-change', (data) => {
        adapter.log.debug(`Alexa-Push-Connection Device Connection change for ${data.deviceSerialNumber} -> ${data.connectionState}`);
        const device = alexa.find(data.deviceSerialNumber);
        if (!device && !appDevices[data.deviceSerialNumber]) {
            adapter.log.debug(`Please Restart Adapter. Non-Existing Device was returned: ${data.deviceSerialNumber}`);
            return;
        }
        if (!device) return;

        const devId = `Echo-Devices.${device.serialNumber}`;
        adapter.setState(`${devId}.online`, data.connectionState === 'ONLINE', true);
    });

    alexa.on('ws-bluetooth-state-change', (data) => {
        adapter.log.debug(`Alexa-Push-Connection Bluetooth State change for ${data.deviceSerialNumber} -> ${data.bluetoothEvent}`);
        const device = alexa.find(data.deviceSerialNumber);
        if (!device && !appDevices[data.deviceSerialNumber]) {
            //adapter.log.info('Please Restart Adapter. Non-Existing Device was returned: ' + data.deviceSerialNumber);
            return;
        }
        if (!device) return;

        updateBluetoothStatus(device);
    });

    alexa.on('ws-audio-player-state-change', (data) => {
        adapter.log.debug(`Alexa-Push-Connection Audio Player State change for ${data.deviceSerialNumber} -> ${data.audioPlayerState}`);
        const device = alexa.find(data.deviceSerialNumber);
        if (!device && !appDevices[data.deviceSerialNumber]) {
            //adapter.log.info('Please Restart Adapter. Non-Existing Device was returned: ' + data.deviceSerialNumber);
            return;
        }
        if (!device) return;

        if (data.audioPlayerState === 'INTERRUPTED' && lastPlayerState[device.serialNumber] && lastPlayerState[device.serialNumber].timeout) {
            clearTimeout(lastPlayerState[device.serialNumber].timeout);
            lastPlayerState[device.serialNumber].timeout = null;
        }

        if (lastPlayerState[device.serialNumber] && lastPlayerState[device.serialNumber].resPlayer && lastPlayerState[device.serialNumber].resPlayer.playerInfo) {
            lastPlayerState[device.serialNumber].resPlayer.playerInfo.state = data.audioPlayerState;
        }
        const devId = `Echo-Devices.${device.serialNumber}`;
        adapter.setState(`${devId}.Player.controlPause`, data.audioPlayerState !== 'PLAYING' && data.audioPlayerState !== 'FINISHED', true);
        adapter.setState(`${devId}.Player.controlPlay`, data.audioPlayerState === 'PLAYING', true);
        playingDevices[device.serialNumber] = data.audioPlayerState === 'PLAYING';
        adapter.setState(`${devId}.Player.currentState`, data.audioPlayerState === 'PLAYING', true);

        schedulePlayerUpdate(device.serialNumber, 1000);
    });

    alexa.on('ws-media-queue-change', (data) => {
        adapter.log.debug(`Alexa-Push-Connection Media Queue change for ${data.deviceSerialNumber} -> ${data.changeType}`);
        const device = alexa.find(data.deviceSerialNumber);
        if (!device && !appDevices[data.deviceSerialNumber]) {
            //adapter.log.info('Please Restart Adapter. Non-Existing Device was returned: ' + data.deviceSerialNumber);
            return;
        }
        if (!device) return;

        schedulePlayerUpdate(device.serialNumber, 1000);
    });

    alexa.on('ws-media-change', (data) => {
        adapter.log.debug(`Alexa-Push-Connection Media change for ${data.deviceSerialNumber}`);
        const device = alexa.find(data.deviceSerialNumber);
        if (!device) {
            //adapter.log.debug('Please Restart Adapter. Non-Existing Device was returned: ' + data.deviceSerialNumber);
            return;
        }
        if (!device) return;

        schedulePlayerUpdate(device.serialNumber, 1000);
    });

    alexa.on('ws-media-progress-change', (data) => {
        adapter.log.debug(`Alexa-Push-Connection Media Progress change for ${data.deviceSerialNumber}`);
        const device = alexa.find(data.deviceSerialNumber);
        if (!device && !appDevices[data.deviceSerialNumber]) {
            //adapter.log.info('Please Restart Adapter. Non-Existing Device was returned: ' + data.deviceSerialNumber);
            return;
        }
        if (!device) return;

        schedulePlayerUpdate(device.serialNumber, 1000);
    });

    alexa.on('ws-volume-change', (data) => {
        adapter.log.debug(`Alexa-Push-Connection Device Volume change for ${data.deviceSerialNumber} -> ${data.volume}/${data.isMuted}`);
        const device = alexa.find(data.deviceSerialNumber);
        if (!device && !appDevices[data.deviceSerialNumber]) {
            //adapter.log.info('Please Restart Adapter. Non-Existing Device was returned: ' + data.deviceSerialNumber);
            return;
        }
        if (!device) return;
        if (!device.isControllable || !device.capabilities.includes('VOLUME_SETTING')) return;

        const devId = `Echo-Devices.${device.serialNumber}`;
        let muted = !!data.isMuted;
        if (data.isMuted === null && data.volume === 0) muted = true;
        if (!muted) adapter.setState(`${devId}.Player.volume`, data.volume, true);
        adapter.setState(`${devId}.Player.muted`, muted, true);

        //schedulePlayerUpdate(device.serialNumber, 15000, true);
    });

    alexa.on('ws-content-focus-change', (data) => {
        adapter.log.debug(`Alexa-Push-Connection Content Focus change for ${data.deviceSerialNumber}`);
        const device = alexa.find(data.deviceSerialNumber);
        if (!device && !appDevices[data.deviceSerialNumber]) {
            //adapter.log.info('Please Restart Adapter. Non-Existing Device was returned: ' + data.deviceSerialNumber);
            return;
        }
        if (!device) return;

        schedulePlayerUpdate(device.serialNumber, 1000);
    });

    alexa.on('ws-device-activity', (activity) => {
        adapter.log.debug(`device-activity: ${JSON.stringify(activity)}`);
        if (activity.description.summary && routineTriggerUtterances && routineTriggerUtterances[activity.deviceSerialNumber] && routineTriggerUtterances[activity.deviceSerialNumber][activity.description.summary.toLowerCase()]) {
            adapter.setState(routineTriggerUtterances[activity.deviceSerialNumber][activity.description.summary.toLowerCase()], true, true);
        }
        updateHistoryStates(activity);
    });

    alexa.on('ws-equilizer-state-change', (data) => {
        adapter.log.debug(`Alexa-Push-Connection Equalizer change for ${data.deviceSerialNumber} -> ${data.bass}/${data.midrange}/${data.treble}`);
        const device = alexa.find(data.deviceSerialNumber);
        if (!device && !appDevices[data.deviceSerialNumber]) {
            //adapter.log.info('Please Restart Adapter. Non-Existing Device was returned: ' + data.deviceSerialNumber);
            return;
        }
        if (!device) return;

        const devId = `Echo-Devices.${device.serialNumber}`;
        if (device.capabilities.includes('EQUALIZER_CONTROLLER_BASS')) {
            adapter.setState(`${devId}.Preferences.equalizerBass`, data.bass, true);
        }
        if (device.capabilities.includes('EQUALIZER_CONTROLLER_MIDRANGE')) {
            adapter.setState(`${devId}.Preferences.equalizerMidRange`, data.midrange, true);
        }
        if (device.capabilities.includes('EQUALIZER_CONTROLLER_TREBLE')) {
            adapter.setState(`${devId}.Preferences.equalizerTreble`, data.treble, true);
        }
    });

    alexa.on('ws-unknown-command', (command, payload) => {
        adapter.log.info(`Alexa-Push-Connection Unknown Command ${command} - send to Developer: ${JSON.stringify(payload)}`);
    });

    const listsInProgress = {};
    alexa.on('ws-todo-change', (payload) => {
        if (!adapter.config.synchronizeLists) return;
        adapter.log.debug(`Received updated list (${listsInProgress[payload.listId]}): ${JSON.stringify(payload)}`);

        if (listsInProgress[payload.listId]) return;
        listsInProgress[payload.listId] = true;

        if (payload.eventType === 'listCreated' || payload.eventType === 'listUpdated') {
            getLists(payload.listId, () => {
                processObjectQueue(() => {
                    delete listsInProgress[payload.listId];
                });
            });
            return;
        }

        if (payload.eventType === 'listDeleted') {
            if (listMap[payload.listId]) {
                const node = `Lists.${listMap[payload.listId]}`;
                deleteObject(node);
            }
            delete listsInProgress[payload.listId];
            return;
        }

        alexa.getList(payload.listId, (err, list) => {
            if (stopped) return;
            if (!list || typeof list !== 'object') {
                delete listsInProgress[payload.listId];
                return;
            }
            // modify states
            list.name = list.name || list.type;
            if (!list.name) {
                delete listsInProgress[payload.listId];
                return;
            }
            list.id = list.name.replace(adapter.FORBIDDEN_CHARS, '-').replace(/ /g, '_').replace(/\./g, '_');
            list.listId = list.itemId;
            delete list.listIds;
            delete list.itemId;

            // always update list
            updateListItems(list, () => {
                processObjectQueue(() => {

                    // eventType: deleted
                    if (payload.eventType === 'itemDeleted') {

                        // delete objects
                        const node = `Lists.${list.id}.items.${payload.listItemId}`;
                        /*adapter.getObjectList({startkey: node, endkey: node + '.\u9999'}, (err, objects) => {

                            adapter.log.debug('Object list for delete for ' + node + '* : ' + JSON.stringify(objects));
                            if (objects && objects.rows) {
                                objects.rows.forEach(object => deleteObject(object.id));
                            }
                            delete listsInProgress[payload.listId];
                        });*/
                        deleteObject(node);
                    }
                    delete listsInProgress[payload.listId];
                });
            });
        });
    });

    alexa.on('ws-notification-change', (data) => {
        adapter.log.debug(`notification-change: ${JSON.stringify(data)}`);
        if (data.eventType === 'DELETE') {
            const device = alexa.find(data.deviceSerialNumber);
            if (device && device.notifications) {
                for (let i = 0; i < device.notifications.length; i++) {
                    if (notificationTimer[data.notificationId]) {
                        clearTimeout(notificationTimer[data.notificationId]);
                        notificationTimer[data.notificationId] = null;
                    }
                    if (notificationTimer[`${data.notificationId}-customVolume`]) {
                        clearTimeout(notificationTimer[`${data.notificationId}-customVolume`]);
                        notificationTimer[`${data.notificationId}-customVolume`] = null;
                    }
                    if (notificationTimer[`${data.notificationId}-customVolumeReset`]) {
                        clearTimeout(notificationTimer[`${data.notificationId}-customVolumeReset`]);
                        notificationTimer[`${data.notificationId}-customVolumeReset`] = null;
                    }
                    if (device.notifications[i].notificationIndex === data.notificationId) {
                        if (notificationTimer[device.notifications[i].id]) { // Remove Timer, will be reset if neeed in 2s
                            clearTimeout(notificationTimer[device.notifications[i].id]);
                            notificationTimer[device.notifications[i].id] = null;
                        }
                        if (notificationTimer[`${device.notifications[i].id}-customVolume`]) { // Remove Timer, will be reset if neeed in 2s
                            clearTimeout(notificationTimer[`${device.notifications[i].id}-customVolume`]);
                            notificationTimer[`${device.notifications[i].id}-customVolume`] = null;
                        }
                        if (notificationTimer[`${device.notifications[i].id}-customVolumeReset`]) { // Remove Timer, will be reset if neeed in 2s
                            clearTimeout(notificationTimer[`${device.notifications[i].id}-customVolumeReset`]);
                            notificationTimer[`${device.notifications[i].id}-customVolumeReset`] = null;
                        }
                        let type = device.notifications[i].type;
                        if (type === 'MusicAlarm') {
                            type = 'Alarm';
                        }
                        if (adapterObjects[`Echo-Devices.${data.deviceSerialNumber}.${type}.${data.notificationId}`]) {
                            if (rememberedNotificationVolumeRestoreCallbacks[device.serialNumber]) {
                                const callback = rememberedNotificationVolumeRestoreCallbacks[device.serialNumber];
                                delete rememberedNotificationVolumeRestoreCallbacks[device.serialNumber];
                                callback();
                            }
                            deleteObject(`Echo-Devices.${data.deviceSerialNumber}.${type}.${data.notificationId}`);
                        }
                        break;
                    }
                }
            }
        }
        scheduleNotificationUpdate(data.deviceSerialNumber, 2000, true);
    });

    alexa.on('cookie', (cookie, csrf, macDms) => {
        adapter.setState('info.cookie', alexa.cookie, true);
        adapter.setState('info.csrf', alexa.csrf, true);

        if (cookie !== adapter.config.cookie) {
            adapter.log.info('Update cookie in adapter configuration ... restarting ...');
            adapter.extendForeignObject(`system.adapter.${adapter.namespace}`, {
                native: {
                    cookie: alexa.cookie,
                    csrf: alexa.csrf,
                    macDms: macDms,
                    cookieData: alexa.cookieData,
                    email: '',
                    password: '',
                    resetCookies: false
                }
            });
        }
    });

    alexa.init(options, err => {
        if (err) {
            adapter.log.debug(`Error from Alexa init: ${err.message}`);
            let restartAdapter = true;
            if (err.message === 'no csrf found') {
                adapter.log.error('Error: no csrf found. Check configuration of cookie');
                restartAdapter = false;
            }
            let lines = err.message.split('Please open ');
            if (lines[1]) {
                lines[1] = `Please open ${lines[1]}`;
                proxyUrl = lines[1].substring(lines[1].indexOf('http://'), lines[1].lastIndexOf('/') + 1);
                restartAdapter = false;
            } else {
                lines = err.message.split('\n');
            }
            lines.forEach(line => adapter.log.error(`Error: ${line}`));

            adapter.setState('info.connection', false, true);

            if (!initDone && restartAdapter) {
                adapter.terminate ? adapter.terminate(utils.EXIT_CODES.START_IMMEDIATELY_AFTER_STOP) : process.exit(utils.EXIT_CODES.START_IMMEDIATELY_AFTER_STOP);
            }
            return;
        }

        if (alexa.cookie !== adapter.config.cookie) {
            return;
        }

        adapter.setState('info.connection', true, true);

        alexa.getMusicProviders((err, providers) => {
            musicProviders = [];
            if (!err && providers) {
                musicProviders = providers;
            }

            initRoutines(() => {
                getLists(() => {
                    alexa.getAllDeviceVolumes((err, deviceVolumes) => {
                        if (!err && deviceVolumes && deviceVolumes.volumes) {
                            deviceVolumes.volumes.forEach(vol => initialDeviceVolumes[vol.dsn] = vol);
                        }
                        alexa.getRoutineSoundList((err, soundList) => {
                            routineSounds = {};
                            if (!err && soundList && Array.isArray(soundList)) {
                                soundList.forEach(sound => {
                                    if (sound.availability !== 'AVAILABLE') return;
                                    routineSounds[sound.id] = sound.displayName;
                                });
                            }
                            alexa.getRoutineSkillCatalog('YourSkills', (err, skillCatalog) => {
                                routineSkills = {};
                                if (!err && skillCatalog && skillCatalog.catalog && skillCatalog.catalog.catalogItems && Array.isArray(skillCatalog.catalog.catalogItems)) {
                                    skillCatalog.catalog.catalogItems.forEach(skill => {
                                        if (skill.itemType !== 'entry' || skill.disabled || skill.catalogType !== 'action') return;
                                        routineSkills[skill.catalogId] = skill.title;
                                    });
                                }

                                adapter.log.info('Initialize all Device states ...');
                                createStates(() => {
                                    createSmarthomeStates(() => {
                                        queryAllSmartHomeDevices(true, false, () => {
                                            initCommUsers(() => {
                                                if (!initDone) {
                                                    adapter.log.info('Subscribing to states...');
                                                    adapter.subscribeStates('*');
                                                    adapter.subscribeObjects('*');
                                                    initDone = true;

                                                    updateHistory(() => {
                                                        updateDeviceConfigurationStates(() => {
                                                            if (adapter.config.usePushConnection) {
                                                                alexa.initPushConnection();
                                                            }
                                                            updatePlayerStatus( () => {
                                                                adapter.log.info('Initialization Done ...');
                                                                scheduleStatesUpdate();

                                                                if (useCrashCheck) {
                                                                    resetCrashCheckerTimeout = setTimeout(() => {
                                                                        try {
                                                                            fs.unlinkSync(crashCheckFileName);
                                                                        } catch (err) {
                                                                            adapter.log.error(`Error deleting crashCheck file: ${err.message}`);
                                                                        }
                                                                    }, 10 * 60 * 1000);
                                                                }
                                                            });
                                                        });
                                                    });
                                                    const delIds = Object.keys(existingStates);
                                                    if (delIds.length) {
                                                        adapter.log.info(`Deleting the following states: ${JSON.stringify(delIds)}`);
                                                        for (let i = 0; i < delIds.length; i++) {
                                                            if (delIds[i].startsWith('Smart-Home-Devices.') && !delIds[i].endsWith('.#includeInIntervalQuery')) continue; // TODO Do not cleanup for now, change later
                                                            try {
                                                                adapter.delObject(delIds[i], err => {
                                                                    if (err) adapter.log.info(`Can not delete object ${delIds[i]}: ${err.message}`);
                                                                });
                                                            } catch (err) {
                                                                adapter.log.info(`Can not delete object ${delIds[i]}: ${err.message}`);
                                                            }
                                                            delete existingStates[delIds[i]];
                                                        }
                                                    }
                                                    checkerInterval = setInterval(() => {
                                                        let allCalls = 0;
                                                        let allSkills = 0;
                                                        adapter.log.debug(`shdCounters: ${JSON.stringify(shdCounters)}`);
                                                        Object.keys(shdCounters).forEach(key => {
                                                            allCalls += shdCounters[key];
                                                            if (key.endsWith('Skill')) allSkills += shdCounters[key];
                                                        });
                                                        if (allCalls > 1000 || allSkills > 500) {
                                                            adapter.log.error(`Too many calls for Smart-Home-Devices in the last hour: ${allCalls} (via Skills: ${allSkills})`);
                                                            adapter.log.error('The Alexa2 Smart Home devices are NOT designed to make mass calls and generate costs at the Skill developer for each call!');
                                                            adapter.log.error('The Alexa2 Adapter will be deactivated now to prevent issues for your Amazon account, other ioBroker users of the adapter and also the Skill developers because of these mass calls.');
                                                            adapter.log.error('Please contact iobroker@fischer-ka.de to find the reason for this behaviour of your installation!');
                                                            Sentry && Sentry.withScope(scope => {
                                                                scope.setLevel('info');
                                                                scope.setExtra('requestCounters', `${JSON.stringify(shdCounters)}`);
                                                                Sentry.captureMessage(`Too many SHD requests ${installationUuid}`, 'info');
                                                            });

                                                            setTimeout(() => adapter.disable(), 2000);
                                                        }
                                                        Object.keys(shdCounters).forEach(key => shdCounters[key] = 0);
                                                    }, 60 * 60 * 1000);
                                                }
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });
}

// If started as allInOne mode => return function to create instance
if (module.parent) {
    module.exports = startAdapter;
} else {
    // or start the instance directly
    startAdapter();
}
